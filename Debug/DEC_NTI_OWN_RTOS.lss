
DEC_NTI_OWN_RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005602  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000004a  00800060  00005602  00005696  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000004ab  008000aa  008000aa  000056e0  2**0
                  ALLOC
  3 .stab         00007218  00000000  00000000  000056e0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003d60  00000000  00000000  0000c8f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  00010658  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  00010798  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  00010908  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  00012551  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  0001343c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  000141ec  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  0001434c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  000145d9  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00014da7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 aa 1c 	jmp	0x3954	; 0x3954 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 be 07 	jmp	0xf7c	; 0xf7c <__vector_10>
      2c:	0c 94 91 07 	jmp	0xf22	; 0xf22 <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 e0       	ldi	r30, 0x02	; 2
      68:	f6 e5       	ldi	r31, 0x56	; 86
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	aa 3a       	cpi	r26, 0xAA	; 170
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	15 e0       	ldi	r17, 0x05	; 5
      78:	aa ea       	ldi	r26, 0xAA	; 170
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a5 35       	cpi	r26, 0x55	; 85
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 11 2a 	call	0x5422	; 0x5422 <main>
      8a:	0c 94 ff 2a 	jmp	0x55fe	; 0x55fe <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 64 2a 	jmp	0x54c8	; 0x54c8 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a7 e7       	ldi	r26, 0x77	; 119
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 80 2a 	jmp	0x5500	; 0x5500 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 70 2a 	jmp	0x54e0	; 0x54e0 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 8c 2a 	jmp	0x5518	; 0x5518 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 70 2a 	jmp	0x54e0	; 0x54e0 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 8c 2a 	jmp	0x5518	; 0x5518 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 64 2a 	jmp	0x54c8	; 0x54c8 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	87 e7       	ldi	r24, 0x77	; 119
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 80 2a 	jmp	0x5500	; 0x5500 <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 70 2a 	jmp	0x54e0	; 0x54e0 <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 8c 2a 	jmp	0x5518	; 0x5518 <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 70 2a 	jmp	0x54e0	; 0x54e0 <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 8c 2a 	jmp	0x5518	; 0x5518 <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 70 2a 	jmp	0x54e0	; 0x54e0 <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 8c 2a 	jmp	0x5518	; 0x5518 <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 74 2a 	jmp	0x54e8	; 0x54e8 <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 90 2a 	jmp	0x5520	; 0x5520 <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <RTOS_VoInit>:

static void VidScheduler(void);

/* RTOS Initialization */
void RTOS_VoInit(void)
{
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	00 d0       	rcall	.+0      	; 0xb4c <RTOS_VoInit+0x6>
     b4c:	00 d0       	rcall	.+0      	; 0xb4e <RTOS_VoInit+0x8>
     b4e:	cd b7       	in	r28, 0x3d	; 61
     b50:	de b7       	in	r29, 0x3e	; 62
	u32 Loc_u32CTCValue;
	/* Set Timer CallBack */
	TIMER0_VidCTC_SetCallBack(VidScheduler);
     b52:	82 e3       	ldi	r24, 0x32	; 50
     b54:	96 e0       	ldi	r25, 0x06	; 6
     b56:	0e 94 7f 07 	call	0xefe	; 0xefe <TIMER0_VidCTC_SetCallBack>
	/* Set CTC Value */
	Loc_u32CTCValue= ((SYSTICK_MS*RTOS_FCPU_KHZ)/RTOS_PRESCALER);
     b5a:	8f e0       	ldi	r24, 0x0F	; 15
     b5c:	90 e0       	ldi	r25, 0x00	; 0
     b5e:	a0 e0       	ldi	r26, 0x00	; 0
     b60:	b0 e0       	ldi	r27, 0x00	; 0
     b62:	89 83       	std	Y+1, r24	; 0x01
     b64:	9a 83       	std	Y+2, r25	; 0x02
     b66:	ab 83       	std	Y+3, r26	; 0x03
     b68:	bc 83       	std	Y+4, r27	; 0x04
	TIMER0_VidSetCTCValue(Loc_u32CTCValue);
     b6a:	89 81       	ldd	r24, Y+1	; 0x01
     b6c:	0e 94 5f 07 	call	0xebe	; 0xebe <TIMER0_VidSetCTCValue>
	/* Timer Init */
	TIMER0_VidInit();
     b70:	0e 94 19 07 	call	0xe32	; 0xe32 <TIMER0_VidInit>
	/* GIE Init */
	MGIE_VidEnable();
     b74:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <MGIE_VidEnable>
}
     b78:	0f 90       	pop	r0
     b7a:	0f 90       	pop	r0
     b7c:	0f 90       	pop	r0
     b7e:	0f 90       	pop	r0
     b80:	cf 91       	pop	r28
     b82:	df 91       	pop	r29
     b84:	08 95       	ret

00000b86 <RTOS_VoCreateTask>:
/* Create Task */
void RTOS_VoCreateTask(void(*PtrToFun)(void),u32 u32Periodicty,u8 u8Priority,u8 u8first_delay)
{
     b86:	0f 93       	push	r16
     b88:	df 93       	push	r29
     b8a:	cf 93       	push	r28
     b8c:	cd b7       	in	r28, 0x3d	; 61
     b8e:	de b7       	in	r29, 0x3e	; 62
     b90:	28 97       	sbiw	r28, 0x08	; 8
     b92:	0f b6       	in	r0, 0x3f	; 63
     b94:	f8 94       	cli
     b96:	de bf       	out	0x3e, r29	; 62
     b98:	0f be       	out	0x3f, r0	; 63
     b9a:	cd bf       	out	0x3d, r28	; 61
     b9c:	9a 83       	std	Y+2, r25	; 0x02
     b9e:	89 83       	std	Y+1, r24	; 0x01
     ba0:	4b 83       	std	Y+3, r20	; 0x03
     ba2:	5c 83       	std	Y+4, r21	; 0x04
     ba4:	6d 83       	std	Y+5, r22	; 0x05
     ba6:	7e 83       	std	Y+6, r23	; 0x06
     ba8:	2f 83       	std	Y+7, r18	; 0x07
     baa:	08 87       	std	Y+8, r16	; 0x08
	if(SysTasks[u8Priority].Fun==NULL)
     bac:	8f 81       	ldd	r24, Y+7	; 0x07
     bae:	88 2f       	mov	r24, r24
     bb0:	90 e0       	ldi	r25, 0x00	; 0
     bb2:	88 0f       	add	r24, r24
     bb4:	99 1f       	adc	r25, r25
     bb6:	88 0f       	add	r24, r24
     bb8:	99 1f       	adc	r25, r25
     bba:	88 0f       	add	r24, r24
     bbc:	99 1f       	adc	r25, r25
     bbe:	fc 01       	movw	r30, r24
     bc0:	e6 55       	subi	r30, 0x56	; 86
     bc2:	ff 4f       	sbci	r31, 0xFF	; 255
     bc4:	80 81       	ld	r24, Z
     bc6:	91 81       	ldd	r25, Z+1	; 0x01
     bc8:	00 97       	sbiw	r24, 0x00	; 0
     bca:	09 f0       	breq	.+2      	; 0xbce <RTOS_VoCreateTask+0x48>
     bcc:	41 c0       	rjmp	.+130    	; 0xc50 <RTOS_VoCreateTask+0xca>
	{
	SysTasks[u8Priority].Fun=PtrToFun;
     bce:	8f 81       	ldd	r24, Y+7	; 0x07
     bd0:	88 2f       	mov	r24, r24
     bd2:	90 e0       	ldi	r25, 0x00	; 0
     bd4:	88 0f       	add	r24, r24
     bd6:	99 1f       	adc	r25, r25
     bd8:	88 0f       	add	r24, r24
     bda:	99 1f       	adc	r25, r25
     bdc:	88 0f       	add	r24, r24
     bde:	99 1f       	adc	r25, r25
     be0:	fc 01       	movw	r30, r24
     be2:	e6 55       	subi	r30, 0x56	; 86
     be4:	ff 4f       	sbci	r31, 0xFF	; 255
     be6:	89 81       	ldd	r24, Y+1	; 0x01
     be8:	9a 81       	ldd	r25, Y+2	; 0x02
     bea:	91 83       	std	Z+1, r25	; 0x01
     bec:	80 83       	st	Z, r24
	SysTasks[u8Priority].Periodicity=u32Periodicty;
     bee:	8f 81       	ldd	r24, Y+7	; 0x07
     bf0:	88 2f       	mov	r24, r24
     bf2:	90 e0       	ldi	r25, 0x00	; 0
     bf4:	88 0f       	add	r24, r24
     bf6:	99 1f       	adc	r25, r25
     bf8:	88 0f       	add	r24, r24
     bfa:	99 1f       	adc	r25, r25
     bfc:	01 96       	adiw	r24, 0x01	; 1
     bfe:	88 0f       	add	r24, r24
     c00:	99 1f       	adc	r25, r25
     c02:	fc 01       	movw	r30, r24
     c04:	e6 55       	subi	r30, 0x56	; 86
     c06:	ff 4f       	sbci	r31, 0xFF	; 255
     c08:	8b 81       	ldd	r24, Y+3	; 0x03
     c0a:	9c 81       	ldd	r25, Y+4	; 0x04
     c0c:	ad 81       	ldd	r26, Y+5	; 0x05
     c0e:	be 81       	ldd	r27, Y+6	; 0x06
     c10:	80 83       	st	Z, r24
     c12:	91 83       	std	Z+1, r25	; 0x01
     c14:	a2 83       	std	Z+2, r26	; 0x02
     c16:	b3 83       	std	Z+3, r27	; 0x03
	SysTasks[u8Priority].first_delay=u8first_delay;
     c18:	8f 81       	ldd	r24, Y+7	; 0x07
     c1a:	88 2f       	mov	r24, r24
     c1c:	90 e0       	ldi	r25, 0x00	; 0
     c1e:	88 0f       	add	r24, r24
     c20:	99 1f       	adc	r25, r25
     c22:	88 0f       	add	r24, r24
     c24:	99 1f       	adc	r25, r25
     c26:	88 0f       	add	r24, r24
     c28:	99 1f       	adc	r25, r25
     c2a:	fc 01       	movw	r30, r24
     c2c:	e0 55       	subi	r30, 0x50	; 80
     c2e:	ff 4f       	sbci	r31, 0xFF	; 255
     c30:	88 85       	ldd	r24, Y+8	; 0x08
     c32:	80 83       	st	Z, r24
	SysTasks[u8Priority].status=RESUME;
     c34:	8f 81       	ldd	r24, Y+7	; 0x07
     c36:	88 2f       	mov	r24, r24
     c38:	90 e0       	ldi	r25, 0x00	; 0
     c3a:	88 0f       	add	r24, r24
     c3c:	99 1f       	adc	r25, r25
     c3e:	88 0f       	add	r24, r24
     c40:	99 1f       	adc	r25, r25
     c42:	88 0f       	add	r24, r24
     c44:	99 1f       	adc	r25, r25
     c46:	fc 01       	movw	r30, r24
     c48:	ef 54       	subi	r30, 0x4F	; 79
     c4a:	ff 4f       	sbci	r31, 0xFF	; 255
     c4c:	81 e0       	ldi	r24, 0x01	; 1
     c4e:	80 83       	st	Z, r24
	}
}
     c50:	28 96       	adiw	r28, 0x08	; 8
     c52:	0f b6       	in	r0, 0x3f	; 63
     c54:	f8 94       	cli
     c56:	de bf       	out	0x3e, r29	; 62
     c58:	0f be       	out	0x3f, r0	; 63
     c5a:	cd bf       	out	0x3d, r28	; 61
     c5c:	cf 91       	pop	r28
     c5e:	df 91       	pop	r29
     c60:	0f 91       	pop	r16
     c62:	08 95       	ret

00000c64 <VidScheduler>:
/* select whose task is ready */
static void VidScheduler(void)
{
     c64:	df 93       	push	r29
     c66:	cf 93       	push	r28
     c68:	0f 92       	push	r0
     c6a:	cd b7       	in	r28, 0x3d	; 61
     c6c:	de b7       	in	r29, 0x3e	; 62
static u32 local_count_systick_count=0;
local_count_systick_count++;
     c6e:	80 91 c2 00 	lds	r24, 0x00C2
     c72:	90 91 c3 00 	lds	r25, 0x00C3
     c76:	a0 91 c4 00 	lds	r26, 0x00C4
     c7a:	b0 91 c5 00 	lds	r27, 0x00C5
     c7e:	01 96       	adiw	r24, 0x01	; 1
     c80:	a1 1d       	adc	r26, r1
     c82:	b1 1d       	adc	r27, r1
     c84:	80 93 c2 00 	sts	0x00C2, r24
     c88:	90 93 c3 00 	sts	0x00C3, r25
     c8c:	a0 93 c4 00 	sts	0x00C4, r26
     c90:	b0 93 c5 00 	sts	0x00C5, r27
for(u8 local_count=0;local_count<MAX_TASK;local_count++)
     c94:	19 82       	std	Y+1, r1	; 0x01
     c96:	7e c0       	rjmp	.+252    	; 0xd94 <VidScheduler+0x130>
{
	if((SysTasks[local_count].status=RESUME) && (SysTasks[local_count].Fun) != NULL)
     c98:	89 81       	ldd	r24, Y+1	; 0x01
     c9a:	88 2f       	mov	r24, r24
     c9c:	90 e0       	ldi	r25, 0x00	; 0
     c9e:	88 0f       	add	r24, r24
     ca0:	99 1f       	adc	r25, r25
     ca2:	88 0f       	add	r24, r24
     ca4:	99 1f       	adc	r25, r25
     ca6:	88 0f       	add	r24, r24
     ca8:	99 1f       	adc	r25, r25
     caa:	fc 01       	movw	r30, r24
     cac:	ef 54       	subi	r30, 0x4F	; 79
     cae:	ff 4f       	sbci	r31, 0xFF	; 255
     cb0:	81 e0       	ldi	r24, 0x01	; 1
     cb2:	80 83       	st	Z, r24
     cb4:	89 81       	ldd	r24, Y+1	; 0x01
     cb6:	88 2f       	mov	r24, r24
     cb8:	90 e0       	ldi	r25, 0x00	; 0
     cba:	88 0f       	add	r24, r24
     cbc:	99 1f       	adc	r25, r25
     cbe:	88 0f       	add	r24, r24
     cc0:	99 1f       	adc	r25, r25
     cc2:	88 0f       	add	r24, r24
     cc4:	99 1f       	adc	r25, r25
     cc6:	fc 01       	movw	r30, r24
     cc8:	e6 55       	subi	r30, 0x56	; 86
     cca:	ff 4f       	sbci	r31, 0xFF	; 255
     ccc:	80 81       	ld	r24, Z
     cce:	91 81       	ldd	r25, Z+1	; 0x01
     cd0:	00 97       	sbiw	r24, 0x00	; 0
     cd2:	09 f4       	brne	.+2      	; 0xcd6 <VidScheduler+0x72>
     cd4:	5c c0       	rjmp	.+184    	; 0xd8e <VidScheduler+0x12a>
	{
		if(SysTasks[local_count].first_delay==0)
     cd6:	89 81       	ldd	r24, Y+1	; 0x01
     cd8:	88 2f       	mov	r24, r24
     cda:	90 e0       	ldi	r25, 0x00	; 0
     cdc:	88 0f       	add	r24, r24
     cde:	99 1f       	adc	r25, r25
     ce0:	88 0f       	add	r24, r24
     ce2:	99 1f       	adc	r25, r25
     ce4:	88 0f       	add	r24, r24
     ce6:	99 1f       	adc	r25, r25
     ce8:	fc 01       	movw	r30, r24
     cea:	e0 55       	subi	r30, 0x50	; 80
     cec:	ff 4f       	sbci	r31, 0xFF	; 255
     cee:	80 81       	ld	r24, Z
     cf0:	88 23       	and	r24, r24
     cf2:	91 f5       	brne	.+100    	; 0xd58 <VidScheduler+0xf4>

	    {
		SysTasks[local_count].first_delay=SysTasks[local_count].Periodicity-1;
     cf4:	89 81       	ldd	r24, Y+1	; 0x01
     cf6:	48 2f       	mov	r20, r24
     cf8:	50 e0       	ldi	r21, 0x00	; 0
     cfa:	89 81       	ldd	r24, Y+1	; 0x01
     cfc:	88 2f       	mov	r24, r24
     cfe:	90 e0       	ldi	r25, 0x00	; 0
     d00:	88 0f       	add	r24, r24
     d02:	99 1f       	adc	r25, r25
     d04:	88 0f       	add	r24, r24
     d06:	99 1f       	adc	r25, r25
     d08:	01 96       	adiw	r24, 0x01	; 1
     d0a:	88 0f       	add	r24, r24
     d0c:	99 1f       	adc	r25, r25
     d0e:	fc 01       	movw	r30, r24
     d10:	e6 55       	subi	r30, 0x56	; 86
     d12:	ff 4f       	sbci	r31, 0xFF	; 255
     d14:	80 81       	ld	r24, Z
     d16:	91 81       	ldd	r25, Z+1	; 0x01
     d18:	a2 81       	ldd	r26, Z+2	; 0x02
     d1a:	b3 81       	ldd	r27, Z+3	; 0x03
     d1c:	28 2f       	mov	r18, r24
     d1e:	21 50       	subi	r18, 0x01	; 1
     d20:	ca 01       	movw	r24, r20
     d22:	88 0f       	add	r24, r24
     d24:	99 1f       	adc	r25, r25
     d26:	88 0f       	add	r24, r24
     d28:	99 1f       	adc	r25, r25
     d2a:	88 0f       	add	r24, r24
     d2c:	99 1f       	adc	r25, r25
     d2e:	fc 01       	movw	r30, r24
     d30:	e0 55       	subi	r30, 0x50	; 80
     d32:	ff 4f       	sbci	r31, 0xFF	; 255
     d34:	20 83       	st	Z, r18
		SysTasks[local_count].Fun();
     d36:	89 81       	ldd	r24, Y+1	; 0x01
     d38:	88 2f       	mov	r24, r24
     d3a:	90 e0       	ldi	r25, 0x00	; 0
     d3c:	88 0f       	add	r24, r24
     d3e:	99 1f       	adc	r25, r25
     d40:	88 0f       	add	r24, r24
     d42:	99 1f       	adc	r25, r25
     d44:	88 0f       	add	r24, r24
     d46:	99 1f       	adc	r25, r25
     d48:	fc 01       	movw	r30, r24
     d4a:	e6 55       	subi	r30, 0x56	; 86
     d4c:	ff 4f       	sbci	r31, 0xFF	; 255
     d4e:	01 90       	ld	r0, Z+
     d50:	f0 81       	ld	r31, Z
     d52:	e0 2d       	mov	r30, r0
     d54:	09 95       	icall
     d56:	1b c0       	rjmp	.+54     	; 0xd8e <VidScheduler+0x12a>
	    }
	    else
     	{

		SysTasks[local_count].first_delay--;
     d58:	89 81       	ldd	r24, Y+1	; 0x01
     d5a:	28 2f       	mov	r18, r24
     d5c:	30 e0       	ldi	r19, 0x00	; 0
     d5e:	c9 01       	movw	r24, r18
     d60:	88 0f       	add	r24, r24
     d62:	99 1f       	adc	r25, r25
     d64:	88 0f       	add	r24, r24
     d66:	99 1f       	adc	r25, r25
     d68:	88 0f       	add	r24, r24
     d6a:	99 1f       	adc	r25, r25
     d6c:	fc 01       	movw	r30, r24
     d6e:	e0 55       	subi	r30, 0x50	; 80
     d70:	ff 4f       	sbci	r31, 0xFF	; 255
     d72:	80 81       	ld	r24, Z
     d74:	48 2f       	mov	r20, r24
     d76:	41 50       	subi	r20, 0x01	; 1
     d78:	c9 01       	movw	r24, r18
     d7a:	88 0f       	add	r24, r24
     d7c:	99 1f       	adc	r25, r25
     d7e:	88 0f       	add	r24, r24
     d80:	99 1f       	adc	r25, r25
     d82:	88 0f       	add	r24, r24
     d84:	99 1f       	adc	r25, r25
     d86:	fc 01       	movw	r30, r24
     d88:	e0 55       	subi	r30, 0x50	; 80
     d8a:	ff 4f       	sbci	r31, 0xFF	; 255
     d8c:	40 83       	st	Z, r20
/* select whose task is ready */
static void VidScheduler(void)
{
static u32 local_count_systick_count=0;
local_count_systick_count++;
for(u8 local_count=0;local_count<MAX_TASK;local_count++)
     d8e:	89 81       	ldd	r24, Y+1	; 0x01
     d90:	8f 5f       	subi	r24, 0xFF	; 255
     d92:	89 83       	std	Y+1, r24	; 0x01
     d94:	89 81       	ldd	r24, Y+1	; 0x01
     d96:	83 30       	cpi	r24, 0x03	; 3
     d98:	08 f4       	brcc	.+2      	; 0xd9c <VidScheduler+0x138>
     d9a:	7e cf       	rjmp	.-260    	; 0xc98 <VidScheduler+0x34>
	{
		/*DO NOTHING */
	}

}
}
     d9c:	0f 90       	pop	r0
     d9e:	cf 91       	pop	r28
     da0:	df 91       	pop	r29
     da2:	08 95       	ret

00000da4 <RTOS_VoTaskResume>:
void RTOS_VoTaskResume(u8 u8Priority)
{
     da4:	df 93       	push	r29
     da6:	cf 93       	push	r28
     da8:	0f 92       	push	r0
     daa:	cd b7       	in	r28, 0x3d	; 61
     dac:	de b7       	in	r29, 0x3e	; 62
     dae:	89 83       	std	Y+1, r24	; 0x01

	SysTasks[u8Priority].status=RESUME;
     db0:	89 81       	ldd	r24, Y+1	; 0x01
     db2:	88 2f       	mov	r24, r24
     db4:	90 e0       	ldi	r25, 0x00	; 0
     db6:	88 0f       	add	r24, r24
     db8:	99 1f       	adc	r25, r25
     dba:	88 0f       	add	r24, r24
     dbc:	99 1f       	adc	r25, r25
     dbe:	88 0f       	add	r24, r24
     dc0:	99 1f       	adc	r25, r25
     dc2:	fc 01       	movw	r30, r24
     dc4:	ef 54       	subi	r30, 0x4F	; 79
     dc6:	ff 4f       	sbci	r31, 0xFF	; 255
     dc8:	81 e0       	ldi	r24, 0x01	; 1
     dca:	80 83       	st	Z, r24

}
     dcc:	0f 90       	pop	r0
     dce:	cf 91       	pop	r28
     dd0:	df 91       	pop	r29
     dd2:	08 95       	ret

00000dd4 <RTOS_VoTaskSuspend>:
void RTOS_VoTaskSuspend(u8 u8Priority)
{
     dd4:	df 93       	push	r29
     dd6:	cf 93       	push	r28
     dd8:	0f 92       	push	r0
     dda:	cd b7       	in	r28, 0x3d	; 61
     ddc:	de b7       	in	r29, 0x3e	; 62
     dde:	89 83       	std	Y+1, r24	; 0x01
	SysTasks[u8Priority].status=SUSPEND;
     de0:	89 81       	ldd	r24, Y+1	; 0x01
     de2:	88 2f       	mov	r24, r24
     de4:	90 e0       	ldi	r25, 0x00	; 0
     de6:	88 0f       	add	r24, r24
     de8:	99 1f       	adc	r25, r25
     dea:	88 0f       	add	r24, r24
     dec:	99 1f       	adc	r25, r25
     dee:	88 0f       	add	r24, r24
     df0:	99 1f       	adc	r25, r25
     df2:	fc 01       	movw	r30, r24
     df4:	ef 54       	subi	r30, 0x4F	; 79
     df6:	ff 4f       	sbci	r31, 0xFF	; 255
     df8:	10 82       	st	Z, r1

}
     dfa:	0f 90       	pop	r0
     dfc:	cf 91       	pop	r28
     dfe:	df 91       	pop	r29
     e00:	08 95       	ret

00000e02 <RTOS_VoTaskDelete>:
void RTOS_VoTaskDelete(u8 u8Priority)
{
     e02:	df 93       	push	r29
     e04:	cf 93       	push	r28
     e06:	0f 92       	push	r0
     e08:	cd b7       	in	r28, 0x3d	; 61
     e0a:	de b7       	in	r29, 0x3e	; 62
     e0c:	89 83       	std	Y+1, r24	; 0x01

	SysTasks[u8Priority].Fun=NULL;
     e0e:	89 81       	ldd	r24, Y+1	; 0x01
     e10:	88 2f       	mov	r24, r24
     e12:	90 e0       	ldi	r25, 0x00	; 0
     e14:	88 0f       	add	r24, r24
     e16:	99 1f       	adc	r25, r25
     e18:	88 0f       	add	r24, r24
     e1a:	99 1f       	adc	r25, r25
     e1c:	88 0f       	add	r24, r24
     e1e:	99 1f       	adc	r25, r25
     e20:	fc 01       	movw	r30, r24
     e22:	e6 55       	subi	r30, 0x56	; 86
     e24:	ff 4f       	sbci	r31, 0xFF	; 255
     e26:	11 82       	std	Z+1, r1	; 0x01
     e28:	10 82       	st	Z, r1

}
     e2a:	0f 90       	pop	r0
     e2c:	cf 91       	pop	r28
     e2e:	df 91       	pop	r29
     e30:	08 95       	ret

00000e32 <TIMER0_VidInit>:

void (*TIMER0_CallBack)(void);

/*Timer0 Initialization*/
void TIMER0_VidInit(void)
{
     e32:	df 93       	push	r29
     e34:	cf 93       	push	r28
     e36:	cd b7       	in	r28, 0x3d	; 61
     e38:	de b7       	in	r29, 0x3e	; 62
	/*Select the suitable Prescaler */
	TCCR0&=0xF8;
     e3a:	a3 e5       	ldi	r26, 0x53	; 83
     e3c:	b0 e0       	ldi	r27, 0x00	; 0
     e3e:	e3 e5       	ldi	r30, 0x53	; 83
     e40:	f0 e0       	ldi	r31, 0x00	; 0
     e42:	80 81       	ld	r24, Z
     e44:	88 7f       	andi	r24, 0xF8	; 248
     e46:	8c 93       	st	X, r24
	TCCR0|=TIMER_SET_PRESCALER;
     e48:	a3 e5       	ldi	r26, 0x53	; 83
     e4a:	b0 e0       	ldi	r27, 0x00	; 0
     e4c:	e3 e5       	ldi	r30, 0x53	; 83
     e4e:	f0 e0       	ldi	r31, 0x00	; 0
     e50:	80 81       	ld	r24, Z
     e52:	85 60       	ori	r24, 0x05	; 5
     e54:	8c 93       	st	X, r24
	CLR_BIT(TCCR0,3);
	/*Timer Overflow Interrupt Enable*/
	SET_BIT(TIMSK,0);

#elif TIMER0_SET_MODE == TIMER0_CTC_MODE
	CLR_BIT(TCCR0,6);
     e56:	a3 e5       	ldi	r26, 0x53	; 83
     e58:	b0 e0       	ldi	r27, 0x00	; 0
     e5a:	e3 e5       	ldi	r30, 0x53	; 83
     e5c:	f0 e0       	ldi	r31, 0x00	; 0
     e5e:	80 81       	ld	r24, Z
     e60:	8f 7b       	andi	r24, 0xBF	; 191
     e62:	8c 93       	st	X, r24
	SET_BIT(TCCR0,3);
     e64:	a3 e5       	ldi	r26, 0x53	; 83
     e66:	b0 e0       	ldi	r27, 0x00	; 0
     e68:	e3 e5       	ldi	r30, 0x53	; 83
     e6a:	f0 e0       	ldi	r31, 0x00	; 0
     e6c:	80 81       	ld	r24, Z
     e6e:	88 60       	ori	r24, 0x08	; 8
     e70:	8c 93       	st	X, r24
#if TIMER0_SET_CTC_INTERRUPT == TIMER0_CTC_INTERRUPT_ENABLED
	SET_BIT(TIMSK,1);
     e72:	a9 e5       	ldi	r26, 0x59	; 89
     e74:	b0 e0       	ldi	r27, 0x00	; 0
     e76:	e9 e5       	ldi	r30, 0x59	; 89
     e78:	f0 e0       	ldi	r31, 0x00	; 0
     e7a:	80 81       	ld	r24, Z
     e7c:	82 60       	ori	r24, 0x02	; 2
     e7e:	8c 93       	st	X, r24
	CLR_BIT(TIMSK,1);
#else
#error "TIMER0 CTC Interrupt Mode is not valid..."
#endif
#if TIMER0_SET_OC0_PIN_MODE == TIMER0_OC0_PIN_DISCONNECTED
	CLR_BIT(TCCR0,5);
     e80:	a3 e5       	ldi	r26, 0x53	; 83
     e82:	b0 e0       	ldi	r27, 0x00	; 0
     e84:	e3 e5       	ldi	r30, 0x53	; 83
     e86:	f0 e0       	ldi	r31, 0x00	; 0
     e88:	80 81       	ld	r24, Z
     e8a:	8f 7d       	andi	r24, 0xDF	; 223
     e8c:	8c 93       	st	X, r24
	CLR_BIT(TCCR0,4);
     e8e:	a3 e5       	ldi	r26, 0x53	; 83
     e90:	b0 e0       	ldi	r27, 0x00	; 0
     e92:	e3 e5       	ldi	r30, 0x53	; 83
     e94:	f0 e0       	ldi	r31, 0x00	; 0
     e96:	80 81       	ld	r24, Z
     e98:	8f 7e       	andi	r24, 0xEF	; 239
     e9a:	8c 93       	st	X, r24
#endif
#else
#error "TIMER0 Mode is not valid..."
#endif

}
     e9c:	cf 91       	pop	r28
     e9e:	df 91       	pop	r29
     ea0:	08 95       	ret

00000ea2 <TIMER0_VidSetPreload>:
/*Set Preload Function*/
void TIMER0_VidSetPreload(u8 Copy_u8Preload)
{
     ea2:	df 93       	push	r29
     ea4:	cf 93       	push	r28
     ea6:	0f 92       	push	r0
     ea8:	cd b7       	in	r28, 0x3d	; 61
     eaa:	de b7       	in	r29, 0x3e	; 62
     eac:	89 83       	std	Y+1, r24	; 0x01
	TCNT0=Copy_u8Preload;
     eae:	e2 e5       	ldi	r30, 0x52	; 82
     eb0:	f0 e0       	ldi	r31, 0x00	; 0
     eb2:	89 81       	ldd	r24, Y+1	; 0x01
     eb4:	80 83       	st	Z, r24
}
     eb6:	0f 90       	pop	r0
     eb8:	cf 91       	pop	r28
     eba:	df 91       	pop	r29
     ebc:	08 95       	ret

00000ebe <TIMER0_VidSetCTCValue>:
/*Set CTC Value Function*/
void TIMER0_VidSetCTCValue(u8 Copy_u8CTCValue)
{
     ebe:	df 93       	push	r29
     ec0:	cf 93       	push	r28
     ec2:	0f 92       	push	r0
     ec4:	cd b7       	in	r28, 0x3d	; 61
     ec6:	de b7       	in	r29, 0x3e	; 62
     ec8:	89 83       	std	Y+1, r24	; 0x01
	OCR0=Copy_u8CTCValue;
     eca:	ec e5       	ldi	r30, 0x5C	; 92
     ecc:	f0 e0       	ldi	r31, 0x00	; 0
     ece:	89 81       	ldd	r24, Y+1	; 0x01
     ed0:	80 83       	st	Z, r24
}
     ed2:	0f 90       	pop	r0
     ed4:	cf 91       	pop	r28
     ed6:	df 91       	pop	r29
     ed8:	08 95       	ret

00000eda <TIMER0_VidOVF_SetCallBack>:
void TIMER0_VidOVF_SetCallBack(void(*Copy_VidCallBack)(void))
{
     eda:	df 93       	push	r29
     edc:	cf 93       	push	r28
     ede:	00 d0       	rcall	.+0      	; 0xee0 <TIMER0_VidOVF_SetCallBack+0x6>
     ee0:	cd b7       	in	r28, 0x3d	; 61
     ee2:	de b7       	in	r29, 0x3e	; 62
     ee4:	9a 83       	std	Y+2, r25	; 0x02
     ee6:	89 83       	std	Y+1, r24	; 0x01
	TIMER0_CallBack=Copy_VidCallBack;
     ee8:	89 81       	ldd	r24, Y+1	; 0x01
     eea:	9a 81       	ldd	r25, Y+2	; 0x02
     eec:	90 93 52 05 	sts	0x0552, r25
     ef0:	80 93 51 05 	sts	0x0551, r24
}
     ef4:	0f 90       	pop	r0
     ef6:	0f 90       	pop	r0
     ef8:	cf 91       	pop	r28
     efa:	df 91       	pop	r29
     efc:	08 95       	ret

00000efe <TIMER0_VidCTC_SetCallBack>:
void TIMER0_VidCTC_SetCallBack(void(*Copy_VidCallBack)(void))
{
     efe:	df 93       	push	r29
     f00:	cf 93       	push	r28
     f02:	00 d0       	rcall	.+0      	; 0xf04 <TIMER0_VidCTC_SetCallBack+0x6>
     f04:	cd b7       	in	r28, 0x3d	; 61
     f06:	de b7       	in	r29, 0x3e	; 62
     f08:	9a 83       	std	Y+2, r25	; 0x02
     f0a:	89 83       	std	Y+1, r24	; 0x01
	TIMER0_CallBack=Copy_VidCallBack;
     f0c:	89 81       	ldd	r24, Y+1	; 0x01
     f0e:	9a 81       	ldd	r25, Y+2	; 0x02
     f10:	90 93 52 05 	sts	0x0552, r25
     f14:	80 93 51 05 	sts	0x0551, r24
}
     f18:	0f 90       	pop	r0
     f1a:	0f 90       	pop	r0
     f1c:	cf 91       	pop	r28
     f1e:	df 91       	pop	r29
     f20:	08 95       	ret

00000f22 <__vector_11>:
void __vector_11(void)   __attribute__((signal));
void __vector_11(void)
{
     f22:	1f 92       	push	r1
     f24:	0f 92       	push	r0
     f26:	0f b6       	in	r0, 0x3f	; 63
     f28:	0f 92       	push	r0
     f2a:	11 24       	eor	r1, r1
     f2c:	2f 93       	push	r18
     f2e:	3f 93       	push	r19
     f30:	4f 93       	push	r20
     f32:	5f 93       	push	r21
     f34:	6f 93       	push	r22
     f36:	7f 93       	push	r23
     f38:	8f 93       	push	r24
     f3a:	9f 93       	push	r25
     f3c:	af 93       	push	r26
     f3e:	bf 93       	push	r27
     f40:	ef 93       	push	r30
     f42:	ff 93       	push	r31
     f44:	df 93       	push	r29
     f46:	cf 93       	push	r28
     f48:	cd b7       	in	r28, 0x3d	; 61
     f4a:	de b7       	in	r29, 0x3e	; 62
	TIMER0_CallBack();
     f4c:	e0 91 51 05 	lds	r30, 0x0551
     f50:	f0 91 52 05 	lds	r31, 0x0552
     f54:	09 95       	icall
}
     f56:	cf 91       	pop	r28
     f58:	df 91       	pop	r29
     f5a:	ff 91       	pop	r31
     f5c:	ef 91       	pop	r30
     f5e:	bf 91       	pop	r27
     f60:	af 91       	pop	r26
     f62:	9f 91       	pop	r25
     f64:	8f 91       	pop	r24
     f66:	7f 91       	pop	r23
     f68:	6f 91       	pop	r22
     f6a:	5f 91       	pop	r21
     f6c:	4f 91       	pop	r20
     f6e:	3f 91       	pop	r19
     f70:	2f 91       	pop	r18
     f72:	0f 90       	pop	r0
     f74:	0f be       	out	0x3f, r0	; 63
     f76:	0f 90       	pop	r0
     f78:	1f 90       	pop	r1
     f7a:	18 95       	reti

00000f7c <__vector_10>:
void __vector_10(void)   __attribute__((signal));
void __vector_10(void)
{
     f7c:	1f 92       	push	r1
     f7e:	0f 92       	push	r0
     f80:	0f b6       	in	r0, 0x3f	; 63
     f82:	0f 92       	push	r0
     f84:	11 24       	eor	r1, r1
     f86:	2f 93       	push	r18
     f88:	3f 93       	push	r19
     f8a:	4f 93       	push	r20
     f8c:	5f 93       	push	r21
     f8e:	6f 93       	push	r22
     f90:	7f 93       	push	r23
     f92:	8f 93       	push	r24
     f94:	9f 93       	push	r25
     f96:	af 93       	push	r26
     f98:	bf 93       	push	r27
     f9a:	ef 93       	push	r30
     f9c:	ff 93       	push	r31
     f9e:	df 93       	push	r29
     fa0:	cf 93       	push	r28
     fa2:	cd b7       	in	r28, 0x3d	; 61
     fa4:	de b7       	in	r29, 0x3e	; 62
	TIMER0_CallBack();
     fa6:	e0 91 51 05 	lds	r30, 0x0551
     faa:	f0 91 52 05 	lds	r31, 0x0552
     fae:	09 95       	icall
}
     fb0:	cf 91       	pop	r28
     fb2:	df 91       	pop	r29
     fb4:	ff 91       	pop	r31
     fb6:	ef 91       	pop	r30
     fb8:	bf 91       	pop	r27
     fba:	af 91       	pop	r26
     fbc:	9f 91       	pop	r25
     fbe:	8f 91       	pop	r24
     fc0:	7f 91       	pop	r23
     fc2:	6f 91       	pop	r22
     fc4:	5f 91       	pop	r21
     fc6:	4f 91       	pop	r20
     fc8:	3f 91       	pop	r19
     fca:	2f 91       	pop	r18
     fcc:	0f 90       	pop	r0
     fce:	0f be       	out	0x3f, r0	; 63
     fd0:	0f 90       	pop	r0
     fd2:	1f 90       	pop	r1
     fd4:	18 95       	reti

00000fd6 <MGIE_VidEnable>:

#include"MGIE_Private.h"

/*GIE Enable Function*/
void MGIE_VidEnable(void)
{
     fd6:	df 93       	push	r29
     fd8:	cf 93       	push	r28
     fda:	cd b7       	in	r28, 0x3d	; 61
     fdc:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG,7);
     fde:	af e5       	ldi	r26, 0x5F	; 95
     fe0:	b0 e0       	ldi	r27, 0x00	; 0
     fe2:	ef e5       	ldi	r30, 0x5F	; 95
     fe4:	f0 e0       	ldi	r31, 0x00	; 0
     fe6:	80 81       	ld	r24, Z
     fe8:	80 68       	ori	r24, 0x80	; 128
     fea:	8c 93       	st	X, r24
}
     fec:	cf 91       	pop	r28
     fee:	df 91       	pop	r29
     ff0:	08 95       	ret

00000ff2 <MGIE_VidDisable>:
/*GIE Disable Function*/
void MGIE_VidDisable(void)
{
     ff2:	df 93       	push	r29
     ff4:	cf 93       	push	r28
     ff6:	cd b7       	in	r28, 0x3d	; 61
     ff8:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(SREG,7);
     ffa:	af e5       	ldi	r26, 0x5F	; 95
     ffc:	b0 e0       	ldi	r27, 0x00	; 0
     ffe:	ef e5       	ldi	r30, 0x5F	; 95
    1000:	f0 e0       	ldi	r31, 0x00	; 0
    1002:	80 81       	ld	r24, Z
    1004:	8f 77       	andi	r24, 0x7F	; 127
    1006:	8c 93       	st	X, r24
}
    1008:	cf 91       	pop	r28
    100a:	df 91       	pop	r29
    100c:	08 95       	ret

0000100e <MDIO_Error_State_SetPinDirection>:
#include"MDIO_Private.h"
#include"MDIO_Interface.h"

/*Set Pin Direction Function */
Error_State MDIO_Error_State_SetPinDirection(u8 Copy_u8PinNumber,u8  Copy_u8PortNumber,u8 Copy_u8PinDirection)
{
    100e:	df 93       	push	r29
    1010:	cf 93       	push	r28
    1012:	00 d0       	rcall	.+0      	; 0x1014 <MDIO_Error_State_SetPinDirection+0x6>
    1014:	00 d0       	rcall	.+0      	; 0x1016 <MDIO_Error_State_SetPinDirection+0x8>
    1016:	00 d0       	rcall	.+0      	; 0x1018 <MDIO_Error_State_SetPinDirection+0xa>
    1018:	cd b7       	in	r28, 0x3d	; 61
    101a:	de b7       	in	r29, 0x3e	; 62
    101c:	8a 83       	std	Y+2, r24	; 0x02
    101e:	6b 83       	std	Y+3, r22	; 0x03
    1020:	4c 83       	std	Y+4, r20	; 0x04
	Error_State LOC_Error_State_ReturnState=OK;
    1022:	81 e0       	ldi	r24, 0x01	; 1
    1024:	89 83       	std	Y+1, r24	; 0x01
	if((Copy_u8PinNumber>=0)&&(Copy_u8PinNumber<8))
    1026:	8a 81       	ldd	r24, Y+2	; 0x02
    1028:	88 30       	cpi	r24, 0x08	; 8
    102a:	08 f0       	brcs	.+2      	; 0x102e <MDIO_Error_State_SetPinDirection+0x20>
    102c:	e8 c0       	rjmp	.+464    	; 0x11fe <MDIO_Error_State_SetPinDirection+0x1f0>
	{
		switch(Copy_u8PortNumber)
    102e:	8b 81       	ldd	r24, Y+3	; 0x03
    1030:	28 2f       	mov	r18, r24
    1032:	30 e0       	ldi	r19, 0x00	; 0
    1034:	3e 83       	std	Y+6, r19	; 0x06
    1036:	2d 83       	std	Y+5, r18	; 0x05
    1038:	8d 81       	ldd	r24, Y+5	; 0x05
    103a:	9e 81       	ldd	r25, Y+6	; 0x06
    103c:	81 30       	cpi	r24, 0x01	; 1
    103e:	91 05       	cpc	r25, r1
    1040:	09 f4       	brne	.+2      	; 0x1044 <MDIO_Error_State_SetPinDirection+0x36>
    1042:	48 c0       	rjmp	.+144    	; 0x10d4 <MDIO_Error_State_SetPinDirection+0xc6>
    1044:	2d 81       	ldd	r18, Y+5	; 0x05
    1046:	3e 81       	ldd	r19, Y+6	; 0x06
    1048:	22 30       	cpi	r18, 0x02	; 2
    104a:	31 05       	cpc	r19, r1
    104c:	2c f4       	brge	.+10     	; 0x1058 <MDIO_Error_State_SetPinDirection+0x4a>
    104e:	8d 81       	ldd	r24, Y+5	; 0x05
    1050:	9e 81       	ldd	r25, Y+6	; 0x06
    1052:	00 97       	sbiw	r24, 0x00	; 0
    1054:	71 f0       	breq	.+28     	; 0x1072 <MDIO_Error_State_SetPinDirection+0x64>
    1056:	d1 c0       	rjmp	.+418    	; 0x11fa <MDIO_Error_State_SetPinDirection+0x1ec>
    1058:	2d 81       	ldd	r18, Y+5	; 0x05
    105a:	3e 81       	ldd	r19, Y+6	; 0x06
    105c:	22 30       	cpi	r18, 0x02	; 2
    105e:	31 05       	cpc	r19, r1
    1060:	09 f4       	brne	.+2      	; 0x1064 <MDIO_Error_State_SetPinDirection+0x56>
    1062:	69 c0       	rjmp	.+210    	; 0x1136 <MDIO_Error_State_SetPinDirection+0x128>
    1064:	8d 81       	ldd	r24, Y+5	; 0x05
    1066:	9e 81       	ldd	r25, Y+6	; 0x06
    1068:	83 30       	cpi	r24, 0x03	; 3
    106a:	91 05       	cpc	r25, r1
    106c:	09 f4       	brne	.+2      	; 0x1070 <MDIO_Error_State_SetPinDirection+0x62>
    106e:	94 c0       	rjmp	.+296    	; 0x1198 <MDIO_Error_State_SetPinDirection+0x18a>
    1070:	c4 c0       	rjmp	.+392    	; 0x11fa <MDIO_Error_State_SetPinDirection+0x1ec>
		{
		case MDIO_PORTA:
			if(Copy_u8PinDirection==PIN_OUTPUT)
    1072:	8c 81       	ldd	r24, Y+4	; 0x04
    1074:	81 30       	cpi	r24, 0x01	; 1
    1076:	a1 f4       	brne	.+40     	; 0x10a0 <MDIO_Error_State_SetPinDirection+0x92>
			{
				SET_BIT(DDRA,Copy_u8PinNumber);
    1078:	aa e3       	ldi	r26, 0x3A	; 58
    107a:	b0 e0       	ldi	r27, 0x00	; 0
    107c:	ea e3       	ldi	r30, 0x3A	; 58
    107e:	f0 e0       	ldi	r31, 0x00	; 0
    1080:	80 81       	ld	r24, Z
    1082:	48 2f       	mov	r20, r24
    1084:	8a 81       	ldd	r24, Y+2	; 0x02
    1086:	28 2f       	mov	r18, r24
    1088:	30 e0       	ldi	r19, 0x00	; 0
    108a:	81 e0       	ldi	r24, 0x01	; 1
    108c:	90 e0       	ldi	r25, 0x00	; 0
    108e:	02 2e       	mov	r0, r18
    1090:	02 c0       	rjmp	.+4      	; 0x1096 <MDIO_Error_State_SetPinDirection+0x88>
    1092:	88 0f       	add	r24, r24
    1094:	99 1f       	adc	r25, r25
    1096:	0a 94       	dec	r0
    1098:	e2 f7       	brpl	.-8      	; 0x1092 <MDIO_Error_State_SetPinDirection+0x84>
    109a:	84 2b       	or	r24, r20
    109c:	8c 93       	st	X, r24
    109e:	b0 c0       	rjmp	.+352    	; 0x1200 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
    10a0:	8c 81       	ldd	r24, Y+4	; 0x04
    10a2:	88 23       	and	r24, r24
    10a4:	a9 f4       	brne	.+42     	; 0x10d0 <MDIO_Error_State_SetPinDirection+0xc2>
			{
				CLR_BIT(DDRA,Copy_u8PinNumber);
    10a6:	aa e3       	ldi	r26, 0x3A	; 58
    10a8:	b0 e0       	ldi	r27, 0x00	; 0
    10aa:	ea e3       	ldi	r30, 0x3A	; 58
    10ac:	f0 e0       	ldi	r31, 0x00	; 0
    10ae:	80 81       	ld	r24, Z
    10b0:	48 2f       	mov	r20, r24
    10b2:	8a 81       	ldd	r24, Y+2	; 0x02
    10b4:	28 2f       	mov	r18, r24
    10b6:	30 e0       	ldi	r19, 0x00	; 0
    10b8:	81 e0       	ldi	r24, 0x01	; 1
    10ba:	90 e0       	ldi	r25, 0x00	; 0
    10bc:	02 2e       	mov	r0, r18
    10be:	02 c0       	rjmp	.+4      	; 0x10c4 <MDIO_Error_State_SetPinDirection+0xb6>
    10c0:	88 0f       	add	r24, r24
    10c2:	99 1f       	adc	r25, r25
    10c4:	0a 94       	dec	r0
    10c6:	e2 f7       	brpl	.-8      	; 0x10c0 <MDIO_Error_State_SetPinDirection+0xb2>
    10c8:	80 95       	com	r24
    10ca:	84 23       	and	r24, r20
    10cc:	8c 93       	st	X, r24
    10ce:	98 c0       	rjmp	.+304    	; 0x1200 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    10d0:	19 82       	std	Y+1, r1	; 0x01
    10d2:	96 c0       	rjmp	.+300    	; 0x1200 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			break;
		case MDIO_PORTB:
			if(Copy_u8PinDirection==PIN_OUTPUT)
    10d4:	8c 81       	ldd	r24, Y+4	; 0x04
    10d6:	81 30       	cpi	r24, 0x01	; 1
    10d8:	a1 f4       	brne	.+40     	; 0x1102 <MDIO_Error_State_SetPinDirection+0xf4>
			{
				SET_BIT(DDRB,Copy_u8PinNumber);
    10da:	a7 e3       	ldi	r26, 0x37	; 55
    10dc:	b0 e0       	ldi	r27, 0x00	; 0
    10de:	e7 e3       	ldi	r30, 0x37	; 55
    10e0:	f0 e0       	ldi	r31, 0x00	; 0
    10e2:	80 81       	ld	r24, Z
    10e4:	48 2f       	mov	r20, r24
    10e6:	8a 81       	ldd	r24, Y+2	; 0x02
    10e8:	28 2f       	mov	r18, r24
    10ea:	30 e0       	ldi	r19, 0x00	; 0
    10ec:	81 e0       	ldi	r24, 0x01	; 1
    10ee:	90 e0       	ldi	r25, 0x00	; 0
    10f0:	02 2e       	mov	r0, r18
    10f2:	02 c0       	rjmp	.+4      	; 0x10f8 <MDIO_Error_State_SetPinDirection+0xea>
    10f4:	88 0f       	add	r24, r24
    10f6:	99 1f       	adc	r25, r25
    10f8:	0a 94       	dec	r0
    10fa:	e2 f7       	brpl	.-8      	; 0x10f4 <MDIO_Error_State_SetPinDirection+0xe6>
    10fc:	84 2b       	or	r24, r20
    10fe:	8c 93       	st	X, r24
    1100:	7f c0       	rjmp	.+254    	; 0x1200 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
    1102:	8c 81       	ldd	r24, Y+4	; 0x04
    1104:	88 23       	and	r24, r24
    1106:	a9 f4       	brne	.+42     	; 0x1132 <MDIO_Error_State_SetPinDirection+0x124>
			{
				CLR_BIT(DDRB,Copy_u8PinNumber);
    1108:	a7 e3       	ldi	r26, 0x37	; 55
    110a:	b0 e0       	ldi	r27, 0x00	; 0
    110c:	e7 e3       	ldi	r30, 0x37	; 55
    110e:	f0 e0       	ldi	r31, 0x00	; 0
    1110:	80 81       	ld	r24, Z
    1112:	48 2f       	mov	r20, r24
    1114:	8a 81       	ldd	r24, Y+2	; 0x02
    1116:	28 2f       	mov	r18, r24
    1118:	30 e0       	ldi	r19, 0x00	; 0
    111a:	81 e0       	ldi	r24, 0x01	; 1
    111c:	90 e0       	ldi	r25, 0x00	; 0
    111e:	02 2e       	mov	r0, r18
    1120:	02 c0       	rjmp	.+4      	; 0x1126 <MDIO_Error_State_SetPinDirection+0x118>
    1122:	88 0f       	add	r24, r24
    1124:	99 1f       	adc	r25, r25
    1126:	0a 94       	dec	r0
    1128:	e2 f7       	brpl	.-8      	; 0x1122 <MDIO_Error_State_SetPinDirection+0x114>
    112a:	80 95       	com	r24
    112c:	84 23       	and	r24, r20
    112e:	8c 93       	st	X, r24
    1130:	67 c0       	rjmp	.+206    	; 0x1200 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    1132:	19 82       	std	Y+1, r1	; 0x01
    1134:	65 c0       	rjmp	.+202    	; 0x1200 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			break;
		case MDIO_PORTC:
			if(Copy_u8PinDirection==PIN_OUTPUT)
    1136:	8c 81       	ldd	r24, Y+4	; 0x04
    1138:	81 30       	cpi	r24, 0x01	; 1
    113a:	a1 f4       	brne	.+40     	; 0x1164 <MDIO_Error_State_SetPinDirection+0x156>
			{
				SET_BIT(DDRC,Copy_u8PinNumber);
    113c:	a4 e3       	ldi	r26, 0x34	; 52
    113e:	b0 e0       	ldi	r27, 0x00	; 0
    1140:	e4 e3       	ldi	r30, 0x34	; 52
    1142:	f0 e0       	ldi	r31, 0x00	; 0
    1144:	80 81       	ld	r24, Z
    1146:	48 2f       	mov	r20, r24
    1148:	8a 81       	ldd	r24, Y+2	; 0x02
    114a:	28 2f       	mov	r18, r24
    114c:	30 e0       	ldi	r19, 0x00	; 0
    114e:	81 e0       	ldi	r24, 0x01	; 1
    1150:	90 e0       	ldi	r25, 0x00	; 0
    1152:	02 2e       	mov	r0, r18
    1154:	02 c0       	rjmp	.+4      	; 0x115a <MDIO_Error_State_SetPinDirection+0x14c>
    1156:	88 0f       	add	r24, r24
    1158:	99 1f       	adc	r25, r25
    115a:	0a 94       	dec	r0
    115c:	e2 f7       	brpl	.-8      	; 0x1156 <MDIO_Error_State_SetPinDirection+0x148>
    115e:	84 2b       	or	r24, r20
    1160:	8c 93       	st	X, r24
    1162:	4e c0       	rjmp	.+156    	; 0x1200 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
    1164:	8c 81       	ldd	r24, Y+4	; 0x04
    1166:	88 23       	and	r24, r24
    1168:	a9 f4       	brne	.+42     	; 0x1194 <MDIO_Error_State_SetPinDirection+0x186>
			{
				CLR_BIT(DDRC,Copy_u8PinNumber);
    116a:	a4 e3       	ldi	r26, 0x34	; 52
    116c:	b0 e0       	ldi	r27, 0x00	; 0
    116e:	e4 e3       	ldi	r30, 0x34	; 52
    1170:	f0 e0       	ldi	r31, 0x00	; 0
    1172:	80 81       	ld	r24, Z
    1174:	48 2f       	mov	r20, r24
    1176:	8a 81       	ldd	r24, Y+2	; 0x02
    1178:	28 2f       	mov	r18, r24
    117a:	30 e0       	ldi	r19, 0x00	; 0
    117c:	81 e0       	ldi	r24, 0x01	; 1
    117e:	90 e0       	ldi	r25, 0x00	; 0
    1180:	02 2e       	mov	r0, r18
    1182:	02 c0       	rjmp	.+4      	; 0x1188 <MDIO_Error_State_SetPinDirection+0x17a>
    1184:	88 0f       	add	r24, r24
    1186:	99 1f       	adc	r25, r25
    1188:	0a 94       	dec	r0
    118a:	e2 f7       	brpl	.-8      	; 0x1184 <MDIO_Error_State_SetPinDirection+0x176>
    118c:	80 95       	com	r24
    118e:	84 23       	and	r24, r20
    1190:	8c 93       	st	X, r24
    1192:	36 c0       	rjmp	.+108    	; 0x1200 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    1194:	19 82       	std	Y+1, r1	; 0x01
    1196:	34 c0       	rjmp	.+104    	; 0x1200 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			break;	
		case MDIO_PORTD:
			if(Copy_u8PinDirection==PIN_OUTPUT)
    1198:	8c 81       	ldd	r24, Y+4	; 0x04
    119a:	81 30       	cpi	r24, 0x01	; 1
    119c:	a1 f4       	brne	.+40     	; 0x11c6 <MDIO_Error_State_SetPinDirection+0x1b8>
			{
				SET_BIT(DDRD,Copy_u8PinNumber);
    119e:	a1 e3       	ldi	r26, 0x31	; 49
    11a0:	b0 e0       	ldi	r27, 0x00	; 0
    11a2:	e1 e3       	ldi	r30, 0x31	; 49
    11a4:	f0 e0       	ldi	r31, 0x00	; 0
    11a6:	80 81       	ld	r24, Z
    11a8:	48 2f       	mov	r20, r24
    11aa:	8a 81       	ldd	r24, Y+2	; 0x02
    11ac:	28 2f       	mov	r18, r24
    11ae:	30 e0       	ldi	r19, 0x00	; 0
    11b0:	81 e0       	ldi	r24, 0x01	; 1
    11b2:	90 e0       	ldi	r25, 0x00	; 0
    11b4:	02 2e       	mov	r0, r18
    11b6:	02 c0       	rjmp	.+4      	; 0x11bc <MDIO_Error_State_SetPinDirection+0x1ae>
    11b8:	88 0f       	add	r24, r24
    11ba:	99 1f       	adc	r25, r25
    11bc:	0a 94       	dec	r0
    11be:	e2 f7       	brpl	.-8      	; 0x11b8 <MDIO_Error_State_SetPinDirection+0x1aa>
    11c0:	84 2b       	or	r24, r20
    11c2:	8c 93       	st	X, r24
    11c4:	1d c0       	rjmp	.+58     	; 0x1200 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else if(Copy_u8PinDirection==PIN_INPUT)
    11c6:	8c 81       	ldd	r24, Y+4	; 0x04
    11c8:	88 23       	and	r24, r24
    11ca:	a9 f4       	brne	.+42     	; 0x11f6 <MDIO_Error_State_SetPinDirection+0x1e8>
			{
				CLR_BIT(DDRD,Copy_u8PinNumber);
    11cc:	a1 e3       	ldi	r26, 0x31	; 49
    11ce:	b0 e0       	ldi	r27, 0x00	; 0
    11d0:	e1 e3       	ldi	r30, 0x31	; 49
    11d2:	f0 e0       	ldi	r31, 0x00	; 0
    11d4:	80 81       	ld	r24, Z
    11d6:	48 2f       	mov	r20, r24
    11d8:	8a 81       	ldd	r24, Y+2	; 0x02
    11da:	28 2f       	mov	r18, r24
    11dc:	30 e0       	ldi	r19, 0x00	; 0
    11de:	81 e0       	ldi	r24, 0x01	; 1
    11e0:	90 e0       	ldi	r25, 0x00	; 0
    11e2:	02 2e       	mov	r0, r18
    11e4:	02 c0       	rjmp	.+4      	; 0x11ea <MDIO_Error_State_SetPinDirection+0x1dc>
    11e6:	88 0f       	add	r24, r24
    11e8:	99 1f       	adc	r25, r25
    11ea:	0a 94       	dec	r0
    11ec:	e2 f7       	brpl	.-8      	; 0x11e6 <MDIO_Error_State_SetPinDirection+0x1d8>
    11ee:	80 95       	com	r24
    11f0:	84 23       	and	r24, r20
    11f2:	8c 93       	st	X, r24
    11f4:	05 c0       	rjmp	.+10     	; 0x1200 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    11f6:	19 82       	std	Y+1, r1	; 0x01
    11f8:	03 c0       	rjmp	.+6      	; 0x1200 <MDIO_Error_State_SetPinDirection+0x1f2>
			}
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    11fa:	19 82       	std	Y+1, r1	; 0x01
    11fc:	01 c0       	rjmp	.+2      	; 0x1200 <MDIO_Error_State_SetPinDirection+0x1f2>
			break;
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    11fe:	19 82       	std	Y+1, r1	; 0x01
	}

	return LOC_Error_State_ReturnState;
    1200:	89 81       	ldd	r24, Y+1	; 0x01
}
    1202:	26 96       	adiw	r28, 0x06	; 6
    1204:	0f b6       	in	r0, 0x3f	; 63
    1206:	f8 94       	cli
    1208:	de bf       	out	0x3e, r29	; 62
    120a:	0f be       	out	0x3f, r0	; 63
    120c:	cd bf       	out	0x3d, r28	; 61
    120e:	cf 91       	pop	r28
    1210:	df 91       	pop	r29
    1212:	08 95       	ret

00001214 <MDIO_Error_State_SetPortDirection>:
/*Set Port Direction Function */
Error_State MDIO_Error_State_SetPortDirection(u8 Copy_u8PortNumber,u8 Copy_u8PortDirection)
{
    1214:	df 93       	push	r29
    1216:	cf 93       	push	r28
    1218:	00 d0       	rcall	.+0      	; 0x121a <MDIO_Error_State_SetPortDirection+0x6>
    121a:	00 d0       	rcall	.+0      	; 0x121c <MDIO_Error_State_SetPortDirection+0x8>
    121c:	0f 92       	push	r0
    121e:	cd b7       	in	r28, 0x3d	; 61
    1220:	de b7       	in	r29, 0x3e	; 62
    1222:	8a 83       	std	Y+2, r24	; 0x02
    1224:	6b 83       	std	Y+3, r22	; 0x03
	Error_State LOC_Error_State_ReturnState=OK;
    1226:	81 e0       	ldi	r24, 0x01	; 1
    1228:	89 83       	std	Y+1, r24	; 0x01
	if((Copy_u8PortDirection==PORT_OUTPUT)||(Copy_u8PortDirection==PORT_INPUT))
    122a:	8b 81       	ldd	r24, Y+3	; 0x03
    122c:	8f 3f       	cpi	r24, 0xFF	; 255
    122e:	19 f0       	breq	.+6      	; 0x1236 <MDIO_Error_State_SetPortDirection+0x22>
    1230:	8b 81       	ldd	r24, Y+3	; 0x03
    1232:	88 23       	and	r24, r24
    1234:	a9 f5       	brne	.+106    	; 0x12a0 <MDIO_Error_State_SetPortDirection+0x8c>
	{
		switch(Copy_u8PortNumber)
    1236:	8a 81       	ldd	r24, Y+2	; 0x02
    1238:	28 2f       	mov	r18, r24
    123a:	30 e0       	ldi	r19, 0x00	; 0
    123c:	3d 83       	std	Y+5, r19	; 0x05
    123e:	2c 83       	std	Y+4, r18	; 0x04
    1240:	8c 81       	ldd	r24, Y+4	; 0x04
    1242:	9d 81       	ldd	r25, Y+5	; 0x05
    1244:	81 30       	cpi	r24, 0x01	; 1
    1246:	91 05       	cpc	r25, r1
    1248:	d1 f0       	breq	.+52     	; 0x127e <MDIO_Error_State_SetPortDirection+0x6a>
    124a:	2c 81       	ldd	r18, Y+4	; 0x04
    124c:	3d 81       	ldd	r19, Y+5	; 0x05
    124e:	22 30       	cpi	r18, 0x02	; 2
    1250:	31 05       	cpc	r19, r1
    1252:	2c f4       	brge	.+10     	; 0x125e <MDIO_Error_State_SetPortDirection+0x4a>
    1254:	8c 81       	ldd	r24, Y+4	; 0x04
    1256:	9d 81       	ldd	r25, Y+5	; 0x05
    1258:	00 97       	sbiw	r24, 0x00	; 0
    125a:	61 f0       	breq	.+24     	; 0x1274 <MDIO_Error_State_SetPortDirection+0x60>
    125c:	1f c0       	rjmp	.+62     	; 0x129c <MDIO_Error_State_SetPortDirection+0x88>
    125e:	2c 81       	ldd	r18, Y+4	; 0x04
    1260:	3d 81       	ldd	r19, Y+5	; 0x05
    1262:	22 30       	cpi	r18, 0x02	; 2
    1264:	31 05       	cpc	r19, r1
    1266:	81 f0       	breq	.+32     	; 0x1288 <MDIO_Error_State_SetPortDirection+0x74>
    1268:	8c 81       	ldd	r24, Y+4	; 0x04
    126a:	9d 81       	ldd	r25, Y+5	; 0x05
    126c:	83 30       	cpi	r24, 0x03	; 3
    126e:	91 05       	cpc	r25, r1
    1270:	81 f0       	breq	.+32     	; 0x1292 <MDIO_Error_State_SetPortDirection+0x7e>
    1272:	14 c0       	rjmp	.+40     	; 0x129c <MDIO_Error_State_SetPortDirection+0x88>
		{
		case MDIO_PORTA:
			DDRA=Copy_u8PortDirection;
    1274:	ea e3       	ldi	r30, 0x3A	; 58
    1276:	f0 e0       	ldi	r31, 0x00	; 0
    1278:	8b 81       	ldd	r24, Y+3	; 0x03
    127a:	80 83       	st	Z, r24
    127c:	12 c0       	rjmp	.+36     	; 0x12a2 <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		case MDIO_PORTB:
			DDRB=Copy_u8PortDirection;
    127e:	e7 e3       	ldi	r30, 0x37	; 55
    1280:	f0 e0       	ldi	r31, 0x00	; 0
    1282:	8b 81       	ldd	r24, Y+3	; 0x03
    1284:	80 83       	st	Z, r24
    1286:	0d c0       	rjmp	.+26     	; 0x12a2 <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		case MDIO_PORTC:
			DDRC=Copy_u8PortDirection;
    1288:	e4 e3       	ldi	r30, 0x34	; 52
    128a:	f0 e0       	ldi	r31, 0x00	; 0
    128c:	8b 81       	ldd	r24, Y+3	; 0x03
    128e:	80 83       	st	Z, r24
    1290:	08 c0       	rjmp	.+16     	; 0x12a2 <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		case MDIO_PORTD:
			DDRD=Copy_u8PortDirection;
    1292:	e1 e3       	ldi	r30, 0x31	; 49
    1294:	f0 e0       	ldi	r31, 0x00	; 0
    1296:	8b 81       	ldd	r24, Y+3	; 0x03
    1298:	80 83       	st	Z, r24
    129a:	03 c0       	rjmp	.+6      	; 0x12a2 <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    129c:	19 82       	std	Y+1, r1	; 0x01
    129e:	01 c0       	rjmp	.+2      	; 0x12a2 <MDIO_Error_State_SetPortDirection+0x8e>
			break;
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    12a0:	19 82       	std	Y+1, r1	; 0x01
	}
	return LOC_Error_State_ReturnState;
    12a2:	89 81       	ldd	r24, Y+1	; 0x01
}
    12a4:	0f 90       	pop	r0
    12a6:	0f 90       	pop	r0
    12a8:	0f 90       	pop	r0
    12aa:	0f 90       	pop	r0
    12ac:	0f 90       	pop	r0
    12ae:	cf 91       	pop	r28
    12b0:	df 91       	pop	r29
    12b2:	08 95       	ret

000012b4 <MDIO_Error_State_SetPinValue>:

/*Set Pin Value Function */
Error_State MDIO_Error_State_SetPinValue(u8 Copy_u8PinNumber,u8 Copy_u8PortNumber,u8 Copy_u8PinValue)
{
    12b4:	df 93       	push	r29
    12b6:	cf 93       	push	r28
    12b8:	00 d0       	rcall	.+0      	; 0x12ba <MDIO_Error_State_SetPinValue+0x6>
    12ba:	00 d0       	rcall	.+0      	; 0x12bc <MDIO_Error_State_SetPinValue+0x8>
    12bc:	00 d0       	rcall	.+0      	; 0x12be <MDIO_Error_State_SetPinValue+0xa>
    12be:	cd b7       	in	r28, 0x3d	; 61
    12c0:	de b7       	in	r29, 0x3e	; 62
    12c2:	8a 83       	std	Y+2, r24	; 0x02
    12c4:	6b 83       	std	Y+3, r22	; 0x03
    12c6:	4c 83       	std	Y+4, r20	; 0x04
	Error_State LOC_Error_State_ReturnState=OK;
    12c8:	81 e0       	ldi	r24, 0x01	; 1
    12ca:	89 83       	std	Y+1, r24	; 0x01

	if((Copy_u8PinNumber>=0)&&(Copy_u8PinNumber<8))
    12cc:	8a 81       	ldd	r24, Y+2	; 0x02
    12ce:	88 30       	cpi	r24, 0x08	; 8
    12d0:	08 f0       	brcs	.+2      	; 0x12d4 <MDIO_Error_State_SetPinValue+0x20>
    12d2:	e8 c0       	rjmp	.+464    	; 0x14a4 <MDIO_Error_State_SetPinValue+0x1f0>
	{
		switch(Copy_u8PortNumber)
    12d4:	8b 81       	ldd	r24, Y+3	; 0x03
    12d6:	28 2f       	mov	r18, r24
    12d8:	30 e0       	ldi	r19, 0x00	; 0
    12da:	3e 83       	std	Y+6, r19	; 0x06
    12dc:	2d 83       	std	Y+5, r18	; 0x05
    12de:	8d 81       	ldd	r24, Y+5	; 0x05
    12e0:	9e 81       	ldd	r25, Y+6	; 0x06
    12e2:	81 30       	cpi	r24, 0x01	; 1
    12e4:	91 05       	cpc	r25, r1
    12e6:	09 f4       	brne	.+2      	; 0x12ea <MDIO_Error_State_SetPinValue+0x36>
    12e8:	48 c0       	rjmp	.+144    	; 0x137a <MDIO_Error_State_SetPinValue+0xc6>
    12ea:	2d 81       	ldd	r18, Y+5	; 0x05
    12ec:	3e 81       	ldd	r19, Y+6	; 0x06
    12ee:	22 30       	cpi	r18, 0x02	; 2
    12f0:	31 05       	cpc	r19, r1
    12f2:	2c f4       	brge	.+10     	; 0x12fe <MDIO_Error_State_SetPinValue+0x4a>
    12f4:	8d 81       	ldd	r24, Y+5	; 0x05
    12f6:	9e 81       	ldd	r25, Y+6	; 0x06
    12f8:	00 97       	sbiw	r24, 0x00	; 0
    12fa:	71 f0       	breq	.+28     	; 0x1318 <MDIO_Error_State_SetPinValue+0x64>
    12fc:	d1 c0       	rjmp	.+418    	; 0x14a0 <MDIO_Error_State_SetPinValue+0x1ec>
    12fe:	2d 81       	ldd	r18, Y+5	; 0x05
    1300:	3e 81       	ldd	r19, Y+6	; 0x06
    1302:	22 30       	cpi	r18, 0x02	; 2
    1304:	31 05       	cpc	r19, r1
    1306:	09 f4       	brne	.+2      	; 0x130a <MDIO_Error_State_SetPinValue+0x56>
    1308:	69 c0       	rjmp	.+210    	; 0x13dc <MDIO_Error_State_SetPinValue+0x128>
    130a:	8d 81       	ldd	r24, Y+5	; 0x05
    130c:	9e 81       	ldd	r25, Y+6	; 0x06
    130e:	83 30       	cpi	r24, 0x03	; 3
    1310:	91 05       	cpc	r25, r1
    1312:	09 f4       	brne	.+2      	; 0x1316 <MDIO_Error_State_SetPinValue+0x62>
    1314:	94 c0       	rjmp	.+296    	; 0x143e <MDIO_Error_State_SetPinValue+0x18a>
    1316:	c4 c0       	rjmp	.+392    	; 0x14a0 <MDIO_Error_State_SetPinValue+0x1ec>
		{
		case MDIO_PORTA:
			if(Copy_u8PinValue==PIN_HIGH)
    1318:	8c 81       	ldd	r24, Y+4	; 0x04
    131a:	81 30       	cpi	r24, 0x01	; 1
    131c:	a1 f4       	brne	.+40     	; 0x1346 <MDIO_Error_State_SetPinValue+0x92>
			{
				SET_BIT(PORTA,Copy_u8PinNumber);
    131e:	ab e3       	ldi	r26, 0x3B	; 59
    1320:	b0 e0       	ldi	r27, 0x00	; 0
    1322:	eb e3       	ldi	r30, 0x3B	; 59
    1324:	f0 e0       	ldi	r31, 0x00	; 0
    1326:	80 81       	ld	r24, Z
    1328:	48 2f       	mov	r20, r24
    132a:	8a 81       	ldd	r24, Y+2	; 0x02
    132c:	28 2f       	mov	r18, r24
    132e:	30 e0       	ldi	r19, 0x00	; 0
    1330:	81 e0       	ldi	r24, 0x01	; 1
    1332:	90 e0       	ldi	r25, 0x00	; 0
    1334:	02 2e       	mov	r0, r18
    1336:	02 c0       	rjmp	.+4      	; 0x133c <MDIO_Error_State_SetPinValue+0x88>
    1338:	88 0f       	add	r24, r24
    133a:	99 1f       	adc	r25, r25
    133c:	0a 94       	dec	r0
    133e:	e2 f7       	brpl	.-8      	; 0x1338 <MDIO_Error_State_SetPinValue+0x84>
    1340:	84 2b       	or	r24, r20
    1342:	8c 93       	st	X, r24
    1344:	b0 c0       	rjmp	.+352    	; 0x14a6 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else if(Copy_u8PinValue==PIN_LOW)
    1346:	8c 81       	ldd	r24, Y+4	; 0x04
    1348:	88 23       	and	r24, r24
    134a:	a9 f4       	brne	.+42     	; 0x1376 <MDIO_Error_State_SetPinValue+0xc2>
			{
				CLR_BIT(PORTA,Copy_u8PinNumber);
    134c:	ab e3       	ldi	r26, 0x3B	; 59
    134e:	b0 e0       	ldi	r27, 0x00	; 0
    1350:	eb e3       	ldi	r30, 0x3B	; 59
    1352:	f0 e0       	ldi	r31, 0x00	; 0
    1354:	80 81       	ld	r24, Z
    1356:	48 2f       	mov	r20, r24
    1358:	8a 81       	ldd	r24, Y+2	; 0x02
    135a:	28 2f       	mov	r18, r24
    135c:	30 e0       	ldi	r19, 0x00	; 0
    135e:	81 e0       	ldi	r24, 0x01	; 1
    1360:	90 e0       	ldi	r25, 0x00	; 0
    1362:	02 2e       	mov	r0, r18
    1364:	02 c0       	rjmp	.+4      	; 0x136a <MDIO_Error_State_SetPinValue+0xb6>
    1366:	88 0f       	add	r24, r24
    1368:	99 1f       	adc	r25, r25
    136a:	0a 94       	dec	r0
    136c:	e2 f7       	brpl	.-8      	; 0x1366 <MDIO_Error_State_SetPinValue+0xb2>
    136e:	80 95       	com	r24
    1370:	84 23       	and	r24, r20
    1372:	8c 93       	st	X, r24
    1374:	98 c0       	rjmp	.+304    	; 0x14a6 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    1376:	19 82       	std	Y+1, r1	; 0x01
    1378:	96 c0       	rjmp	.+300    	; 0x14a6 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			break;
		case MDIO_PORTB:
			if(Copy_u8PinValue==PIN_HIGH)
    137a:	8c 81       	ldd	r24, Y+4	; 0x04
    137c:	81 30       	cpi	r24, 0x01	; 1
    137e:	a1 f4       	brne	.+40     	; 0x13a8 <MDIO_Error_State_SetPinValue+0xf4>
			{
				SET_BIT(PORTB,Copy_u8PinNumber);
    1380:	a8 e3       	ldi	r26, 0x38	; 56
    1382:	b0 e0       	ldi	r27, 0x00	; 0
    1384:	e8 e3       	ldi	r30, 0x38	; 56
    1386:	f0 e0       	ldi	r31, 0x00	; 0
    1388:	80 81       	ld	r24, Z
    138a:	48 2f       	mov	r20, r24
    138c:	8a 81       	ldd	r24, Y+2	; 0x02
    138e:	28 2f       	mov	r18, r24
    1390:	30 e0       	ldi	r19, 0x00	; 0
    1392:	81 e0       	ldi	r24, 0x01	; 1
    1394:	90 e0       	ldi	r25, 0x00	; 0
    1396:	02 2e       	mov	r0, r18
    1398:	02 c0       	rjmp	.+4      	; 0x139e <MDIO_Error_State_SetPinValue+0xea>
    139a:	88 0f       	add	r24, r24
    139c:	99 1f       	adc	r25, r25
    139e:	0a 94       	dec	r0
    13a0:	e2 f7       	brpl	.-8      	; 0x139a <MDIO_Error_State_SetPinValue+0xe6>
    13a2:	84 2b       	or	r24, r20
    13a4:	8c 93       	st	X, r24
    13a6:	7f c0       	rjmp	.+254    	; 0x14a6 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else if(Copy_u8PinValue==PIN_LOW)
    13a8:	8c 81       	ldd	r24, Y+4	; 0x04
    13aa:	88 23       	and	r24, r24
    13ac:	a9 f4       	brne	.+42     	; 0x13d8 <MDIO_Error_State_SetPinValue+0x124>
			{
				CLR_BIT(PORTB,Copy_u8PinNumber);
    13ae:	a8 e3       	ldi	r26, 0x38	; 56
    13b0:	b0 e0       	ldi	r27, 0x00	; 0
    13b2:	e8 e3       	ldi	r30, 0x38	; 56
    13b4:	f0 e0       	ldi	r31, 0x00	; 0
    13b6:	80 81       	ld	r24, Z
    13b8:	48 2f       	mov	r20, r24
    13ba:	8a 81       	ldd	r24, Y+2	; 0x02
    13bc:	28 2f       	mov	r18, r24
    13be:	30 e0       	ldi	r19, 0x00	; 0
    13c0:	81 e0       	ldi	r24, 0x01	; 1
    13c2:	90 e0       	ldi	r25, 0x00	; 0
    13c4:	02 2e       	mov	r0, r18
    13c6:	02 c0       	rjmp	.+4      	; 0x13cc <MDIO_Error_State_SetPinValue+0x118>
    13c8:	88 0f       	add	r24, r24
    13ca:	99 1f       	adc	r25, r25
    13cc:	0a 94       	dec	r0
    13ce:	e2 f7       	brpl	.-8      	; 0x13c8 <MDIO_Error_State_SetPinValue+0x114>
    13d0:	80 95       	com	r24
    13d2:	84 23       	and	r24, r20
    13d4:	8c 93       	st	X, r24
    13d6:	67 c0       	rjmp	.+206    	; 0x14a6 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    13d8:	19 82       	std	Y+1, r1	; 0x01
    13da:	65 c0       	rjmp	.+202    	; 0x14a6 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			break;
		case MDIO_PORTC:
			if(Copy_u8PinValue==PIN_HIGH)
    13dc:	8c 81       	ldd	r24, Y+4	; 0x04
    13de:	81 30       	cpi	r24, 0x01	; 1
    13e0:	a1 f4       	brne	.+40     	; 0x140a <MDIO_Error_State_SetPinValue+0x156>
			{
				SET_BIT(PORTC,Copy_u8PinNumber);
    13e2:	a5 e3       	ldi	r26, 0x35	; 53
    13e4:	b0 e0       	ldi	r27, 0x00	; 0
    13e6:	e5 e3       	ldi	r30, 0x35	; 53
    13e8:	f0 e0       	ldi	r31, 0x00	; 0
    13ea:	80 81       	ld	r24, Z
    13ec:	48 2f       	mov	r20, r24
    13ee:	8a 81       	ldd	r24, Y+2	; 0x02
    13f0:	28 2f       	mov	r18, r24
    13f2:	30 e0       	ldi	r19, 0x00	; 0
    13f4:	81 e0       	ldi	r24, 0x01	; 1
    13f6:	90 e0       	ldi	r25, 0x00	; 0
    13f8:	02 2e       	mov	r0, r18
    13fa:	02 c0       	rjmp	.+4      	; 0x1400 <MDIO_Error_State_SetPinValue+0x14c>
    13fc:	88 0f       	add	r24, r24
    13fe:	99 1f       	adc	r25, r25
    1400:	0a 94       	dec	r0
    1402:	e2 f7       	brpl	.-8      	; 0x13fc <MDIO_Error_State_SetPinValue+0x148>
    1404:	84 2b       	or	r24, r20
    1406:	8c 93       	st	X, r24
    1408:	4e c0       	rjmp	.+156    	; 0x14a6 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else if(Copy_u8PinValue==PIN_LOW)
    140a:	8c 81       	ldd	r24, Y+4	; 0x04
    140c:	88 23       	and	r24, r24
    140e:	a9 f4       	brne	.+42     	; 0x143a <MDIO_Error_State_SetPinValue+0x186>
			{
				CLR_BIT(PORTC,Copy_u8PinNumber);
    1410:	a5 e3       	ldi	r26, 0x35	; 53
    1412:	b0 e0       	ldi	r27, 0x00	; 0
    1414:	e5 e3       	ldi	r30, 0x35	; 53
    1416:	f0 e0       	ldi	r31, 0x00	; 0
    1418:	80 81       	ld	r24, Z
    141a:	48 2f       	mov	r20, r24
    141c:	8a 81       	ldd	r24, Y+2	; 0x02
    141e:	28 2f       	mov	r18, r24
    1420:	30 e0       	ldi	r19, 0x00	; 0
    1422:	81 e0       	ldi	r24, 0x01	; 1
    1424:	90 e0       	ldi	r25, 0x00	; 0
    1426:	02 2e       	mov	r0, r18
    1428:	02 c0       	rjmp	.+4      	; 0x142e <MDIO_Error_State_SetPinValue+0x17a>
    142a:	88 0f       	add	r24, r24
    142c:	99 1f       	adc	r25, r25
    142e:	0a 94       	dec	r0
    1430:	e2 f7       	brpl	.-8      	; 0x142a <MDIO_Error_State_SetPinValue+0x176>
    1432:	80 95       	com	r24
    1434:	84 23       	and	r24, r20
    1436:	8c 93       	st	X, r24
    1438:	36 c0       	rjmp	.+108    	; 0x14a6 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    143a:	19 82       	std	Y+1, r1	; 0x01
    143c:	34 c0       	rjmp	.+104    	; 0x14a6 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			break;	
		case MDIO_PORTD:
			if(Copy_u8PinValue==PIN_HIGH)
    143e:	8c 81       	ldd	r24, Y+4	; 0x04
    1440:	81 30       	cpi	r24, 0x01	; 1
    1442:	a1 f4       	brne	.+40     	; 0x146c <MDIO_Error_State_SetPinValue+0x1b8>
			{
				SET_BIT(PORTD,Copy_u8PinNumber);
    1444:	a2 e3       	ldi	r26, 0x32	; 50
    1446:	b0 e0       	ldi	r27, 0x00	; 0
    1448:	e2 e3       	ldi	r30, 0x32	; 50
    144a:	f0 e0       	ldi	r31, 0x00	; 0
    144c:	80 81       	ld	r24, Z
    144e:	48 2f       	mov	r20, r24
    1450:	8a 81       	ldd	r24, Y+2	; 0x02
    1452:	28 2f       	mov	r18, r24
    1454:	30 e0       	ldi	r19, 0x00	; 0
    1456:	81 e0       	ldi	r24, 0x01	; 1
    1458:	90 e0       	ldi	r25, 0x00	; 0
    145a:	02 2e       	mov	r0, r18
    145c:	02 c0       	rjmp	.+4      	; 0x1462 <MDIO_Error_State_SetPinValue+0x1ae>
    145e:	88 0f       	add	r24, r24
    1460:	99 1f       	adc	r25, r25
    1462:	0a 94       	dec	r0
    1464:	e2 f7       	brpl	.-8      	; 0x145e <MDIO_Error_State_SetPinValue+0x1aa>
    1466:	84 2b       	or	r24, r20
    1468:	8c 93       	st	X, r24
    146a:	1d c0       	rjmp	.+58     	; 0x14a6 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else if(Copy_u8PinValue==PIN_LOW)
    146c:	8c 81       	ldd	r24, Y+4	; 0x04
    146e:	88 23       	and	r24, r24
    1470:	a9 f4       	brne	.+42     	; 0x149c <MDIO_Error_State_SetPinValue+0x1e8>
			{
				CLR_BIT(PORTD,Copy_u8PinNumber);
    1472:	a2 e3       	ldi	r26, 0x32	; 50
    1474:	b0 e0       	ldi	r27, 0x00	; 0
    1476:	e2 e3       	ldi	r30, 0x32	; 50
    1478:	f0 e0       	ldi	r31, 0x00	; 0
    147a:	80 81       	ld	r24, Z
    147c:	48 2f       	mov	r20, r24
    147e:	8a 81       	ldd	r24, Y+2	; 0x02
    1480:	28 2f       	mov	r18, r24
    1482:	30 e0       	ldi	r19, 0x00	; 0
    1484:	81 e0       	ldi	r24, 0x01	; 1
    1486:	90 e0       	ldi	r25, 0x00	; 0
    1488:	02 2e       	mov	r0, r18
    148a:	02 c0       	rjmp	.+4      	; 0x1490 <MDIO_Error_State_SetPinValue+0x1dc>
    148c:	88 0f       	add	r24, r24
    148e:	99 1f       	adc	r25, r25
    1490:	0a 94       	dec	r0
    1492:	e2 f7       	brpl	.-8      	; 0x148c <MDIO_Error_State_SetPinValue+0x1d8>
    1494:	80 95       	com	r24
    1496:	84 23       	and	r24, r20
    1498:	8c 93       	st	X, r24
    149a:	05 c0       	rjmp	.+10     	; 0x14a6 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			else
			{
				LOC_Error_State_ReturnState=NOK;
    149c:	19 82       	std	Y+1, r1	; 0x01
    149e:	03 c0       	rjmp	.+6      	; 0x14a6 <MDIO_Error_State_SetPinValue+0x1f2>
			}
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    14a0:	19 82       	std	Y+1, r1	; 0x01
    14a2:	01 c0       	rjmp	.+2      	; 0x14a6 <MDIO_Error_State_SetPinValue+0x1f2>
			break;
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    14a4:	19 82       	std	Y+1, r1	; 0x01
	}

	return LOC_Error_State_ReturnState;
    14a6:	89 81       	ldd	r24, Y+1	; 0x01
}
    14a8:	26 96       	adiw	r28, 0x06	; 6
    14aa:	0f b6       	in	r0, 0x3f	; 63
    14ac:	f8 94       	cli
    14ae:	de bf       	out	0x3e, r29	; 62
    14b0:	0f be       	out	0x3f, r0	; 63
    14b2:	cd bf       	out	0x3d, r28	; 61
    14b4:	cf 91       	pop	r28
    14b6:	df 91       	pop	r29
    14b8:	08 95       	ret

000014ba <MDIO_Error_State_SetPortValue>:

/*Set Port Value Function */
Error_State MDIO_Error_State_SetPortValue(u8 Copy_u8PortNumber,u8 Copy_u8PortValue)
{
    14ba:	df 93       	push	r29
    14bc:	cf 93       	push	r28
    14be:	00 d0       	rcall	.+0      	; 0x14c0 <MDIO_Error_State_SetPortValue+0x6>
    14c0:	00 d0       	rcall	.+0      	; 0x14c2 <MDIO_Error_State_SetPortValue+0x8>
    14c2:	0f 92       	push	r0
    14c4:	cd b7       	in	r28, 0x3d	; 61
    14c6:	de b7       	in	r29, 0x3e	; 62
    14c8:	8a 83       	std	Y+2, r24	; 0x02
    14ca:	6b 83       	std	Y+3, r22	; 0x03
	Error_State LOC_Error_State_ReturnState=OK;
    14cc:	81 e0       	ldi	r24, 0x01	; 1
    14ce:	89 83       	std	Y+1, r24	; 0x01
	switch(Copy_u8PortNumber)
    14d0:	8a 81       	ldd	r24, Y+2	; 0x02
    14d2:	28 2f       	mov	r18, r24
    14d4:	30 e0       	ldi	r19, 0x00	; 0
    14d6:	3d 83       	std	Y+5, r19	; 0x05
    14d8:	2c 83       	std	Y+4, r18	; 0x04
    14da:	8c 81       	ldd	r24, Y+4	; 0x04
    14dc:	9d 81       	ldd	r25, Y+5	; 0x05
    14de:	81 30       	cpi	r24, 0x01	; 1
    14e0:	91 05       	cpc	r25, r1
    14e2:	d1 f0       	breq	.+52     	; 0x1518 <MDIO_Error_State_SetPortValue+0x5e>
    14e4:	2c 81       	ldd	r18, Y+4	; 0x04
    14e6:	3d 81       	ldd	r19, Y+5	; 0x05
    14e8:	22 30       	cpi	r18, 0x02	; 2
    14ea:	31 05       	cpc	r19, r1
    14ec:	2c f4       	brge	.+10     	; 0x14f8 <MDIO_Error_State_SetPortValue+0x3e>
    14ee:	8c 81       	ldd	r24, Y+4	; 0x04
    14f0:	9d 81       	ldd	r25, Y+5	; 0x05
    14f2:	00 97       	sbiw	r24, 0x00	; 0
    14f4:	61 f0       	breq	.+24     	; 0x150e <MDIO_Error_State_SetPortValue+0x54>
    14f6:	1f c0       	rjmp	.+62     	; 0x1536 <MDIO_Error_State_SetPortValue+0x7c>
    14f8:	2c 81       	ldd	r18, Y+4	; 0x04
    14fa:	3d 81       	ldd	r19, Y+5	; 0x05
    14fc:	22 30       	cpi	r18, 0x02	; 2
    14fe:	31 05       	cpc	r19, r1
    1500:	81 f0       	breq	.+32     	; 0x1522 <MDIO_Error_State_SetPortValue+0x68>
    1502:	8c 81       	ldd	r24, Y+4	; 0x04
    1504:	9d 81       	ldd	r25, Y+5	; 0x05
    1506:	83 30       	cpi	r24, 0x03	; 3
    1508:	91 05       	cpc	r25, r1
    150a:	81 f0       	breq	.+32     	; 0x152c <MDIO_Error_State_SetPortValue+0x72>
    150c:	14 c0       	rjmp	.+40     	; 0x1536 <MDIO_Error_State_SetPortValue+0x7c>
	{
	case MDIO_PORTA:
		PORTA=Copy_u8PortValue;
    150e:	eb e3       	ldi	r30, 0x3B	; 59
    1510:	f0 e0       	ldi	r31, 0x00	; 0
    1512:	8b 81       	ldd	r24, Y+3	; 0x03
    1514:	80 83       	st	Z, r24
    1516:	10 c0       	rjmp	.+32     	; 0x1538 <MDIO_Error_State_SetPortValue+0x7e>
		break;
	case MDIO_PORTB:
		PORTB=Copy_u8PortValue;
    1518:	e8 e3       	ldi	r30, 0x38	; 56
    151a:	f0 e0       	ldi	r31, 0x00	; 0
    151c:	8b 81       	ldd	r24, Y+3	; 0x03
    151e:	80 83       	st	Z, r24
    1520:	0b c0       	rjmp	.+22     	; 0x1538 <MDIO_Error_State_SetPortValue+0x7e>
		break;
	case MDIO_PORTC:
		PORTC=Copy_u8PortValue;
    1522:	e5 e3       	ldi	r30, 0x35	; 53
    1524:	f0 e0       	ldi	r31, 0x00	; 0
    1526:	8b 81       	ldd	r24, Y+3	; 0x03
    1528:	80 83       	st	Z, r24
    152a:	06 c0       	rjmp	.+12     	; 0x1538 <MDIO_Error_State_SetPortValue+0x7e>
		break;	
	case MDIO_PORTD:
		PORTD=Copy_u8PortValue;
    152c:	e2 e3       	ldi	r30, 0x32	; 50
    152e:	f0 e0       	ldi	r31, 0x00	; 0
    1530:	8b 81       	ldd	r24, Y+3	; 0x03
    1532:	80 83       	st	Z, r24
    1534:	01 c0       	rjmp	.+2      	; 0x1538 <MDIO_Error_State_SetPortValue+0x7e>
		break;	
	default:
		LOC_Error_State_ReturnState=NOK;
    1536:	19 82       	std	Y+1, r1	; 0x01
		break;
	}
	return LOC_Error_State_ReturnState;
    1538:	89 81       	ldd	r24, Y+1	; 0x01
}
    153a:	0f 90       	pop	r0
    153c:	0f 90       	pop	r0
    153e:	0f 90       	pop	r0
    1540:	0f 90       	pop	r0
    1542:	0f 90       	pop	r0
    1544:	cf 91       	pop	r28
    1546:	df 91       	pop	r29
    1548:	08 95       	ret

0000154a <MDIO_Error_State_GetPinValue>:

/*Get Pin Value Function */
Error_State MDIO_Error_State_GetPinValue(u8 Copy_u8PinNumber,u8 Copy_u8PortNumber,u8* P_u8PinValue)
{
    154a:	df 93       	push	r29
    154c:	cf 93       	push	r28
    154e:	cd b7       	in	r28, 0x3d	; 61
    1550:	de b7       	in	r29, 0x3e	; 62
    1552:	27 97       	sbiw	r28, 0x07	; 7
    1554:	0f b6       	in	r0, 0x3f	; 63
    1556:	f8 94       	cli
    1558:	de bf       	out	0x3e, r29	; 62
    155a:	0f be       	out	0x3f, r0	; 63
    155c:	cd bf       	out	0x3d, r28	; 61
    155e:	8a 83       	std	Y+2, r24	; 0x02
    1560:	6b 83       	std	Y+3, r22	; 0x03
    1562:	5d 83       	std	Y+5, r21	; 0x05
    1564:	4c 83       	std	Y+4, r20	; 0x04
	Error_State LOC_Error_State_ReturnState=OK;
    1566:	81 e0       	ldi	r24, 0x01	; 1
    1568:	89 83       	std	Y+1, r24	; 0x01

	if(((Copy_u8PinNumber>=0)&&(Copy_u8PinNumber<8))&&(P_u8PinValue!=NULL_POINTER))
    156a:	8a 81       	ldd	r24, Y+2	; 0x02
    156c:	88 30       	cpi	r24, 0x08	; 8
    156e:	08 f0       	brcs	.+2      	; 0x1572 <MDIO_Error_State_GetPinValue+0x28>
    1570:	79 c0       	rjmp	.+242    	; 0x1664 <MDIO_Error_State_GetPinValue+0x11a>
    1572:	8c 81       	ldd	r24, Y+4	; 0x04
    1574:	9d 81       	ldd	r25, Y+5	; 0x05
    1576:	81 30       	cpi	r24, 0x01	; 1
    1578:	91 05       	cpc	r25, r1
    157a:	09 f4       	brne	.+2      	; 0x157e <MDIO_Error_State_GetPinValue+0x34>
    157c:	73 c0       	rjmp	.+230    	; 0x1664 <MDIO_Error_State_GetPinValue+0x11a>
	{
		switch(Copy_u8PortNumber)
    157e:	8b 81       	ldd	r24, Y+3	; 0x03
    1580:	28 2f       	mov	r18, r24
    1582:	30 e0       	ldi	r19, 0x00	; 0
    1584:	3f 83       	std	Y+7, r19	; 0x07
    1586:	2e 83       	std	Y+6, r18	; 0x06
    1588:	4e 81       	ldd	r20, Y+6	; 0x06
    158a:	5f 81       	ldd	r21, Y+7	; 0x07
    158c:	41 30       	cpi	r20, 0x01	; 1
    158e:	51 05       	cpc	r21, r1
    1590:	59 f1       	breq	.+86     	; 0x15e8 <MDIO_Error_State_GetPinValue+0x9e>
    1592:	8e 81       	ldd	r24, Y+6	; 0x06
    1594:	9f 81       	ldd	r25, Y+7	; 0x07
    1596:	82 30       	cpi	r24, 0x02	; 2
    1598:	91 05       	cpc	r25, r1
    159a:	34 f4       	brge	.+12     	; 0x15a8 <MDIO_Error_State_GetPinValue+0x5e>
    159c:	2e 81       	ldd	r18, Y+6	; 0x06
    159e:	3f 81       	ldd	r19, Y+7	; 0x07
    15a0:	21 15       	cp	r18, r1
    15a2:	31 05       	cpc	r19, r1
    15a4:	69 f0       	breq	.+26     	; 0x15c0 <MDIO_Error_State_GetPinValue+0x76>
    15a6:	5c c0       	rjmp	.+184    	; 0x1660 <MDIO_Error_State_GetPinValue+0x116>
    15a8:	4e 81       	ldd	r20, Y+6	; 0x06
    15aa:	5f 81       	ldd	r21, Y+7	; 0x07
    15ac:	42 30       	cpi	r20, 0x02	; 2
    15ae:	51 05       	cpc	r21, r1
    15b0:	79 f1       	breq	.+94     	; 0x1610 <MDIO_Error_State_GetPinValue+0xc6>
    15b2:	8e 81       	ldd	r24, Y+6	; 0x06
    15b4:	9f 81       	ldd	r25, Y+7	; 0x07
    15b6:	83 30       	cpi	r24, 0x03	; 3
    15b8:	91 05       	cpc	r25, r1
    15ba:	09 f4       	brne	.+2      	; 0x15be <MDIO_Error_State_GetPinValue+0x74>
    15bc:	3d c0       	rjmp	.+122    	; 0x1638 <MDIO_Error_State_GetPinValue+0xee>
    15be:	50 c0       	rjmp	.+160    	; 0x1660 <MDIO_Error_State_GetPinValue+0x116>
		{
		case MDIO_PORTA:
			*P_u8PinValue=GET_BIT(PINA,Copy_u8PinNumber);
    15c0:	e9 e3       	ldi	r30, 0x39	; 57
    15c2:	f0 e0       	ldi	r31, 0x00	; 0
    15c4:	80 81       	ld	r24, Z
    15c6:	28 2f       	mov	r18, r24
    15c8:	30 e0       	ldi	r19, 0x00	; 0
    15ca:	8a 81       	ldd	r24, Y+2	; 0x02
    15cc:	88 2f       	mov	r24, r24
    15ce:	90 e0       	ldi	r25, 0x00	; 0
    15d0:	a9 01       	movw	r20, r18
    15d2:	02 c0       	rjmp	.+4      	; 0x15d8 <MDIO_Error_State_GetPinValue+0x8e>
    15d4:	55 95       	asr	r21
    15d6:	47 95       	ror	r20
    15d8:	8a 95       	dec	r24
    15da:	e2 f7       	brpl	.-8      	; 0x15d4 <MDIO_Error_State_GetPinValue+0x8a>
    15dc:	ca 01       	movw	r24, r20
    15de:	81 70       	andi	r24, 0x01	; 1
    15e0:	ec 81       	ldd	r30, Y+4	; 0x04
    15e2:	fd 81       	ldd	r31, Y+5	; 0x05
    15e4:	80 83       	st	Z, r24
    15e6:	3f c0       	rjmp	.+126    	; 0x1666 <MDIO_Error_State_GetPinValue+0x11c>
			break;
		case MDIO_PORTB:
			*P_u8PinValue=GET_BIT(PINB,Copy_u8PinNumber);
    15e8:	e6 e3       	ldi	r30, 0x36	; 54
    15ea:	f0 e0       	ldi	r31, 0x00	; 0
    15ec:	80 81       	ld	r24, Z
    15ee:	28 2f       	mov	r18, r24
    15f0:	30 e0       	ldi	r19, 0x00	; 0
    15f2:	8a 81       	ldd	r24, Y+2	; 0x02
    15f4:	88 2f       	mov	r24, r24
    15f6:	90 e0       	ldi	r25, 0x00	; 0
    15f8:	a9 01       	movw	r20, r18
    15fa:	02 c0       	rjmp	.+4      	; 0x1600 <MDIO_Error_State_GetPinValue+0xb6>
    15fc:	55 95       	asr	r21
    15fe:	47 95       	ror	r20
    1600:	8a 95       	dec	r24
    1602:	e2 f7       	brpl	.-8      	; 0x15fc <MDIO_Error_State_GetPinValue+0xb2>
    1604:	ca 01       	movw	r24, r20
    1606:	81 70       	andi	r24, 0x01	; 1
    1608:	ec 81       	ldd	r30, Y+4	; 0x04
    160a:	fd 81       	ldd	r31, Y+5	; 0x05
    160c:	80 83       	st	Z, r24
    160e:	2b c0       	rjmp	.+86     	; 0x1666 <MDIO_Error_State_GetPinValue+0x11c>
			break;
		case MDIO_PORTC:
			*P_u8PinValue=GET_BIT(PINC,Copy_u8PinNumber);
    1610:	e3 e3       	ldi	r30, 0x33	; 51
    1612:	f0 e0       	ldi	r31, 0x00	; 0
    1614:	80 81       	ld	r24, Z
    1616:	28 2f       	mov	r18, r24
    1618:	30 e0       	ldi	r19, 0x00	; 0
    161a:	8a 81       	ldd	r24, Y+2	; 0x02
    161c:	88 2f       	mov	r24, r24
    161e:	90 e0       	ldi	r25, 0x00	; 0
    1620:	a9 01       	movw	r20, r18
    1622:	02 c0       	rjmp	.+4      	; 0x1628 <MDIO_Error_State_GetPinValue+0xde>
    1624:	55 95       	asr	r21
    1626:	47 95       	ror	r20
    1628:	8a 95       	dec	r24
    162a:	e2 f7       	brpl	.-8      	; 0x1624 <MDIO_Error_State_GetPinValue+0xda>
    162c:	ca 01       	movw	r24, r20
    162e:	81 70       	andi	r24, 0x01	; 1
    1630:	ec 81       	ldd	r30, Y+4	; 0x04
    1632:	fd 81       	ldd	r31, Y+5	; 0x05
    1634:	80 83       	st	Z, r24
    1636:	17 c0       	rjmp	.+46     	; 0x1666 <MDIO_Error_State_GetPinValue+0x11c>
			break;
		case MDIO_PORTD:
			*P_u8PinValue=GET_BIT(PIND,Copy_u8PinNumber);
    1638:	e0 e3       	ldi	r30, 0x30	; 48
    163a:	f0 e0       	ldi	r31, 0x00	; 0
    163c:	80 81       	ld	r24, Z
    163e:	28 2f       	mov	r18, r24
    1640:	30 e0       	ldi	r19, 0x00	; 0
    1642:	8a 81       	ldd	r24, Y+2	; 0x02
    1644:	88 2f       	mov	r24, r24
    1646:	90 e0       	ldi	r25, 0x00	; 0
    1648:	a9 01       	movw	r20, r18
    164a:	02 c0       	rjmp	.+4      	; 0x1650 <MDIO_Error_State_GetPinValue+0x106>
    164c:	55 95       	asr	r21
    164e:	47 95       	ror	r20
    1650:	8a 95       	dec	r24
    1652:	e2 f7       	brpl	.-8      	; 0x164c <MDIO_Error_State_GetPinValue+0x102>
    1654:	ca 01       	movw	r24, r20
    1656:	81 70       	andi	r24, 0x01	; 1
    1658:	ec 81       	ldd	r30, Y+4	; 0x04
    165a:	fd 81       	ldd	r31, Y+5	; 0x05
    165c:	80 83       	st	Z, r24
    165e:	03 c0       	rjmp	.+6      	; 0x1666 <MDIO_Error_State_GetPinValue+0x11c>
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    1660:	19 82       	std	Y+1, r1	; 0x01
    1662:	01 c0       	rjmp	.+2      	; 0x1666 <MDIO_Error_State_GetPinValue+0x11c>
			break;		
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    1664:	19 82       	std	Y+1, r1	; 0x01
	}

	return LOC_Error_State_ReturnState;
    1666:	89 81       	ldd	r24, Y+1	; 0x01
}
    1668:	27 96       	adiw	r28, 0x07	; 7
    166a:	0f b6       	in	r0, 0x3f	; 63
    166c:	f8 94       	cli
    166e:	de bf       	out	0x3e, r29	; 62
    1670:	0f be       	out	0x3f, r0	; 63
    1672:	cd bf       	out	0x3d, r28	; 61
    1674:	cf 91       	pop	r28
    1676:	df 91       	pop	r29
    1678:	08 95       	ret

0000167a <MDIO_Error_State_SetNippleValue>:
/*Set Nipple Direction Function */

/*Set Nipple Values Function */
Error_State MDIO_Error_State_SetNippleValue(u8 Copy_u8PinStart,u8 Copy_u8PortNumber,u8 Copy_u8Value)
{
    167a:	df 93       	push	r29
    167c:	cf 93       	push	r28
    167e:	00 d0       	rcall	.+0      	; 0x1680 <MDIO_Error_State_SetNippleValue+0x6>
    1680:	00 d0       	rcall	.+0      	; 0x1682 <MDIO_Error_State_SetNippleValue+0x8>
    1682:	00 d0       	rcall	.+0      	; 0x1684 <MDIO_Error_State_SetNippleValue+0xa>
    1684:	cd b7       	in	r28, 0x3d	; 61
    1686:	de b7       	in	r29, 0x3e	; 62
    1688:	8a 83       	std	Y+2, r24	; 0x02
    168a:	6b 83       	std	Y+3, r22	; 0x03
    168c:	4c 83       	std	Y+4, r20	; 0x04
	Error_State LOC_Error_State_ReturnState=OK;
    168e:	81 e0       	ldi	r24, 0x01	; 1
    1690:	89 83       	std	Y+1, r24	; 0x01
	if(Copy_u8PinStart<=4)
    1692:	8a 81       	ldd	r24, Y+2	; 0x02
    1694:	85 30       	cpi	r24, 0x05	; 5
    1696:	08 f0       	brcs	.+2      	; 0x169a <MDIO_Error_State_SetNippleValue+0x20>
    1698:	97 c0       	rjmp	.+302    	; 0x17c8 <MDIO_Error_State_SetNippleValue+0x14e>
	{
		switch(Copy_u8PortNumber)
    169a:	8b 81       	ldd	r24, Y+3	; 0x03
    169c:	28 2f       	mov	r18, r24
    169e:	30 e0       	ldi	r19, 0x00	; 0
    16a0:	3e 83       	std	Y+6, r19	; 0x06
    16a2:	2d 83       	std	Y+5, r18	; 0x05
    16a4:	8d 81       	ldd	r24, Y+5	; 0x05
    16a6:	9e 81       	ldd	r25, Y+6	; 0x06
    16a8:	81 30       	cpi	r24, 0x01	; 1
    16aa:	91 05       	cpc	r25, r1
    16ac:	a1 f1       	breq	.+104    	; 0x1716 <MDIO_Error_State_SetNippleValue+0x9c>
    16ae:	2d 81       	ldd	r18, Y+5	; 0x05
    16b0:	3e 81       	ldd	r19, Y+6	; 0x06
    16b2:	22 30       	cpi	r18, 0x02	; 2
    16b4:	31 05       	cpc	r19, r1
    16b6:	2c f4       	brge	.+10     	; 0x16c2 <MDIO_Error_State_SetNippleValue+0x48>
    16b8:	8d 81       	ldd	r24, Y+5	; 0x05
    16ba:	9e 81       	ldd	r25, Y+6	; 0x06
    16bc:	00 97       	sbiw	r24, 0x00	; 0
    16be:	71 f0       	breq	.+28     	; 0x16dc <MDIO_Error_State_SetNippleValue+0x62>
    16c0:	81 c0       	rjmp	.+258    	; 0x17c4 <MDIO_Error_State_SetNippleValue+0x14a>
    16c2:	2d 81       	ldd	r18, Y+5	; 0x05
    16c4:	3e 81       	ldd	r19, Y+6	; 0x06
    16c6:	22 30       	cpi	r18, 0x02	; 2
    16c8:	31 05       	cpc	r19, r1
    16ca:	09 f4       	brne	.+2      	; 0x16ce <MDIO_Error_State_SetNippleValue+0x54>
    16cc:	41 c0       	rjmp	.+130    	; 0x1750 <MDIO_Error_State_SetNippleValue+0xd6>
    16ce:	8d 81       	ldd	r24, Y+5	; 0x05
    16d0:	9e 81       	ldd	r25, Y+6	; 0x06
    16d2:	83 30       	cpi	r24, 0x03	; 3
    16d4:	91 05       	cpc	r25, r1
    16d6:	09 f4       	brne	.+2      	; 0x16da <MDIO_Error_State_SetNippleValue+0x60>
    16d8:	58 c0       	rjmp	.+176    	; 0x178a <MDIO_Error_State_SetNippleValue+0x110>
    16da:	74 c0       	rjmp	.+232    	; 0x17c4 <MDIO_Error_State_SetNippleValue+0x14a>
		case MDIO_PORTA:
		/*for(u8 i=Copy_u8PinStart;i<=7;i++)
		{
			CLR_BIT(PORTA,i);
		}*/
			PORTA&=(~(0x0F<<Copy_u8PinStart));
    16dc:	ab e3       	ldi	r26, 0x3B	; 59
    16de:	b0 e0       	ldi	r27, 0x00	; 0
    16e0:	eb e3       	ldi	r30, 0x3B	; 59
    16e2:	f0 e0       	ldi	r31, 0x00	; 0
    16e4:	80 81       	ld	r24, Z
    16e6:	48 2f       	mov	r20, r24
    16e8:	8a 81       	ldd	r24, Y+2	; 0x02
    16ea:	28 2f       	mov	r18, r24
    16ec:	30 e0       	ldi	r19, 0x00	; 0
    16ee:	8f e0       	ldi	r24, 0x0F	; 15
    16f0:	90 e0       	ldi	r25, 0x00	; 0
    16f2:	02 2e       	mov	r0, r18
    16f4:	02 c0       	rjmp	.+4      	; 0x16fa <MDIO_Error_State_SetNippleValue+0x80>
    16f6:	88 0f       	add	r24, r24
    16f8:	99 1f       	adc	r25, r25
    16fa:	0a 94       	dec	r0
    16fc:	e2 f7       	brpl	.-8      	; 0x16f6 <MDIO_Error_State_SetNippleValue+0x7c>
    16fe:	80 95       	com	r24
    1700:	84 23       	and	r24, r20
    1702:	8c 93       	st	X, r24
			PORTA|=Copy_u8Value;
    1704:	ab e3       	ldi	r26, 0x3B	; 59
    1706:	b0 e0       	ldi	r27, 0x00	; 0
    1708:	eb e3       	ldi	r30, 0x3B	; 59
    170a:	f0 e0       	ldi	r31, 0x00	; 0
    170c:	90 81       	ld	r25, Z
    170e:	8c 81       	ldd	r24, Y+4	; 0x04
    1710:	89 2b       	or	r24, r25
    1712:	8c 93       	st	X, r24
    1714:	5a c0       	rjmp	.+180    	; 0x17ca <MDIO_Error_State_SetNippleValue+0x150>
		case MDIO_PORTB:
			/*for(u8 i=Copy_u8PinStart;i<=Copy_u8PinEnd;i++)
		{
			CLR_BIT(PORTA,i);
		}*/
			PORTB&=(~(0x0F<<Copy_u8PinStart));
    1716:	a8 e3       	ldi	r26, 0x38	; 56
    1718:	b0 e0       	ldi	r27, 0x00	; 0
    171a:	e8 e3       	ldi	r30, 0x38	; 56
    171c:	f0 e0       	ldi	r31, 0x00	; 0
    171e:	80 81       	ld	r24, Z
    1720:	48 2f       	mov	r20, r24
    1722:	8a 81       	ldd	r24, Y+2	; 0x02
    1724:	28 2f       	mov	r18, r24
    1726:	30 e0       	ldi	r19, 0x00	; 0
    1728:	8f e0       	ldi	r24, 0x0F	; 15
    172a:	90 e0       	ldi	r25, 0x00	; 0
    172c:	02 2e       	mov	r0, r18
    172e:	02 c0       	rjmp	.+4      	; 0x1734 <MDIO_Error_State_SetNippleValue+0xba>
    1730:	88 0f       	add	r24, r24
    1732:	99 1f       	adc	r25, r25
    1734:	0a 94       	dec	r0
    1736:	e2 f7       	brpl	.-8      	; 0x1730 <MDIO_Error_State_SetNippleValue+0xb6>
    1738:	80 95       	com	r24
    173a:	84 23       	and	r24, r20
    173c:	8c 93       	st	X, r24
			PORTB|=Copy_u8Value;
    173e:	a8 e3       	ldi	r26, 0x38	; 56
    1740:	b0 e0       	ldi	r27, 0x00	; 0
    1742:	e8 e3       	ldi	r30, 0x38	; 56
    1744:	f0 e0       	ldi	r31, 0x00	; 0
    1746:	90 81       	ld	r25, Z
    1748:	8c 81       	ldd	r24, Y+4	; 0x04
    174a:	89 2b       	or	r24, r25
    174c:	8c 93       	st	X, r24
    174e:	3d c0       	rjmp	.+122    	; 0x17ca <MDIO_Error_State_SetNippleValue+0x150>
		case MDIO_PORTC:
			/*for(u8 i=Copy_u8PinStart;i<=Copy_u8PinEnd;i++)
		{
			CLR_BIT(PORTA,i);
		}*/
			PORTC&=(~(0x0F<<Copy_u8PinStart));
    1750:	a5 e3       	ldi	r26, 0x35	; 53
    1752:	b0 e0       	ldi	r27, 0x00	; 0
    1754:	e5 e3       	ldi	r30, 0x35	; 53
    1756:	f0 e0       	ldi	r31, 0x00	; 0
    1758:	80 81       	ld	r24, Z
    175a:	48 2f       	mov	r20, r24
    175c:	8a 81       	ldd	r24, Y+2	; 0x02
    175e:	28 2f       	mov	r18, r24
    1760:	30 e0       	ldi	r19, 0x00	; 0
    1762:	8f e0       	ldi	r24, 0x0F	; 15
    1764:	90 e0       	ldi	r25, 0x00	; 0
    1766:	02 2e       	mov	r0, r18
    1768:	02 c0       	rjmp	.+4      	; 0x176e <MDIO_Error_State_SetNippleValue+0xf4>
    176a:	88 0f       	add	r24, r24
    176c:	99 1f       	adc	r25, r25
    176e:	0a 94       	dec	r0
    1770:	e2 f7       	brpl	.-8      	; 0x176a <MDIO_Error_State_SetNippleValue+0xf0>
    1772:	80 95       	com	r24
    1774:	84 23       	and	r24, r20
    1776:	8c 93       	st	X, r24
			PORTC|=Copy_u8Value;
    1778:	a5 e3       	ldi	r26, 0x35	; 53
    177a:	b0 e0       	ldi	r27, 0x00	; 0
    177c:	e5 e3       	ldi	r30, 0x35	; 53
    177e:	f0 e0       	ldi	r31, 0x00	; 0
    1780:	90 81       	ld	r25, Z
    1782:	8c 81       	ldd	r24, Y+4	; 0x04
    1784:	89 2b       	or	r24, r25
    1786:	8c 93       	st	X, r24
    1788:	20 c0       	rjmp	.+64     	; 0x17ca <MDIO_Error_State_SetNippleValue+0x150>
		case MDIO_PORTD:
			/*for(u8 i=Copy_u8PinStart;i<=Copy_u8PinEnd;i++)
		{
			CLR_BIT(PORTA,i);
		}*/
			PORTD&=(~(0x0F<<Copy_u8PinStart));
    178a:	a2 e3       	ldi	r26, 0x32	; 50
    178c:	b0 e0       	ldi	r27, 0x00	; 0
    178e:	e2 e3       	ldi	r30, 0x32	; 50
    1790:	f0 e0       	ldi	r31, 0x00	; 0
    1792:	80 81       	ld	r24, Z
    1794:	48 2f       	mov	r20, r24
    1796:	8a 81       	ldd	r24, Y+2	; 0x02
    1798:	28 2f       	mov	r18, r24
    179a:	30 e0       	ldi	r19, 0x00	; 0
    179c:	8f e0       	ldi	r24, 0x0F	; 15
    179e:	90 e0       	ldi	r25, 0x00	; 0
    17a0:	02 2e       	mov	r0, r18
    17a2:	02 c0       	rjmp	.+4      	; 0x17a8 <MDIO_Error_State_SetNippleValue+0x12e>
    17a4:	88 0f       	add	r24, r24
    17a6:	99 1f       	adc	r25, r25
    17a8:	0a 94       	dec	r0
    17aa:	e2 f7       	brpl	.-8      	; 0x17a4 <MDIO_Error_State_SetNippleValue+0x12a>
    17ac:	80 95       	com	r24
    17ae:	84 23       	and	r24, r20
    17b0:	8c 93       	st	X, r24
			PORTD|=Copy_u8Value;
    17b2:	a2 e3       	ldi	r26, 0x32	; 50
    17b4:	b0 e0       	ldi	r27, 0x00	; 0
    17b6:	e2 e3       	ldi	r30, 0x32	; 50
    17b8:	f0 e0       	ldi	r31, 0x00	; 0
    17ba:	90 81       	ld	r25, Z
    17bc:	8c 81       	ldd	r24, Y+4	; 0x04
    17be:	89 2b       	or	r24, r25
    17c0:	8c 93       	st	X, r24
    17c2:	03 c0       	rjmp	.+6      	; 0x17ca <MDIO_Error_State_SetNippleValue+0x150>
			break;
		default:
			LOC_Error_State_ReturnState=NOK;
    17c4:	19 82       	std	Y+1, r1	; 0x01
    17c6:	01 c0       	rjmp	.+2      	; 0x17ca <MDIO_Error_State_SetNippleValue+0x150>
		}
	}
	else
	{
		LOC_Error_State_ReturnState=NOK;
    17c8:	19 82       	std	Y+1, r1	; 0x01
	}
	return LOC_Error_State_ReturnState;
    17ca:	89 81       	ldd	r24, Y+1	; 0x01
}
    17cc:	26 96       	adiw	r28, 0x06	; 6
    17ce:	0f b6       	in	r0, 0x3f	; 63
    17d0:	f8 94       	cli
    17d2:	de bf       	out	0x3e, r29	; 62
    17d4:	0f be       	out	0x3f, r0	; 63
    17d6:	cd bf       	out	0x3d, r28	; 61
    17d8:	cf 91       	pop	r28
    17da:	df 91       	pop	r29
    17dc:	08 95       	ret

000017de <DIO_voidSetPortDirection>:
#include"../../LIB/LSTD_TYPES.h"
#include"BIT_MATH.h"

void DIO_voidSetPortDirection(u8 copy_u8portID,u8 copy_u8PortDir )

{
    17de:	df 93       	push	r29
    17e0:	cf 93       	push	r28
    17e2:	00 d0       	rcall	.+0      	; 0x17e4 <DIO_voidSetPortDirection+0x6>
    17e4:	00 d0       	rcall	.+0      	; 0x17e6 <DIO_voidSetPortDirection+0x8>
    17e6:	cd b7       	in	r28, 0x3d	; 61
    17e8:	de b7       	in	r29, 0x3e	; 62
    17ea:	89 83       	std	Y+1, r24	; 0x01
    17ec:	6a 83       	std	Y+2, r22	; 0x02
	switch(copy_u8portID)
    17ee:	89 81       	ldd	r24, Y+1	; 0x01
    17f0:	28 2f       	mov	r18, r24
    17f2:	30 e0       	ldi	r19, 0x00	; 0
    17f4:	3c 83       	std	Y+4, r19	; 0x04
    17f6:	2b 83       	std	Y+3, r18	; 0x03
    17f8:	8b 81       	ldd	r24, Y+3	; 0x03
    17fa:	9c 81       	ldd	r25, Y+4	; 0x04
    17fc:	81 30       	cpi	r24, 0x01	; 1
    17fe:	91 05       	cpc	r25, r1
    1800:	d1 f0       	breq	.+52     	; 0x1836 <DIO_voidSetPortDirection+0x58>
    1802:	2b 81       	ldd	r18, Y+3	; 0x03
    1804:	3c 81       	ldd	r19, Y+4	; 0x04
    1806:	22 30       	cpi	r18, 0x02	; 2
    1808:	31 05       	cpc	r19, r1
    180a:	2c f4       	brge	.+10     	; 0x1816 <DIO_voidSetPortDirection+0x38>
    180c:	8b 81       	ldd	r24, Y+3	; 0x03
    180e:	9c 81       	ldd	r25, Y+4	; 0x04
    1810:	00 97       	sbiw	r24, 0x00	; 0
    1812:	61 f0       	breq	.+24     	; 0x182c <DIO_voidSetPortDirection+0x4e>
    1814:	1e c0       	rjmp	.+60     	; 0x1852 <DIO_voidSetPortDirection+0x74>
    1816:	2b 81       	ldd	r18, Y+3	; 0x03
    1818:	3c 81       	ldd	r19, Y+4	; 0x04
    181a:	22 30       	cpi	r18, 0x02	; 2
    181c:	31 05       	cpc	r19, r1
    181e:	81 f0       	breq	.+32     	; 0x1840 <DIO_voidSetPortDirection+0x62>
    1820:	8b 81       	ldd	r24, Y+3	; 0x03
    1822:	9c 81       	ldd	r25, Y+4	; 0x04
    1824:	83 30       	cpi	r24, 0x03	; 3
    1826:	91 05       	cpc	r25, r1
    1828:	81 f0       	breq	.+32     	; 0x184a <DIO_voidSetPortDirection+0x6c>
    182a:	13 c0       	rjmp	.+38     	; 0x1852 <DIO_voidSetPortDirection+0x74>
	{
	case PORTA_ID :   DDRA_REG= copy_u8PortDir ; break ;
    182c:	ea e3       	ldi	r30, 0x3A	; 58
    182e:	f0 e0       	ldi	r31, 0x00	; 0
    1830:	8a 81       	ldd	r24, Y+2	; 0x02
    1832:	80 83       	st	Z, r24
    1834:	0e c0       	rjmp	.+28     	; 0x1852 <DIO_voidSetPortDirection+0x74>
	case PORTB_ID :   DDRB_REG= copy_u8PortDir ; break ;
    1836:	e7 e3       	ldi	r30, 0x37	; 55
    1838:	f0 e0       	ldi	r31, 0x00	; 0
    183a:	8a 81       	ldd	r24, Y+2	; 0x02
    183c:	80 83       	st	Z, r24
    183e:	09 c0       	rjmp	.+18     	; 0x1852 <DIO_voidSetPortDirection+0x74>
	case PORTC_ID :   DDRC_REG= copy_u8PortDir ; break ;
    1840:	e4 e3       	ldi	r30, 0x34	; 52
    1842:	f0 e0       	ldi	r31, 0x00	; 0
    1844:	8a 81       	ldd	r24, Y+2	; 0x02
    1846:	80 83       	st	Z, r24
    1848:	04 c0       	rjmp	.+8      	; 0x1852 <DIO_voidSetPortDirection+0x74>
	case PORTD_ID :   DDRD_REG= copy_u8PortDir ; break ;
    184a:	e1 e3       	ldi	r30, 0x31	; 49
    184c:	f0 e0       	ldi	r31, 0x00	; 0
    184e:	8a 81       	ldd	r24, Y+2	; 0x02
    1850:	80 83       	st	Z, r24

	}
}
    1852:	0f 90       	pop	r0
    1854:	0f 90       	pop	r0
    1856:	0f 90       	pop	r0
    1858:	0f 90       	pop	r0
    185a:	cf 91       	pop	r28
    185c:	df 91       	pop	r29
    185e:	08 95       	ret

00001860 <DIO_voidSetPortValue>:


void DIO_voidSetPortValue(u8 copy_u8PortID,u8 copy_u8PortVal )

{
    1860:	df 93       	push	r29
    1862:	cf 93       	push	r28
    1864:	00 d0       	rcall	.+0      	; 0x1866 <DIO_voidSetPortValue+0x6>
    1866:	00 d0       	rcall	.+0      	; 0x1868 <DIO_voidSetPortValue+0x8>
    1868:	cd b7       	in	r28, 0x3d	; 61
    186a:	de b7       	in	r29, 0x3e	; 62
    186c:	89 83       	std	Y+1, r24	; 0x01
    186e:	6a 83       	std	Y+2, r22	; 0x02

	switch(copy_u8PortID)
    1870:	89 81       	ldd	r24, Y+1	; 0x01
    1872:	28 2f       	mov	r18, r24
    1874:	30 e0       	ldi	r19, 0x00	; 0
    1876:	3c 83       	std	Y+4, r19	; 0x04
    1878:	2b 83       	std	Y+3, r18	; 0x03
    187a:	8b 81       	ldd	r24, Y+3	; 0x03
    187c:	9c 81       	ldd	r25, Y+4	; 0x04
    187e:	81 30       	cpi	r24, 0x01	; 1
    1880:	91 05       	cpc	r25, r1
    1882:	d1 f0       	breq	.+52     	; 0x18b8 <DIO_voidSetPortValue+0x58>
    1884:	2b 81       	ldd	r18, Y+3	; 0x03
    1886:	3c 81       	ldd	r19, Y+4	; 0x04
    1888:	22 30       	cpi	r18, 0x02	; 2
    188a:	31 05       	cpc	r19, r1
    188c:	2c f4       	brge	.+10     	; 0x1898 <DIO_voidSetPortValue+0x38>
    188e:	8b 81       	ldd	r24, Y+3	; 0x03
    1890:	9c 81       	ldd	r25, Y+4	; 0x04
    1892:	00 97       	sbiw	r24, 0x00	; 0
    1894:	61 f0       	breq	.+24     	; 0x18ae <DIO_voidSetPortValue+0x4e>
    1896:	1e c0       	rjmp	.+60     	; 0x18d4 <DIO_voidSetPortValue+0x74>
    1898:	2b 81       	ldd	r18, Y+3	; 0x03
    189a:	3c 81       	ldd	r19, Y+4	; 0x04
    189c:	22 30       	cpi	r18, 0x02	; 2
    189e:	31 05       	cpc	r19, r1
    18a0:	81 f0       	breq	.+32     	; 0x18c2 <DIO_voidSetPortValue+0x62>
    18a2:	8b 81       	ldd	r24, Y+3	; 0x03
    18a4:	9c 81       	ldd	r25, Y+4	; 0x04
    18a6:	83 30       	cpi	r24, 0x03	; 3
    18a8:	91 05       	cpc	r25, r1
    18aa:	81 f0       	breq	.+32     	; 0x18cc <DIO_voidSetPortValue+0x6c>
    18ac:	13 c0       	rjmp	.+38     	; 0x18d4 <DIO_voidSetPortValue+0x74>
	{
	case PORTA_ID :   PORTA_REG= copy_u8PortVal ; break ;
    18ae:	eb e3       	ldi	r30, 0x3B	; 59
    18b0:	f0 e0       	ldi	r31, 0x00	; 0
    18b2:	8a 81       	ldd	r24, Y+2	; 0x02
    18b4:	80 83       	st	Z, r24
    18b6:	0e c0       	rjmp	.+28     	; 0x18d4 <DIO_voidSetPortValue+0x74>
	case PORTB_ID :   PORTD_REG= copy_u8PortVal ; break ;
    18b8:	e2 e3       	ldi	r30, 0x32	; 50
    18ba:	f0 e0       	ldi	r31, 0x00	; 0
    18bc:	8a 81       	ldd	r24, Y+2	; 0x02
    18be:	80 83       	st	Z, r24
    18c0:	09 c0       	rjmp	.+18     	; 0x18d4 <DIO_voidSetPortValue+0x74>
	case PORTC_ID :   PORTC_REG= copy_u8PortVal ; break ;
    18c2:	e5 e3       	ldi	r30, 0x35	; 53
    18c4:	f0 e0       	ldi	r31, 0x00	; 0
    18c6:	8a 81       	ldd	r24, Y+2	; 0x02
    18c8:	80 83       	st	Z, r24
    18ca:	04 c0       	rjmp	.+8      	; 0x18d4 <DIO_voidSetPortValue+0x74>
	case PORTD_ID :   PORTD_REG= copy_u8PortVal ; break ;
    18cc:	e2 e3       	ldi	r30, 0x32	; 50
    18ce:	f0 e0       	ldi	r31, 0x00	; 0
    18d0:	8a 81       	ldd	r24, Y+2	; 0x02
    18d2:	80 83       	st	Z, r24

	}
}
    18d4:	0f 90       	pop	r0
    18d6:	0f 90       	pop	r0
    18d8:	0f 90       	pop	r0
    18da:	0f 90       	pop	r0
    18dc:	cf 91       	pop	r28
    18de:	df 91       	pop	r29
    18e0:	08 95       	ret

000018e2 <DIO_voidSetPinDirection>:
void DIO_voidSetPinDirection(u8 PORT_ID, u8 PIN_ID, u8 DDR_ID)
{
    18e2:	df 93       	push	r29
    18e4:	cf 93       	push	r28
    18e6:	cd b7       	in	r28, 0x3d	; 61
    18e8:	de b7       	in	r29, 0x3e	; 62
    18ea:	27 97       	sbiw	r28, 0x07	; 7
    18ec:	0f b6       	in	r0, 0x3f	; 63
    18ee:	f8 94       	cli
    18f0:	de bf       	out	0x3e, r29	; 62
    18f2:	0f be       	out	0x3f, r0	; 63
    18f4:	cd bf       	out	0x3d, r28	; 61
    18f6:	89 83       	std	Y+1, r24	; 0x01
    18f8:	6a 83       	std	Y+2, r22	; 0x02
    18fa:	4b 83       	std	Y+3, r20	; 0x03
		if(DDR_ID==PIN_OUTPUT)//Output
    18fc:	8b 81       	ldd	r24, Y+3	; 0x03
    18fe:	81 30       	cpi	r24, 0x01	; 1
    1900:	09 f0       	breq	.+2      	; 0x1904 <DIO_voidSetPinDirection+0x22>
    1902:	6f c0       	rjmp	.+222    	; 0x19e2 <DIO_voidSetPinDirection+0x100>
		{
			switch(PORT_ID)
    1904:	89 81       	ldd	r24, Y+1	; 0x01
    1906:	28 2f       	mov	r18, r24
    1908:	30 e0       	ldi	r19, 0x00	; 0
    190a:	3f 83       	std	Y+7, r19	; 0x07
    190c:	2e 83       	std	Y+6, r18	; 0x06
    190e:	8e 81       	ldd	r24, Y+6	; 0x06
    1910:	9f 81       	ldd	r25, Y+7	; 0x07
    1912:	81 30       	cpi	r24, 0x01	; 1
    1914:	91 05       	cpc	r25, r1
    1916:	49 f1       	breq	.+82     	; 0x196a <DIO_voidSetPinDirection+0x88>
    1918:	2e 81       	ldd	r18, Y+6	; 0x06
    191a:	3f 81       	ldd	r19, Y+7	; 0x07
    191c:	22 30       	cpi	r18, 0x02	; 2
    191e:	31 05       	cpc	r19, r1
    1920:	2c f4       	brge	.+10     	; 0x192c <DIO_voidSetPinDirection+0x4a>
    1922:	8e 81       	ldd	r24, Y+6	; 0x06
    1924:	9f 81       	ldd	r25, Y+7	; 0x07
    1926:	00 97       	sbiw	r24, 0x00	; 0
    1928:	61 f0       	breq	.+24     	; 0x1942 <DIO_voidSetPinDirection+0x60>
    192a:	d2 c0       	rjmp	.+420    	; 0x1ad0 <DIO_voidSetPinDirection+0x1ee>
    192c:	2e 81       	ldd	r18, Y+6	; 0x06
    192e:	3f 81       	ldd	r19, Y+7	; 0x07
    1930:	22 30       	cpi	r18, 0x02	; 2
    1932:	31 05       	cpc	r19, r1
    1934:	71 f1       	breq	.+92     	; 0x1992 <DIO_voidSetPinDirection+0xb0>
    1936:	8e 81       	ldd	r24, Y+6	; 0x06
    1938:	9f 81       	ldd	r25, Y+7	; 0x07
    193a:	83 30       	cpi	r24, 0x03	; 3
    193c:	91 05       	cpc	r25, r1
    193e:	e9 f1       	breq	.+122    	; 0x19ba <DIO_voidSetPinDirection+0xd8>
    1940:	c7 c0       	rjmp	.+398    	; 0x1ad0 <DIO_voidSetPinDirection+0x1ee>
			{
			case PORTA_ID:    SET_BIT(DDRA_REG,PIN_ID); break;
    1942:	aa e3       	ldi	r26, 0x3A	; 58
    1944:	b0 e0       	ldi	r27, 0x00	; 0
    1946:	ea e3       	ldi	r30, 0x3A	; 58
    1948:	f0 e0       	ldi	r31, 0x00	; 0
    194a:	80 81       	ld	r24, Z
    194c:	48 2f       	mov	r20, r24
    194e:	8a 81       	ldd	r24, Y+2	; 0x02
    1950:	28 2f       	mov	r18, r24
    1952:	30 e0       	ldi	r19, 0x00	; 0
    1954:	81 e0       	ldi	r24, 0x01	; 1
    1956:	90 e0       	ldi	r25, 0x00	; 0
    1958:	02 2e       	mov	r0, r18
    195a:	02 c0       	rjmp	.+4      	; 0x1960 <DIO_voidSetPinDirection+0x7e>
    195c:	88 0f       	add	r24, r24
    195e:	99 1f       	adc	r25, r25
    1960:	0a 94       	dec	r0
    1962:	e2 f7       	brpl	.-8      	; 0x195c <DIO_voidSetPinDirection+0x7a>
    1964:	84 2b       	or	r24, r20
    1966:	8c 93       	st	X, r24
    1968:	b3 c0       	rjmp	.+358    	; 0x1ad0 <DIO_voidSetPinDirection+0x1ee>
			case PORTB_ID:    SET_BIT(DDRB_REG,PIN_ID); break;
    196a:	a7 e3       	ldi	r26, 0x37	; 55
    196c:	b0 e0       	ldi	r27, 0x00	; 0
    196e:	e7 e3       	ldi	r30, 0x37	; 55
    1970:	f0 e0       	ldi	r31, 0x00	; 0
    1972:	80 81       	ld	r24, Z
    1974:	48 2f       	mov	r20, r24
    1976:	8a 81       	ldd	r24, Y+2	; 0x02
    1978:	28 2f       	mov	r18, r24
    197a:	30 e0       	ldi	r19, 0x00	; 0
    197c:	81 e0       	ldi	r24, 0x01	; 1
    197e:	90 e0       	ldi	r25, 0x00	; 0
    1980:	02 2e       	mov	r0, r18
    1982:	02 c0       	rjmp	.+4      	; 0x1988 <DIO_voidSetPinDirection+0xa6>
    1984:	88 0f       	add	r24, r24
    1986:	99 1f       	adc	r25, r25
    1988:	0a 94       	dec	r0
    198a:	e2 f7       	brpl	.-8      	; 0x1984 <DIO_voidSetPinDirection+0xa2>
    198c:	84 2b       	or	r24, r20
    198e:	8c 93       	st	X, r24
    1990:	9f c0       	rjmp	.+318    	; 0x1ad0 <DIO_voidSetPinDirection+0x1ee>
			case PORTC_ID:    SET_BIT(DDRC_REG,PIN_ID); break;
    1992:	a4 e3       	ldi	r26, 0x34	; 52
    1994:	b0 e0       	ldi	r27, 0x00	; 0
    1996:	e4 e3       	ldi	r30, 0x34	; 52
    1998:	f0 e0       	ldi	r31, 0x00	; 0
    199a:	80 81       	ld	r24, Z
    199c:	48 2f       	mov	r20, r24
    199e:	8a 81       	ldd	r24, Y+2	; 0x02
    19a0:	28 2f       	mov	r18, r24
    19a2:	30 e0       	ldi	r19, 0x00	; 0
    19a4:	81 e0       	ldi	r24, 0x01	; 1
    19a6:	90 e0       	ldi	r25, 0x00	; 0
    19a8:	02 2e       	mov	r0, r18
    19aa:	02 c0       	rjmp	.+4      	; 0x19b0 <DIO_voidSetPinDirection+0xce>
    19ac:	88 0f       	add	r24, r24
    19ae:	99 1f       	adc	r25, r25
    19b0:	0a 94       	dec	r0
    19b2:	e2 f7       	brpl	.-8      	; 0x19ac <DIO_voidSetPinDirection+0xca>
    19b4:	84 2b       	or	r24, r20
    19b6:	8c 93       	st	X, r24
    19b8:	8b c0       	rjmp	.+278    	; 0x1ad0 <DIO_voidSetPinDirection+0x1ee>
			case PORTD_ID:    SET_BIT(DDRD_REG,PIN_ID); break;
    19ba:	a1 e3       	ldi	r26, 0x31	; 49
    19bc:	b0 e0       	ldi	r27, 0x00	; 0
    19be:	e1 e3       	ldi	r30, 0x31	; 49
    19c0:	f0 e0       	ldi	r31, 0x00	; 0
    19c2:	80 81       	ld	r24, Z
    19c4:	48 2f       	mov	r20, r24
    19c6:	8a 81       	ldd	r24, Y+2	; 0x02
    19c8:	28 2f       	mov	r18, r24
    19ca:	30 e0       	ldi	r19, 0x00	; 0
    19cc:	81 e0       	ldi	r24, 0x01	; 1
    19ce:	90 e0       	ldi	r25, 0x00	; 0
    19d0:	02 2e       	mov	r0, r18
    19d2:	02 c0       	rjmp	.+4      	; 0x19d8 <DIO_voidSetPinDirection+0xf6>
    19d4:	88 0f       	add	r24, r24
    19d6:	99 1f       	adc	r25, r25
    19d8:	0a 94       	dec	r0
    19da:	e2 f7       	brpl	.-8      	; 0x19d4 <DIO_voidSetPinDirection+0xf2>
    19dc:	84 2b       	or	r24, r20
    19de:	8c 93       	st	X, r24
    19e0:	77 c0       	rjmp	.+238    	; 0x1ad0 <DIO_voidSetPinDirection+0x1ee>

			default:   break;

			}
		}
		else if(DDR_ID==PIN_INPUT)//Input
    19e2:	8b 81       	ldd	r24, Y+3	; 0x03
    19e4:	88 23       	and	r24, r24
    19e6:	09 f0       	breq	.+2      	; 0x19ea <DIO_voidSetPinDirection+0x108>
    19e8:	73 c0       	rjmp	.+230    	; 0x1ad0 <DIO_voidSetPinDirection+0x1ee>
		{
			switch(PORT_ID)
    19ea:	89 81       	ldd	r24, Y+1	; 0x01
    19ec:	28 2f       	mov	r18, r24
    19ee:	30 e0       	ldi	r19, 0x00	; 0
    19f0:	3d 83       	std	Y+5, r19	; 0x05
    19f2:	2c 83       	std	Y+4, r18	; 0x04
    19f4:	8c 81       	ldd	r24, Y+4	; 0x04
    19f6:	9d 81       	ldd	r25, Y+5	; 0x05
    19f8:	81 30       	cpi	r24, 0x01	; 1
    19fa:	91 05       	cpc	r25, r1
    19fc:	59 f1       	breq	.+86     	; 0x1a54 <DIO_voidSetPinDirection+0x172>
    19fe:	2c 81       	ldd	r18, Y+4	; 0x04
    1a00:	3d 81       	ldd	r19, Y+5	; 0x05
    1a02:	22 30       	cpi	r18, 0x02	; 2
    1a04:	31 05       	cpc	r19, r1
    1a06:	2c f4       	brge	.+10     	; 0x1a12 <DIO_voidSetPinDirection+0x130>
    1a08:	8c 81       	ldd	r24, Y+4	; 0x04
    1a0a:	9d 81       	ldd	r25, Y+5	; 0x05
    1a0c:	00 97       	sbiw	r24, 0x00	; 0
    1a0e:	69 f0       	breq	.+26     	; 0x1a2a <DIO_voidSetPinDirection+0x148>
    1a10:	5f c0       	rjmp	.+190    	; 0x1ad0 <DIO_voidSetPinDirection+0x1ee>
    1a12:	2c 81       	ldd	r18, Y+4	; 0x04
    1a14:	3d 81       	ldd	r19, Y+5	; 0x05
    1a16:	22 30       	cpi	r18, 0x02	; 2
    1a18:	31 05       	cpc	r19, r1
    1a1a:	89 f1       	breq	.+98     	; 0x1a7e <DIO_voidSetPinDirection+0x19c>
    1a1c:	8c 81       	ldd	r24, Y+4	; 0x04
    1a1e:	9d 81       	ldd	r25, Y+5	; 0x05
    1a20:	83 30       	cpi	r24, 0x03	; 3
    1a22:	91 05       	cpc	r25, r1
    1a24:	09 f4       	brne	.+2      	; 0x1a28 <DIO_voidSetPinDirection+0x146>
    1a26:	40 c0       	rjmp	.+128    	; 0x1aa8 <DIO_voidSetPinDirection+0x1c6>
    1a28:	53 c0       	rjmp	.+166    	; 0x1ad0 <DIO_voidSetPinDirection+0x1ee>
			{
			case PORTA_ID:   CLR_BIT(DDRA_REG,PIN_ID); break;
    1a2a:	aa e3       	ldi	r26, 0x3A	; 58
    1a2c:	b0 e0       	ldi	r27, 0x00	; 0
    1a2e:	ea e3       	ldi	r30, 0x3A	; 58
    1a30:	f0 e0       	ldi	r31, 0x00	; 0
    1a32:	80 81       	ld	r24, Z
    1a34:	48 2f       	mov	r20, r24
    1a36:	8a 81       	ldd	r24, Y+2	; 0x02
    1a38:	28 2f       	mov	r18, r24
    1a3a:	30 e0       	ldi	r19, 0x00	; 0
    1a3c:	81 e0       	ldi	r24, 0x01	; 1
    1a3e:	90 e0       	ldi	r25, 0x00	; 0
    1a40:	02 2e       	mov	r0, r18
    1a42:	02 c0       	rjmp	.+4      	; 0x1a48 <DIO_voidSetPinDirection+0x166>
    1a44:	88 0f       	add	r24, r24
    1a46:	99 1f       	adc	r25, r25
    1a48:	0a 94       	dec	r0
    1a4a:	e2 f7       	brpl	.-8      	; 0x1a44 <DIO_voidSetPinDirection+0x162>
    1a4c:	80 95       	com	r24
    1a4e:	84 23       	and	r24, r20
    1a50:	8c 93       	st	X, r24
    1a52:	3e c0       	rjmp	.+124    	; 0x1ad0 <DIO_voidSetPinDirection+0x1ee>
			case PORTB_ID:   CLR_BIT(DDRB_REG,PIN_ID); break;
    1a54:	a7 e3       	ldi	r26, 0x37	; 55
    1a56:	b0 e0       	ldi	r27, 0x00	; 0
    1a58:	e7 e3       	ldi	r30, 0x37	; 55
    1a5a:	f0 e0       	ldi	r31, 0x00	; 0
    1a5c:	80 81       	ld	r24, Z
    1a5e:	48 2f       	mov	r20, r24
    1a60:	8a 81       	ldd	r24, Y+2	; 0x02
    1a62:	28 2f       	mov	r18, r24
    1a64:	30 e0       	ldi	r19, 0x00	; 0
    1a66:	81 e0       	ldi	r24, 0x01	; 1
    1a68:	90 e0       	ldi	r25, 0x00	; 0
    1a6a:	02 2e       	mov	r0, r18
    1a6c:	02 c0       	rjmp	.+4      	; 0x1a72 <DIO_voidSetPinDirection+0x190>
    1a6e:	88 0f       	add	r24, r24
    1a70:	99 1f       	adc	r25, r25
    1a72:	0a 94       	dec	r0
    1a74:	e2 f7       	brpl	.-8      	; 0x1a6e <DIO_voidSetPinDirection+0x18c>
    1a76:	80 95       	com	r24
    1a78:	84 23       	and	r24, r20
    1a7a:	8c 93       	st	X, r24
    1a7c:	29 c0       	rjmp	.+82     	; 0x1ad0 <DIO_voidSetPinDirection+0x1ee>
			case PORTC_ID:   CLR_BIT(DDRC_REG,PIN_ID); break;
    1a7e:	a4 e3       	ldi	r26, 0x34	; 52
    1a80:	b0 e0       	ldi	r27, 0x00	; 0
    1a82:	e4 e3       	ldi	r30, 0x34	; 52
    1a84:	f0 e0       	ldi	r31, 0x00	; 0
    1a86:	80 81       	ld	r24, Z
    1a88:	48 2f       	mov	r20, r24
    1a8a:	8a 81       	ldd	r24, Y+2	; 0x02
    1a8c:	28 2f       	mov	r18, r24
    1a8e:	30 e0       	ldi	r19, 0x00	; 0
    1a90:	81 e0       	ldi	r24, 0x01	; 1
    1a92:	90 e0       	ldi	r25, 0x00	; 0
    1a94:	02 2e       	mov	r0, r18
    1a96:	02 c0       	rjmp	.+4      	; 0x1a9c <DIO_voidSetPinDirection+0x1ba>
    1a98:	88 0f       	add	r24, r24
    1a9a:	99 1f       	adc	r25, r25
    1a9c:	0a 94       	dec	r0
    1a9e:	e2 f7       	brpl	.-8      	; 0x1a98 <DIO_voidSetPinDirection+0x1b6>
    1aa0:	80 95       	com	r24
    1aa2:	84 23       	and	r24, r20
    1aa4:	8c 93       	st	X, r24
    1aa6:	14 c0       	rjmp	.+40     	; 0x1ad0 <DIO_voidSetPinDirection+0x1ee>
			case PORTD_ID:   CLR_BIT(DDRD_REG,PIN_ID); break;
    1aa8:	a1 e3       	ldi	r26, 0x31	; 49
    1aaa:	b0 e0       	ldi	r27, 0x00	; 0
    1aac:	e1 e3       	ldi	r30, 0x31	; 49
    1aae:	f0 e0       	ldi	r31, 0x00	; 0
    1ab0:	80 81       	ld	r24, Z
    1ab2:	48 2f       	mov	r20, r24
    1ab4:	8a 81       	ldd	r24, Y+2	; 0x02
    1ab6:	28 2f       	mov	r18, r24
    1ab8:	30 e0       	ldi	r19, 0x00	; 0
    1aba:	81 e0       	ldi	r24, 0x01	; 1
    1abc:	90 e0       	ldi	r25, 0x00	; 0
    1abe:	02 2e       	mov	r0, r18
    1ac0:	02 c0       	rjmp	.+4      	; 0x1ac6 <DIO_voidSetPinDirection+0x1e4>
    1ac2:	88 0f       	add	r24, r24
    1ac4:	99 1f       	adc	r25, r25
    1ac6:	0a 94       	dec	r0
    1ac8:	e2 f7       	brpl	.-8      	; 0x1ac2 <DIO_voidSetPinDirection+0x1e0>
    1aca:	80 95       	com	r24
    1acc:	84 23       	and	r24, r20
    1ace:	8c 93       	st	X, r24
			default:   break;
			}
		}
	}
    1ad0:	27 96       	adiw	r28, 0x07	; 7
    1ad2:	0f b6       	in	r0, 0x3f	; 63
    1ad4:	f8 94       	cli
    1ad6:	de bf       	out	0x3e, r29	; 62
    1ad8:	0f be       	out	0x3f, r0	; 63
    1ada:	cd bf       	out	0x3d, r28	; 61
    1adc:	cf 91       	pop	r28
    1ade:	df 91       	pop	r29
    1ae0:	08 95       	ret

00001ae2 <DIO_voidSetPinValue>:


void DIO_voidSetPinValue(u8 PORT_ID, u8 PIN_ID, u8 value_ID)
{
    1ae2:	df 93       	push	r29
    1ae4:	cf 93       	push	r28
    1ae6:	cd b7       	in	r28, 0x3d	; 61
    1ae8:	de b7       	in	r29, 0x3e	; 62
    1aea:	27 97       	sbiw	r28, 0x07	; 7
    1aec:	0f b6       	in	r0, 0x3f	; 63
    1aee:	f8 94       	cli
    1af0:	de bf       	out	0x3e, r29	; 62
    1af2:	0f be       	out	0x3f, r0	; 63
    1af4:	cd bf       	out	0x3d, r28	; 61
    1af6:	89 83       	std	Y+1, r24	; 0x01
    1af8:	6a 83       	std	Y+2, r22	; 0x02
    1afa:	4b 83       	std	Y+3, r20	; 0x03
		if(value_ID==PIN_HIGH)//High
    1afc:	8b 81       	ldd	r24, Y+3	; 0x03
    1afe:	81 30       	cpi	r24, 0x01	; 1
    1b00:	09 f0       	breq	.+2      	; 0x1b04 <DIO_voidSetPinValue+0x22>
    1b02:	6f c0       	rjmp	.+222    	; 0x1be2 <DIO_voidSetPinValue+0x100>
		{
			switch(PORT_ID)
    1b04:	89 81       	ldd	r24, Y+1	; 0x01
    1b06:	28 2f       	mov	r18, r24
    1b08:	30 e0       	ldi	r19, 0x00	; 0
    1b0a:	3f 83       	std	Y+7, r19	; 0x07
    1b0c:	2e 83       	std	Y+6, r18	; 0x06
    1b0e:	8e 81       	ldd	r24, Y+6	; 0x06
    1b10:	9f 81       	ldd	r25, Y+7	; 0x07
    1b12:	81 30       	cpi	r24, 0x01	; 1
    1b14:	91 05       	cpc	r25, r1
    1b16:	49 f1       	breq	.+82     	; 0x1b6a <DIO_voidSetPinValue+0x88>
    1b18:	2e 81       	ldd	r18, Y+6	; 0x06
    1b1a:	3f 81       	ldd	r19, Y+7	; 0x07
    1b1c:	22 30       	cpi	r18, 0x02	; 2
    1b1e:	31 05       	cpc	r19, r1
    1b20:	2c f4       	brge	.+10     	; 0x1b2c <DIO_voidSetPinValue+0x4a>
    1b22:	8e 81       	ldd	r24, Y+6	; 0x06
    1b24:	9f 81       	ldd	r25, Y+7	; 0x07
    1b26:	00 97       	sbiw	r24, 0x00	; 0
    1b28:	61 f0       	breq	.+24     	; 0x1b42 <DIO_voidSetPinValue+0x60>
    1b2a:	d2 c0       	rjmp	.+420    	; 0x1cd0 <DIO_voidSetPinValue+0x1ee>
    1b2c:	2e 81       	ldd	r18, Y+6	; 0x06
    1b2e:	3f 81       	ldd	r19, Y+7	; 0x07
    1b30:	22 30       	cpi	r18, 0x02	; 2
    1b32:	31 05       	cpc	r19, r1
    1b34:	71 f1       	breq	.+92     	; 0x1b92 <DIO_voidSetPinValue+0xb0>
    1b36:	8e 81       	ldd	r24, Y+6	; 0x06
    1b38:	9f 81       	ldd	r25, Y+7	; 0x07
    1b3a:	83 30       	cpi	r24, 0x03	; 3
    1b3c:	91 05       	cpc	r25, r1
    1b3e:	e9 f1       	breq	.+122    	; 0x1bba <DIO_voidSetPinValue+0xd8>
    1b40:	c7 c0       	rjmp	.+398    	; 0x1cd0 <DIO_voidSetPinValue+0x1ee>
			{
			case PORTA_ID :    SET_BIT(PORTA_REG,PIN_ID); break;
    1b42:	ab e3       	ldi	r26, 0x3B	; 59
    1b44:	b0 e0       	ldi	r27, 0x00	; 0
    1b46:	eb e3       	ldi	r30, 0x3B	; 59
    1b48:	f0 e0       	ldi	r31, 0x00	; 0
    1b4a:	80 81       	ld	r24, Z
    1b4c:	48 2f       	mov	r20, r24
    1b4e:	8a 81       	ldd	r24, Y+2	; 0x02
    1b50:	28 2f       	mov	r18, r24
    1b52:	30 e0       	ldi	r19, 0x00	; 0
    1b54:	81 e0       	ldi	r24, 0x01	; 1
    1b56:	90 e0       	ldi	r25, 0x00	; 0
    1b58:	02 2e       	mov	r0, r18
    1b5a:	02 c0       	rjmp	.+4      	; 0x1b60 <DIO_voidSetPinValue+0x7e>
    1b5c:	88 0f       	add	r24, r24
    1b5e:	99 1f       	adc	r25, r25
    1b60:	0a 94       	dec	r0
    1b62:	e2 f7       	brpl	.-8      	; 0x1b5c <DIO_voidSetPinValue+0x7a>
    1b64:	84 2b       	or	r24, r20
    1b66:	8c 93       	st	X, r24
    1b68:	b3 c0       	rjmp	.+358    	; 0x1cd0 <DIO_voidSetPinValue+0x1ee>
			case PORTB_ID :    SET_BIT(PORTB_REG,PIN_ID); break;
    1b6a:	a8 e3       	ldi	r26, 0x38	; 56
    1b6c:	b0 e0       	ldi	r27, 0x00	; 0
    1b6e:	e8 e3       	ldi	r30, 0x38	; 56
    1b70:	f0 e0       	ldi	r31, 0x00	; 0
    1b72:	80 81       	ld	r24, Z
    1b74:	48 2f       	mov	r20, r24
    1b76:	8a 81       	ldd	r24, Y+2	; 0x02
    1b78:	28 2f       	mov	r18, r24
    1b7a:	30 e0       	ldi	r19, 0x00	; 0
    1b7c:	81 e0       	ldi	r24, 0x01	; 1
    1b7e:	90 e0       	ldi	r25, 0x00	; 0
    1b80:	02 2e       	mov	r0, r18
    1b82:	02 c0       	rjmp	.+4      	; 0x1b88 <DIO_voidSetPinValue+0xa6>
    1b84:	88 0f       	add	r24, r24
    1b86:	99 1f       	adc	r25, r25
    1b88:	0a 94       	dec	r0
    1b8a:	e2 f7       	brpl	.-8      	; 0x1b84 <DIO_voidSetPinValue+0xa2>
    1b8c:	84 2b       	or	r24, r20
    1b8e:	8c 93       	st	X, r24
    1b90:	9f c0       	rjmp	.+318    	; 0x1cd0 <DIO_voidSetPinValue+0x1ee>
			case PORTC_ID :    SET_BIT(PORTC_REG,PIN_ID); break;
    1b92:	a5 e3       	ldi	r26, 0x35	; 53
    1b94:	b0 e0       	ldi	r27, 0x00	; 0
    1b96:	e5 e3       	ldi	r30, 0x35	; 53
    1b98:	f0 e0       	ldi	r31, 0x00	; 0
    1b9a:	80 81       	ld	r24, Z
    1b9c:	48 2f       	mov	r20, r24
    1b9e:	8a 81       	ldd	r24, Y+2	; 0x02
    1ba0:	28 2f       	mov	r18, r24
    1ba2:	30 e0       	ldi	r19, 0x00	; 0
    1ba4:	81 e0       	ldi	r24, 0x01	; 1
    1ba6:	90 e0       	ldi	r25, 0x00	; 0
    1ba8:	02 2e       	mov	r0, r18
    1baa:	02 c0       	rjmp	.+4      	; 0x1bb0 <DIO_voidSetPinValue+0xce>
    1bac:	88 0f       	add	r24, r24
    1bae:	99 1f       	adc	r25, r25
    1bb0:	0a 94       	dec	r0
    1bb2:	e2 f7       	brpl	.-8      	; 0x1bac <DIO_voidSetPinValue+0xca>
    1bb4:	84 2b       	or	r24, r20
    1bb6:	8c 93       	st	X, r24
    1bb8:	8b c0       	rjmp	.+278    	; 0x1cd0 <DIO_voidSetPinValue+0x1ee>
			case PORTD_ID :    SET_BIT(PORTD_REG,PIN_ID); break;
    1bba:	a2 e3       	ldi	r26, 0x32	; 50
    1bbc:	b0 e0       	ldi	r27, 0x00	; 0
    1bbe:	e2 e3       	ldi	r30, 0x32	; 50
    1bc0:	f0 e0       	ldi	r31, 0x00	; 0
    1bc2:	80 81       	ld	r24, Z
    1bc4:	48 2f       	mov	r20, r24
    1bc6:	8a 81       	ldd	r24, Y+2	; 0x02
    1bc8:	28 2f       	mov	r18, r24
    1bca:	30 e0       	ldi	r19, 0x00	; 0
    1bcc:	81 e0       	ldi	r24, 0x01	; 1
    1bce:	90 e0       	ldi	r25, 0x00	; 0
    1bd0:	02 2e       	mov	r0, r18
    1bd2:	02 c0       	rjmp	.+4      	; 0x1bd8 <DIO_voidSetPinValue+0xf6>
    1bd4:	88 0f       	add	r24, r24
    1bd6:	99 1f       	adc	r25, r25
    1bd8:	0a 94       	dec	r0
    1bda:	e2 f7       	brpl	.-8      	; 0x1bd4 <DIO_voidSetPinValue+0xf2>
    1bdc:	84 2b       	or	r24, r20
    1bde:	8c 93       	st	X, r24
    1be0:	77 c0       	rjmp	.+238    	; 0x1cd0 <DIO_voidSetPinValue+0x1ee>

			}
		}
		else if(value_ID==PIN_LOW)//Low
    1be2:	8b 81       	ldd	r24, Y+3	; 0x03
    1be4:	88 23       	and	r24, r24
    1be6:	09 f0       	breq	.+2      	; 0x1bea <DIO_voidSetPinValue+0x108>
    1be8:	73 c0       	rjmp	.+230    	; 0x1cd0 <DIO_voidSetPinValue+0x1ee>
		{
			switch(PORT_ID)
    1bea:	89 81       	ldd	r24, Y+1	; 0x01
    1bec:	28 2f       	mov	r18, r24
    1bee:	30 e0       	ldi	r19, 0x00	; 0
    1bf0:	3d 83       	std	Y+5, r19	; 0x05
    1bf2:	2c 83       	std	Y+4, r18	; 0x04
    1bf4:	8c 81       	ldd	r24, Y+4	; 0x04
    1bf6:	9d 81       	ldd	r25, Y+5	; 0x05
    1bf8:	81 30       	cpi	r24, 0x01	; 1
    1bfa:	91 05       	cpc	r25, r1
    1bfc:	59 f1       	breq	.+86     	; 0x1c54 <DIO_voidSetPinValue+0x172>
    1bfe:	2c 81       	ldd	r18, Y+4	; 0x04
    1c00:	3d 81       	ldd	r19, Y+5	; 0x05
    1c02:	22 30       	cpi	r18, 0x02	; 2
    1c04:	31 05       	cpc	r19, r1
    1c06:	2c f4       	brge	.+10     	; 0x1c12 <DIO_voidSetPinValue+0x130>
    1c08:	8c 81       	ldd	r24, Y+4	; 0x04
    1c0a:	9d 81       	ldd	r25, Y+5	; 0x05
    1c0c:	00 97       	sbiw	r24, 0x00	; 0
    1c0e:	69 f0       	breq	.+26     	; 0x1c2a <DIO_voidSetPinValue+0x148>
    1c10:	5f c0       	rjmp	.+190    	; 0x1cd0 <DIO_voidSetPinValue+0x1ee>
    1c12:	2c 81       	ldd	r18, Y+4	; 0x04
    1c14:	3d 81       	ldd	r19, Y+5	; 0x05
    1c16:	22 30       	cpi	r18, 0x02	; 2
    1c18:	31 05       	cpc	r19, r1
    1c1a:	89 f1       	breq	.+98     	; 0x1c7e <DIO_voidSetPinValue+0x19c>
    1c1c:	8c 81       	ldd	r24, Y+4	; 0x04
    1c1e:	9d 81       	ldd	r25, Y+5	; 0x05
    1c20:	83 30       	cpi	r24, 0x03	; 3
    1c22:	91 05       	cpc	r25, r1
    1c24:	09 f4       	brne	.+2      	; 0x1c28 <DIO_voidSetPinValue+0x146>
    1c26:	40 c0       	rjmp	.+128    	; 0x1ca8 <DIO_voidSetPinValue+0x1c6>
    1c28:	53 c0       	rjmp	.+166    	; 0x1cd0 <DIO_voidSetPinValue+0x1ee>
			{
			case PORTA_ID : CLR_BIT(PORTA_REG,PIN_ID); break ;
    1c2a:	ab e3       	ldi	r26, 0x3B	; 59
    1c2c:	b0 e0       	ldi	r27, 0x00	; 0
    1c2e:	eb e3       	ldi	r30, 0x3B	; 59
    1c30:	f0 e0       	ldi	r31, 0x00	; 0
    1c32:	80 81       	ld	r24, Z
    1c34:	48 2f       	mov	r20, r24
    1c36:	8a 81       	ldd	r24, Y+2	; 0x02
    1c38:	28 2f       	mov	r18, r24
    1c3a:	30 e0       	ldi	r19, 0x00	; 0
    1c3c:	81 e0       	ldi	r24, 0x01	; 1
    1c3e:	90 e0       	ldi	r25, 0x00	; 0
    1c40:	02 2e       	mov	r0, r18
    1c42:	02 c0       	rjmp	.+4      	; 0x1c48 <DIO_voidSetPinValue+0x166>
    1c44:	88 0f       	add	r24, r24
    1c46:	99 1f       	adc	r25, r25
    1c48:	0a 94       	dec	r0
    1c4a:	e2 f7       	brpl	.-8      	; 0x1c44 <DIO_voidSetPinValue+0x162>
    1c4c:	80 95       	com	r24
    1c4e:	84 23       	and	r24, r20
    1c50:	8c 93       	st	X, r24
    1c52:	3e c0       	rjmp	.+124    	; 0x1cd0 <DIO_voidSetPinValue+0x1ee>
			case PORTB_ID : CLR_BIT(PORTB_REG,PIN_ID); break ;
    1c54:	a8 e3       	ldi	r26, 0x38	; 56
    1c56:	b0 e0       	ldi	r27, 0x00	; 0
    1c58:	e8 e3       	ldi	r30, 0x38	; 56
    1c5a:	f0 e0       	ldi	r31, 0x00	; 0
    1c5c:	80 81       	ld	r24, Z
    1c5e:	48 2f       	mov	r20, r24
    1c60:	8a 81       	ldd	r24, Y+2	; 0x02
    1c62:	28 2f       	mov	r18, r24
    1c64:	30 e0       	ldi	r19, 0x00	; 0
    1c66:	81 e0       	ldi	r24, 0x01	; 1
    1c68:	90 e0       	ldi	r25, 0x00	; 0
    1c6a:	02 2e       	mov	r0, r18
    1c6c:	02 c0       	rjmp	.+4      	; 0x1c72 <DIO_voidSetPinValue+0x190>
    1c6e:	88 0f       	add	r24, r24
    1c70:	99 1f       	adc	r25, r25
    1c72:	0a 94       	dec	r0
    1c74:	e2 f7       	brpl	.-8      	; 0x1c6e <DIO_voidSetPinValue+0x18c>
    1c76:	80 95       	com	r24
    1c78:	84 23       	and	r24, r20
    1c7a:	8c 93       	st	X, r24
    1c7c:	29 c0       	rjmp	.+82     	; 0x1cd0 <DIO_voidSetPinValue+0x1ee>
			case PORTC_ID : CLR_BIT(PORTC_REG,PIN_ID) ;break ;
    1c7e:	a5 e3       	ldi	r26, 0x35	; 53
    1c80:	b0 e0       	ldi	r27, 0x00	; 0
    1c82:	e5 e3       	ldi	r30, 0x35	; 53
    1c84:	f0 e0       	ldi	r31, 0x00	; 0
    1c86:	80 81       	ld	r24, Z
    1c88:	48 2f       	mov	r20, r24
    1c8a:	8a 81       	ldd	r24, Y+2	; 0x02
    1c8c:	28 2f       	mov	r18, r24
    1c8e:	30 e0       	ldi	r19, 0x00	; 0
    1c90:	81 e0       	ldi	r24, 0x01	; 1
    1c92:	90 e0       	ldi	r25, 0x00	; 0
    1c94:	02 2e       	mov	r0, r18
    1c96:	02 c0       	rjmp	.+4      	; 0x1c9c <DIO_voidSetPinValue+0x1ba>
    1c98:	88 0f       	add	r24, r24
    1c9a:	99 1f       	adc	r25, r25
    1c9c:	0a 94       	dec	r0
    1c9e:	e2 f7       	brpl	.-8      	; 0x1c98 <DIO_voidSetPinValue+0x1b6>
    1ca0:	80 95       	com	r24
    1ca2:	84 23       	and	r24, r20
    1ca4:	8c 93       	st	X, r24
    1ca6:	14 c0       	rjmp	.+40     	; 0x1cd0 <DIO_voidSetPinValue+0x1ee>
			case PORTD_ID : CLR_BIT(PORTD_REG,PIN_ID) ;break ;
    1ca8:	a2 e3       	ldi	r26, 0x32	; 50
    1caa:	b0 e0       	ldi	r27, 0x00	; 0
    1cac:	e2 e3       	ldi	r30, 0x32	; 50
    1cae:	f0 e0       	ldi	r31, 0x00	; 0
    1cb0:	80 81       	ld	r24, Z
    1cb2:	48 2f       	mov	r20, r24
    1cb4:	8a 81       	ldd	r24, Y+2	; 0x02
    1cb6:	28 2f       	mov	r18, r24
    1cb8:	30 e0       	ldi	r19, 0x00	; 0
    1cba:	81 e0       	ldi	r24, 0x01	; 1
    1cbc:	90 e0       	ldi	r25, 0x00	; 0
    1cbe:	02 2e       	mov	r0, r18
    1cc0:	02 c0       	rjmp	.+4      	; 0x1cc6 <DIO_voidSetPinValue+0x1e4>
    1cc2:	88 0f       	add	r24, r24
    1cc4:	99 1f       	adc	r25, r25
    1cc6:	0a 94       	dec	r0
    1cc8:	e2 f7       	brpl	.-8      	; 0x1cc2 <DIO_voidSetPinValue+0x1e0>
    1cca:	80 95       	com	r24
    1ccc:	84 23       	and	r24, r20
    1cce:	8c 93       	st	X, r24

			}
		}
}
    1cd0:	27 96       	adiw	r28, 0x07	; 7
    1cd2:	0f b6       	in	r0, 0x3f	; 63
    1cd4:	f8 94       	cli
    1cd6:	de bf       	out	0x3e, r29	; 62
    1cd8:	0f be       	out	0x3f, r0	; 63
    1cda:	cd bf       	out	0x3d, r28	; 61
    1cdc:	cf 91       	pop	r28
    1cde:	df 91       	pop	r29
    1ce0:	08 95       	ret

00001ce2 <DIO_voidToggelPin>:
void DIO_voidToggelPin(u8 copy_u8PortID,u8 copy_u8PinID)
{
    1ce2:	df 93       	push	r29
    1ce4:	cf 93       	push	r28
    1ce6:	00 d0       	rcall	.+0      	; 0x1ce8 <DIO_voidToggelPin+0x6>
    1ce8:	00 d0       	rcall	.+0      	; 0x1cea <DIO_voidToggelPin+0x8>
    1cea:	cd b7       	in	r28, 0x3d	; 61
    1cec:	de b7       	in	r29, 0x3e	; 62
    1cee:	89 83       	std	Y+1, r24	; 0x01
    1cf0:	6a 83       	std	Y+2, r22	; 0x02

	switch (copy_u8PortID)
    1cf2:	89 81       	ldd	r24, Y+1	; 0x01
    1cf4:	28 2f       	mov	r18, r24
    1cf6:	30 e0       	ldi	r19, 0x00	; 0
    1cf8:	3c 83       	std	Y+4, r19	; 0x04
    1cfa:	2b 83       	std	Y+3, r18	; 0x03
    1cfc:	8b 81       	ldd	r24, Y+3	; 0x03
    1cfe:	9c 81       	ldd	r25, Y+4	; 0x04
    1d00:	81 30       	cpi	r24, 0x01	; 1
    1d02:	91 05       	cpc	r25, r1
    1d04:	49 f1       	breq	.+82     	; 0x1d58 <DIO_voidToggelPin+0x76>
    1d06:	2b 81       	ldd	r18, Y+3	; 0x03
    1d08:	3c 81       	ldd	r19, Y+4	; 0x04
    1d0a:	22 30       	cpi	r18, 0x02	; 2
    1d0c:	31 05       	cpc	r19, r1
    1d0e:	2c f4       	brge	.+10     	; 0x1d1a <DIO_voidToggelPin+0x38>
    1d10:	8b 81       	ldd	r24, Y+3	; 0x03
    1d12:	9c 81       	ldd	r25, Y+4	; 0x04
    1d14:	00 97       	sbiw	r24, 0x00	; 0
    1d16:	61 f0       	breq	.+24     	; 0x1d30 <DIO_voidToggelPin+0x4e>
    1d18:	5a c0       	rjmp	.+180    	; 0x1dce <DIO_voidToggelPin+0xec>
    1d1a:	2b 81       	ldd	r18, Y+3	; 0x03
    1d1c:	3c 81       	ldd	r19, Y+4	; 0x04
    1d1e:	22 30       	cpi	r18, 0x02	; 2
    1d20:	31 05       	cpc	r19, r1
    1d22:	71 f1       	breq	.+92     	; 0x1d80 <DIO_voidToggelPin+0x9e>
    1d24:	8b 81       	ldd	r24, Y+3	; 0x03
    1d26:	9c 81       	ldd	r25, Y+4	; 0x04
    1d28:	83 30       	cpi	r24, 0x03	; 3
    1d2a:	91 05       	cpc	r25, r1
    1d2c:	e9 f1       	breq	.+122    	; 0x1da8 <DIO_voidToggelPin+0xc6>
    1d2e:	4f c0       	rjmp	.+158    	; 0x1dce <DIO_voidToggelPin+0xec>
	{
	case PORTA_ID :  TOG_BIT(PORTA_REG,copy_u8PinID) ; break ;
    1d30:	ab e3       	ldi	r26, 0x3B	; 59
    1d32:	b0 e0       	ldi	r27, 0x00	; 0
    1d34:	eb e3       	ldi	r30, 0x3B	; 59
    1d36:	f0 e0       	ldi	r31, 0x00	; 0
    1d38:	80 81       	ld	r24, Z
    1d3a:	48 2f       	mov	r20, r24
    1d3c:	8a 81       	ldd	r24, Y+2	; 0x02
    1d3e:	28 2f       	mov	r18, r24
    1d40:	30 e0       	ldi	r19, 0x00	; 0
    1d42:	81 e0       	ldi	r24, 0x01	; 1
    1d44:	90 e0       	ldi	r25, 0x00	; 0
    1d46:	02 2e       	mov	r0, r18
    1d48:	02 c0       	rjmp	.+4      	; 0x1d4e <DIO_voidToggelPin+0x6c>
    1d4a:	88 0f       	add	r24, r24
    1d4c:	99 1f       	adc	r25, r25
    1d4e:	0a 94       	dec	r0
    1d50:	e2 f7       	brpl	.-8      	; 0x1d4a <DIO_voidToggelPin+0x68>
    1d52:	84 27       	eor	r24, r20
    1d54:	8c 93       	st	X, r24
    1d56:	3b c0       	rjmp	.+118    	; 0x1dce <DIO_voidToggelPin+0xec>
	case PORTB_ID :  TOG_BIT(PORTB_REG,copy_u8PinID) ; break ;
    1d58:	a8 e3       	ldi	r26, 0x38	; 56
    1d5a:	b0 e0       	ldi	r27, 0x00	; 0
    1d5c:	e8 e3       	ldi	r30, 0x38	; 56
    1d5e:	f0 e0       	ldi	r31, 0x00	; 0
    1d60:	80 81       	ld	r24, Z
    1d62:	48 2f       	mov	r20, r24
    1d64:	8a 81       	ldd	r24, Y+2	; 0x02
    1d66:	28 2f       	mov	r18, r24
    1d68:	30 e0       	ldi	r19, 0x00	; 0
    1d6a:	81 e0       	ldi	r24, 0x01	; 1
    1d6c:	90 e0       	ldi	r25, 0x00	; 0
    1d6e:	02 2e       	mov	r0, r18
    1d70:	02 c0       	rjmp	.+4      	; 0x1d76 <DIO_voidToggelPin+0x94>
    1d72:	88 0f       	add	r24, r24
    1d74:	99 1f       	adc	r25, r25
    1d76:	0a 94       	dec	r0
    1d78:	e2 f7       	brpl	.-8      	; 0x1d72 <DIO_voidToggelPin+0x90>
    1d7a:	84 27       	eor	r24, r20
    1d7c:	8c 93       	st	X, r24
    1d7e:	27 c0       	rjmp	.+78     	; 0x1dce <DIO_voidToggelPin+0xec>
	case PORTC_ID :  TOG_BIT(PORTC_REG,copy_u8PinID) ; break ;
    1d80:	a5 e3       	ldi	r26, 0x35	; 53
    1d82:	b0 e0       	ldi	r27, 0x00	; 0
    1d84:	e5 e3       	ldi	r30, 0x35	; 53
    1d86:	f0 e0       	ldi	r31, 0x00	; 0
    1d88:	80 81       	ld	r24, Z
    1d8a:	48 2f       	mov	r20, r24
    1d8c:	8a 81       	ldd	r24, Y+2	; 0x02
    1d8e:	28 2f       	mov	r18, r24
    1d90:	30 e0       	ldi	r19, 0x00	; 0
    1d92:	81 e0       	ldi	r24, 0x01	; 1
    1d94:	90 e0       	ldi	r25, 0x00	; 0
    1d96:	02 2e       	mov	r0, r18
    1d98:	02 c0       	rjmp	.+4      	; 0x1d9e <DIO_voidToggelPin+0xbc>
    1d9a:	88 0f       	add	r24, r24
    1d9c:	99 1f       	adc	r25, r25
    1d9e:	0a 94       	dec	r0
    1da0:	e2 f7       	brpl	.-8      	; 0x1d9a <DIO_voidToggelPin+0xb8>
    1da2:	84 27       	eor	r24, r20
    1da4:	8c 93       	st	X, r24
    1da6:	13 c0       	rjmp	.+38     	; 0x1dce <DIO_voidToggelPin+0xec>
	case PORTD_ID :  TOG_BIT(PORTD_REG,copy_u8PinID) ; break ;
    1da8:	a2 e3       	ldi	r26, 0x32	; 50
    1daa:	b0 e0       	ldi	r27, 0x00	; 0
    1dac:	e2 e3       	ldi	r30, 0x32	; 50
    1dae:	f0 e0       	ldi	r31, 0x00	; 0
    1db0:	80 81       	ld	r24, Z
    1db2:	48 2f       	mov	r20, r24
    1db4:	8a 81       	ldd	r24, Y+2	; 0x02
    1db6:	28 2f       	mov	r18, r24
    1db8:	30 e0       	ldi	r19, 0x00	; 0
    1dba:	81 e0       	ldi	r24, 0x01	; 1
    1dbc:	90 e0       	ldi	r25, 0x00	; 0
    1dbe:	02 2e       	mov	r0, r18
    1dc0:	02 c0       	rjmp	.+4      	; 0x1dc6 <DIO_voidToggelPin+0xe4>
    1dc2:	88 0f       	add	r24, r24
    1dc4:	99 1f       	adc	r25, r25
    1dc6:	0a 94       	dec	r0
    1dc8:	e2 f7       	brpl	.-8      	; 0x1dc2 <DIO_voidToggelPin+0xe0>
    1dca:	84 27       	eor	r24, r20
    1dcc:	8c 93       	st	X, r24


	}
}
    1dce:	0f 90       	pop	r0
    1dd0:	0f 90       	pop	r0
    1dd2:	0f 90       	pop	r0
    1dd4:	0f 90       	pop	r0
    1dd6:	cf 91       	pop	r28
    1dd8:	df 91       	pop	r29
    1dda:	08 95       	ret

00001ddc <DIO_voidGetBitValue>:
u8 DIO_voidGetBitValue(u8 copy_u8PortID , u8 copy_PinID )
{
    1ddc:	df 93       	push	r29
    1dde:	cf 93       	push	r28
    1de0:	00 d0       	rcall	.+0      	; 0x1de2 <DIO_voidGetBitValue+0x6>
    1de2:	00 d0       	rcall	.+0      	; 0x1de4 <DIO_voidGetBitValue+0x8>
    1de4:	0f 92       	push	r0
    1de6:	cd b7       	in	r28, 0x3d	; 61
    1de8:	de b7       	in	r29, 0x3e	; 62
    1dea:	8a 83       	std	Y+2, r24	; 0x02
    1dec:	6b 83       	std	Y+3, r22	; 0x03

		u8 Local_PinVal ;

		switch(copy_u8PortID)
    1dee:	8a 81       	ldd	r24, Y+2	; 0x02
    1df0:	28 2f       	mov	r18, r24
    1df2:	30 e0       	ldi	r19, 0x00	; 0
    1df4:	3d 83       	std	Y+5, r19	; 0x05
    1df6:	2c 83       	std	Y+4, r18	; 0x04
    1df8:	4c 81       	ldd	r20, Y+4	; 0x04
    1dfa:	5d 81       	ldd	r21, Y+5	; 0x05
    1dfc:	41 30       	cpi	r20, 0x01	; 1
    1dfe:	51 05       	cpc	r21, r1
    1e00:	41 f1       	breq	.+80     	; 0x1e52 <DIO_voidGetBitValue+0x76>
    1e02:	8c 81       	ldd	r24, Y+4	; 0x04
    1e04:	9d 81       	ldd	r25, Y+5	; 0x05
    1e06:	82 30       	cpi	r24, 0x02	; 2
    1e08:	91 05       	cpc	r25, r1
    1e0a:	34 f4       	brge	.+12     	; 0x1e18 <DIO_voidGetBitValue+0x3c>
    1e0c:	2c 81       	ldd	r18, Y+4	; 0x04
    1e0e:	3d 81       	ldd	r19, Y+5	; 0x05
    1e10:	21 15       	cp	r18, r1
    1e12:	31 05       	cpc	r19, r1
    1e14:	61 f0       	breq	.+24     	; 0x1e2e <DIO_voidGetBitValue+0x52>
    1e16:	52 c0       	rjmp	.+164    	; 0x1ebc <DIO_voidGetBitValue+0xe0>
    1e18:	4c 81       	ldd	r20, Y+4	; 0x04
    1e1a:	5d 81       	ldd	r21, Y+5	; 0x05
    1e1c:	42 30       	cpi	r20, 0x02	; 2
    1e1e:	51 05       	cpc	r21, r1
    1e20:	51 f1       	breq	.+84     	; 0x1e76 <DIO_voidGetBitValue+0x9a>
    1e22:	8c 81       	ldd	r24, Y+4	; 0x04
    1e24:	9d 81       	ldd	r25, Y+5	; 0x05
    1e26:	83 30       	cpi	r24, 0x03	; 3
    1e28:	91 05       	cpc	r25, r1
    1e2a:	b9 f1       	breq	.+110    	; 0x1e9a <DIO_voidGetBitValue+0xbe>
    1e2c:	47 c0       	rjmp	.+142    	; 0x1ebc <DIO_voidGetBitValue+0xe0>
		{

		case PORTA_ID : Local_PinVal=GET_BIT(PINA_REG,copy_PinID)   ; break ;
    1e2e:	e9 e3       	ldi	r30, 0x39	; 57
    1e30:	f0 e0       	ldi	r31, 0x00	; 0
    1e32:	80 81       	ld	r24, Z
    1e34:	28 2f       	mov	r18, r24
    1e36:	30 e0       	ldi	r19, 0x00	; 0
    1e38:	8b 81       	ldd	r24, Y+3	; 0x03
    1e3a:	88 2f       	mov	r24, r24
    1e3c:	90 e0       	ldi	r25, 0x00	; 0
    1e3e:	a9 01       	movw	r20, r18
    1e40:	02 c0       	rjmp	.+4      	; 0x1e46 <DIO_voidGetBitValue+0x6a>
    1e42:	55 95       	asr	r21
    1e44:	47 95       	ror	r20
    1e46:	8a 95       	dec	r24
    1e48:	e2 f7       	brpl	.-8      	; 0x1e42 <DIO_voidGetBitValue+0x66>
    1e4a:	ca 01       	movw	r24, r20
    1e4c:	81 70       	andi	r24, 0x01	; 1
    1e4e:	89 83       	std	Y+1, r24	; 0x01
    1e50:	35 c0       	rjmp	.+106    	; 0x1ebc <DIO_voidGetBitValue+0xe0>
		case PORTB_ID : Local_PinVal=GET_BIT(PINB_REG,copy_PinID)   ; break ;
    1e52:	e6 e3       	ldi	r30, 0x36	; 54
    1e54:	f0 e0       	ldi	r31, 0x00	; 0
    1e56:	80 81       	ld	r24, Z
    1e58:	28 2f       	mov	r18, r24
    1e5a:	30 e0       	ldi	r19, 0x00	; 0
    1e5c:	8b 81       	ldd	r24, Y+3	; 0x03
    1e5e:	88 2f       	mov	r24, r24
    1e60:	90 e0       	ldi	r25, 0x00	; 0
    1e62:	a9 01       	movw	r20, r18
    1e64:	02 c0       	rjmp	.+4      	; 0x1e6a <DIO_voidGetBitValue+0x8e>
    1e66:	55 95       	asr	r21
    1e68:	47 95       	ror	r20
    1e6a:	8a 95       	dec	r24
    1e6c:	e2 f7       	brpl	.-8      	; 0x1e66 <DIO_voidGetBitValue+0x8a>
    1e6e:	ca 01       	movw	r24, r20
    1e70:	81 70       	andi	r24, 0x01	; 1
    1e72:	89 83       	std	Y+1, r24	; 0x01
    1e74:	23 c0       	rjmp	.+70     	; 0x1ebc <DIO_voidGetBitValue+0xe0>

		case PORTC_ID : Local_PinVal=GET_BIT(PINC_REG,copy_PinID)   ; break ;
    1e76:	e3 e3       	ldi	r30, 0x33	; 51
    1e78:	f0 e0       	ldi	r31, 0x00	; 0
    1e7a:	80 81       	ld	r24, Z
    1e7c:	28 2f       	mov	r18, r24
    1e7e:	30 e0       	ldi	r19, 0x00	; 0
    1e80:	8b 81       	ldd	r24, Y+3	; 0x03
    1e82:	88 2f       	mov	r24, r24
    1e84:	90 e0       	ldi	r25, 0x00	; 0
    1e86:	a9 01       	movw	r20, r18
    1e88:	02 c0       	rjmp	.+4      	; 0x1e8e <DIO_voidGetBitValue+0xb2>
    1e8a:	55 95       	asr	r21
    1e8c:	47 95       	ror	r20
    1e8e:	8a 95       	dec	r24
    1e90:	e2 f7       	brpl	.-8      	; 0x1e8a <DIO_voidGetBitValue+0xae>
    1e92:	ca 01       	movw	r24, r20
    1e94:	81 70       	andi	r24, 0x01	; 1
    1e96:	89 83       	std	Y+1, r24	; 0x01
    1e98:	11 c0       	rjmp	.+34     	; 0x1ebc <DIO_voidGetBitValue+0xe0>

		case PORTD_ID : Local_PinVal=GET_BIT(PIND_REG,copy_PinID)   ; break ;
    1e9a:	e0 e3       	ldi	r30, 0x30	; 48
    1e9c:	f0 e0       	ldi	r31, 0x00	; 0
    1e9e:	80 81       	ld	r24, Z
    1ea0:	28 2f       	mov	r18, r24
    1ea2:	30 e0       	ldi	r19, 0x00	; 0
    1ea4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ea6:	88 2f       	mov	r24, r24
    1ea8:	90 e0       	ldi	r25, 0x00	; 0
    1eaa:	a9 01       	movw	r20, r18
    1eac:	02 c0       	rjmp	.+4      	; 0x1eb2 <DIO_voidGetBitValue+0xd6>
    1eae:	55 95       	asr	r21
    1eb0:	47 95       	ror	r20
    1eb2:	8a 95       	dec	r24
    1eb4:	e2 f7       	brpl	.-8      	; 0x1eae <DIO_voidGetBitValue+0xd2>
    1eb6:	ca 01       	movw	r24, r20
    1eb8:	81 70       	andi	r24, 0x01	; 1
    1eba:	89 83       	std	Y+1, r24	; 0x01

		}

		return Local_PinVal ;
    1ebc:	89 81       	ldd	r24, Y+1	; 0x01

}
    1ebe:	0f 90       	pop	r0
    1ec0:	0f 90       	pop	r0
    1ec2:	0f 90       	pop	r0
    1ec4:	0f 90       	pop	r0
    1ec6:	0f 90       	pop	r0
    1ec8:	cf 91       	pop	r28
    1eca:	df 91       	pop	r29
    1ecc:	08 95       	ret

00001ece <SSD_u8FromU8toSevSeg>:
#include "SSD_Interface.h"
#include "SSD_Private.h"
#include "SSD_Config.h"


static u8 SSD_u8FromU8toSevSeg(u8 copy_u8Num){
    1ece:	df 93       	push	r29
    1ed0:	cf 93       	push	r28
    1ed2:	00 d0       	rcall	.+0      	; 0x1ed4 <SSD_u8FromU8toSevSeg+0x6>
    1ed4:	00 d0       	rcall	.+0      	; 0x1ed6 <SSD_u8FromU8toSevSeg+0x8>
    1ed6:	cd b7       	in	r28, 0x3d	; 61
    1ed8:	de b7       	in	r29, 0x3e	; 62
    1eda:	89 83       	std	Y+1, r24	; 0x01

	switch(copy_u8Num){
    1edc:	89 81       	ldd	r24, Y+1	; 0x01
    1ede:	28 2f       	mov	r18, r24
    1ee0:	30 e0       	ldi	r19, 0x00	; 0
    1ee2:	3c 83       	std	Y+4, r19	; 0x04
    1ee4:	2b 83       	std	Y+3, r18	; 0x03
    1ee6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ee8:	9c 81       	ldd	r25, Y+4	; 0x04
    1eea:	84 30       	cpi	r24, 0x04	; 4
    1eec:	91 05       	cpc	r25, r1
    1eee:	09 f4       	brne	.+2      	; 0x1ef2 <SSD_u8FromU8toSevSeg+0x24>
    1ef0:	4b c0       	rjmp	.+150    	; 0x1f88 <SSD_u8FromU8toSevSeg+0xba>
    1ef2:	2b 81       	ldd	r18, Y+3	; 0x03
    1ef4:	3c 81       	ldd	r19, Y+4	; 0x04
    1ef6:	25 30       	cpi	r18, 0x05	; 5
    1ef8:	31 05       	cpc	r19, r1
    1efa:	d4 f4       	brge	.+52     	; 0x1f30 <SSD_u8FromU8toSevSeg+0x62>
    1efc:	8b 81       	ldd	r24, Y+3	; 0x03
    1efe:	9c 81       	ldd	r25, Y+4	; 0x04
    1f00:	81 30       	cpi	r24, 0x01	; 1
    1f02:	91 05       	cpc	r25, r1
    1f04:	c1 f1       	breq	.+112    	; 0x1f76 <SSD_u8FromU8toSevSeg+0xa8>
    1f06:	2b 81       	ldd	r18, Y+3	; 0x03
    1f08:	3c 81       	ldd	r19, Y+4	; 0x04
    1f0a:	22 30       	cpi	r18, 0x02	; 2
    1f0c:	31 05       	cpc	r19, r1
    1f0e:	2c f4       	brge	.+10     	; 0x1f1a <SSD_u8FromU8toSevSeg+0x4c>
    1f10:	8b 81       	ldd	r24, Y+3	; 0x03
    1f12:	9c 81       	ldd	r25, Y+4	; 0x04
    1f14:	00 97       	sbiw	r24, 0x00	; 0
    1f16:	61 f1       	breq	.+88     	; 0x1f70 <SSD_u8FromU8toSevSeg+0xa2>
    1f18:	49 c0       	rjmp	.+146    	; 0x1fac <SSD_u8FromU8toSevSeg+0xde>
    1f1a:	2b 81       	ldd	r18, Y+3	; 0x03
    1f1c:	3c 81       	ldd	r19, Y+4	; 0x04
    1f1e:	22 30       	cpi	r18, 0x02	; 2
    1f20:	31 05       	cpc	r19, r1
    1f22:	61 f1       	breq	.+88     	; 0x1f7c <SSD_u8FromU8toSevSeg+0xae>
    1f24:	8b 81       	ldd	r24, Y+3	; 0x03
    1f26:	9c 81       	ldd	r25, Y+4	; 0x04
    1f28:	83 30       	cpi	r24, 0x03	; 3
    1f2a:	91 05       	cpc	r25, r1
    1f2c:	51 f1       	breq	.+84     	; 0x1f82 <SSD_u8FromU8toSevSeg+0xb4>
    1f2e:	3e c0       	rjmp	.+124    	; 0x1fac <SSD_u8FromU8toSevSeg+0xde>
    1f30:	2b 81       	ldd	r18, Y+3	; 0x03
    1f32:	3c 81       	ldd	r19, Y+4	; 0x04
    1f34:	27 30       	cpi	r18, 0x07	; 7
    1f36:	31 05       	cpc	r19, r1
    1f38:	81 f1       	breq	.+96     	; 0x1f9a <SSD_u8FromU8toSevSeg+0xcc>
    1f3a:	8b 81       	ldd	r24, Y+3	; 0x03
    1f3c:	9c 81       	ldd	r25, Y+4	; 0x04
    1f3e:	88 30       	cpi	r24, 0x08	; 8
    1f40:	91 05       	cpc	r25, r1
    1f42:	5c f4       	brge	.+22     	; 0x1f5a <SSD_u8FromU8toSevSeg+0x8c>
    1f44:	2b 81       	ldd	r18, Y+3	; 0x03
    1f46:	3c 81       	ldd	r19, Y+4	; 0x04
    1f48:	25 30       	cpi	r18, 0x05	; 5
    1f4a:	31 05       	cpc	r19, r1
    1f4c:	01 f1       	breq	.+64     	; 0x1f8e <SSD_u8FromU8toSevSeg+0xc0>
    1f4e:	8b 81       	ldd	r24, Y+3	; 0x03
    1f50:	9c 81       	ldd	r25, Y+4	; 0x04
    1f52:	86 30       	cpi	r24, 0x06	; 6
    1f54:	91 05       	cpc	r25, r1
    1f56:	f1 f0       	breq	.+60     	; 0x1f94 <SSD_u8FromU8toSevSeg+0xc6>
    1f58:	29 c0       	rjmp	.+82     	; 0x1fac <SSD_u8FromU8toSevSeg+0xde>
    1f5a:	2b 81       	ldd	r18, Y+3	; 0x03
    1f5c:	3c 81       	ldd	r19, Y+4	; 0x04
    1f5e:	28 30       	cpi	r18, 0x08	; 8
    1f60:	31 05       	cpc	r19, r1
    1f62:	f1 f0       	breq	.+60     	; 0x1fa0 <SSD_u8FromU8toSevSeg+0xd2>
    1f64:	8b 81       	ldd	r24, Y+3	; 0x03
    1f66:	9c 81       	ldd	r25, Y+4	; 0x04
    1f68:	89 30       	cpi	r24, 0x09	; 9
    1f6a:	91 05       	cpc	r25, r1
    1f6c:	e1 f0       	breq	.+56     	; 0x1fa6 <SSD_u8FromU8toSevSeg+0xd8>
    1f6e:	1e c0       	rjmp	.+60     	; 0x1fac <SSD_u8FromU8toSevSeg+0xde>
		case 0:return SSD_NUM_0; break;
    1f70:	9e e7       	ldi	r25, 0x7E	; 126
    1f72:	9a 83       	std	Y+2, r25	; 0x02
    1f74:	1d c0       	rjmp	.+58     	; 0x1fb0 <SSD_u8FromU8toSevSeg+0xe2>
		case 1:return SSD_NUM_1; break;
    1f76:	2c e0       	ldi	r18, 0x0C	; 12
    1f78:	2a 83       	std	Y+2, r18	; 0x02
    1f7a:	1a c0       	rjmp	.+52     	; 0x1fb0 <SSD_u8FromU8toSevSeg+0xe2>
		case 2:return SSD_NUM_2; break;
    1f7c:	36 eb       	ldi	r19, 0xB6	; 182
    1f7e:	3a 83       	std	Y+2, r19	; 0x02
    1f80:	17 c0       	rjmp	.+46     	; 0x1fb0 <SSD_u8FromU8toSevSeg+0xe2>
		case 3:return SSD_NUM_3; break;
    1f82:	8e e9       	ldi	r24, 0x9E	; 158
    1f84:	8a 83       	std	Y+2, r24	; 0x02
    1f86:	14 c0       	rjmp	.+40     	; 0x1fb0 <SSD_u8FromU8toSevSeg+0xe2>
		case 4:return SSD_NUM_4; break;
    1f88:	9c ec       	ldi	r25, 0xCC	; 204
    1f8a:	9a 83       	std	Y+2, r25	; 0x02
    1f8c:	11 c0       	rjmp	.+34     	; 0x1fb0 <SSD_u8FromU8toSevSeg+0xe2>
		case 5:return SSD_NUM_5; break;
    1f8e:	2a ed       	ldi	r18, 0xDA	; 218
    1f90:	2a 83       	std	Y+2, r18	; 0x02
    1f92:	0e c0       	rjmp	.+28     	; 0x1fb0 <SSD_u8FromU8toSevSeg+0xe2>
		case 6:return SSD_NUM_6; break;
    1f94:	3a ef       	ldi	r19, 0xFA	; 250
    1f96:	3a 83       	std	Y+2, r19	; 0x02
    1f98:	0b c0       	rjmp	.+22     	; 0x1fb0 <SSD_u8FromU8toSevSeg+0xe2>
		case 7:return SSD_NUM_7; break;
    1f9a:	8e e0       	ldi	r24, 0x0E	; 14
    1f9c:	8a 83       	std	Y+2, r24	; 0x02
    1f9e:	08 c0       	rjmp	.+16     	; 0x1fb0 <SSD_u8FromU8toSevSeg+0xe2>
		case 8:return SSD_NUM_8; break;
    1fa0:	9f ef       	ldi	r25, 0xFF	; 255
    1fa2:	9a 83       	std	Y+2, r25	; 0x02
    1fa4:	05 c0       	rjmp	.+10     	; 0x1fb0 <SSD_u8FromU8toSevSeg+0xe2>
		case 9:return SSD_NUM_9; break;
    1fa6:	2e ed       	ldi	r18, 0xDE	; 222
    1fa8:	2a 83       	std	Y+2, r18	; 0x02
    1faa:	02 c0       	rjmp	.+4      	; 0x1fb0 <SSD_u8FromU8toSevSeg+0xe2>
		default:return SSD_NUM_0; break;
    1fac:	3e e7       	ldi	r19, 0x7E	; 126
    1fae:	3a 83       	std	Y+2, r19	; 0x02
    1fb0:	8a 81       	ldd	r24, Y+2	; 0x02
	}

}
    1fb2:	0f 90       	pop	r0
    1fb4:	0f 90       	pop	r0
    1fb6:	0f 90       	pop	r0
    1fb8:	0f 90       	pop	r0
    1fba:	cf 91       	pop	r28
    1fbc:	df 91       	pop	r29
    1fbe:	08 95       	ret

00001fc0 <SSD_voidInit>:
void SSD_voidInit(){
    1fc0:	df 93       	push	r29
    1fc2:	cf 93       	push	r28
    1fc4:	cd b7       	in	r28, 0x3d	; 61
    1fc6:	de b7       	in	r29, 0x3e	; 62

	/* Output Number Ports  */
	DIO_voidSetPortDirection(SSD_NUM_PORT_1, PORT_OUTPUT);
    1fc8:	80 e0       	ldi	r24, 0x00	; 0
    1fca:	6f ef       	ldi	r22, 0xFF	; 255
    1fcc:	0e 94 ef 0b 	call	0x17de	; 0x17de <DIO_voidSetPortDirection>
//	DIO_voidSetPortDirection(SSD_NUM_PORT_2, PORT_OUTPUT);

	DIO_voidSetPortValue(SSD_NUM_PORT_1,PORT_HIGH);
    1fd0:	80 e0       	ldi	r24, 0x00	; 0
    1fd2:	6f ef       	ldi	r22, 0xFF	; 255
    1fd4:	0e 94 30 0c 	call	0x1860	; 0x1860 <DIO_voidSetPortValue>
//	DIO_voidSetPinDirection(SSD_COM_PORT, SSD_COM2_PIN,PIN_OUTPUT);

	/* Enable SSD1 and SSD2 */
//	DIO_voidSetPinValue(SSD_COM_PORT,  SSD_COM1_PIN,PIN_HIGH);
//	DIO_voidSetPinValue(SSD_COM_PORT, SSD_COM2_PIN,PIN_HIGH);
}
    1fd8:	cf 91       	pop	r28
    1fda:	df 91       	pop	r29
    1fdc:	08 95       	ret

00001fde <SSD_voidPrintNum_1>:

void SSD_voidPrintNum_1(u8 copy_u8Num){
    1fde:	df 93       	push	r29
    1fe0:	cf 93       	push	r28
    1fe2:	0f 92       	push	r0
    1fe4:	cd b7       	in	r28, 0x3d	; 61
    1fe6:	de b7       	in	r29, 0x3e	; 62
    1fe8:	89 83       	std	Y+1, r24	; 0x01
	DIO_voidSetPortValue(SSD_NUM_PORT_1,  SSD_u8FromU8toSevSeg(copy_u8Num));
    1fea:	89 81       	ldd	r24, Y+1	; 0x01
    1fec:	0e 94 67 0f 	call	0x1ece	; 0x1ece <SSD_u8FromU8toSevSeg>
    1ff0:	98 2f       	mov	r25, r24
    1ff2:	80 e0       	ldi	r24, 0x00	; 0
    1ff4:	69 2f       	mov	r22, r25
    1ff6:	0e 94 30 0c 	call	0x1860	; 0x1860 <DIO_voidSetPortValue>
}
    1ffa:	0f 90       	pop	r0
    1ffc:	cf 91       	pop	r28
    1ffe:	df 91       	pop	r29
    2000:	08 95       	ret

00002002 <writebittosend>:

#include "LCD_configure.h"
#include "util/delay.h"

void writebittosend(u8 byte)
{
    2002:	df 93       	push	r29
    2004:	cf 93       	push	r28
    2006:	cd b7       	in	r28, 0x3d	; 61
    2008:	de b7       	in	r29, 0x3e	; 62
    200a:	e9 97       	sbiw	r28, 0x39	; 57
    200c:	0f b6       	in	r0, 0x3f	; 63
    200e:	f8 94       	cli
    2010:	de bf       	out	0x3e, r29	; 62
    2012:	0f be       	out	0x3f, r0	; 63
    2014:	cd bf       	out	0x3d, r28	; 61
    2016:	89 af       	std	Y+57, r24	; 0x39
	DIO_voidSetPinValue( EN_PORT, EN_PIN, PIN_LOW);
    2018:	83 e0       	ldi	r24, 0x03	; 3
    201a:	61 e0       	ldi	r22, 0x01	; 1
    201c:	40 e0       	ldi	r20, 0x00	; 0
    201e:	0e 94 71 0d 	call	0x1ae2	; 0x1ae2 <DIO_voidSetPinValue>

	DIO_voidSetPinValue(D7_PORT, D7_PIN, (byte>>7) & 1 );
    2022:	89 ad       	ldd	r24, Y+57	; 0x39
    2024:	98 2f       	mov	r25, r24
    2026:	99 1f       	adc	r25, r25
    2028:	99 27       	eor	r25, r25
    202a:	99 1f       	adc	r25, r25
    202c:	83 e0       	ldi	r24, 0x03	; 3
    202e:	67 e0       	ldi	r22, 0x07	; 7
    2030:	49 2f       	mov	r20, r25
    2032:	0e 94 71 0d 	call	0x1ae2	; 0x1ae2 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(D6_PORT, D6_PIN, (byte>>6) & 1 );
    2036:	89 ad       	ldd	r24, Y+57	; 0x39
    2038:	82 95       	swap	r24
    203a:	86 95       	lsr	r24
    203c:	86 95       	lsr	r24
    203e:	83 70       	andi	r24, 0x03	; 3
    2040:	98 2f       	mov	r25, r24
    2042:	91 70       	andi	r25, 0x01	; 1
    2044:	83 e0       	ldi	r24, 0x03	; 3
    2046:	66 e0       	ldi	r22, 0x06	; 6
    2048:	49 2f       	mov	r20, r25
    204a:	0e 94 71 0d 	call	0x1ae2	; 0x1ae2 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(D5_PORT, D5_PIN, (byte>>5) & 1 );
    204e:	89 ad       	ldd	r24, Y+57	; 0x39
    2050:	82 95       	swap	r24
    2052:	86 95       	lsr	r24
    2054:	87 70       	andi	r24, 0x07	; 7
    2056:	98 2f       	mov	r25, r24
    2058:	91 70       	andi	r25, 0x01	; 1
    205a:	83 e0       	ldi	r24, 0x03	; 3
    205c:	65 e0       	ldi	r22, 0x05	; 5
    205e:	49 2f       	mov	r20, r25
    2060:	0e 94 71 0d 	call	0x1ae2	; 0x1ae2 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(D4_PORT, D4_PIN, (byte>>4) & 1 );
    2064:	89 ad       	ldd	r24, Y+57	; 0x39
    2066:	82 95       	swap	r24
    2068:	8f 70       	andi	r24, 0x0F	; 15
    206a:	98 2f       	mov	r25, r24
    206c:	91 70       	andi	r25, 0x01	; 1
    206e:	83 e0       	ldi	r24, 0x03	; 3
    2070:	64 e0       	ldi	r22, 0x04	; 4
    2072:	49 2f       	mov	r20, r25
    2074:	0e 94 71 0d 	call	0x1ae2	; 0x1ae2 <DIO_voidSetPinValue>

	DIO_voidSetPinValue( EN_PORT, EN_PIN, PIN_HIGH);
    2078:	83 e0       	ldi	r24, 0x03	; 3
    207a:	61 e0       	ldi	r22, 0x01	; 1
    207c:	41 e0       	ldi	r20, 0x01	; 1
    207e:	0e 94 71 0d 	call	0x1ae2	; 0x1ae2 <DIO_voidSetPinValue>
    2082:	80 e0       	ldi	r24, 0x00	; 0
    2084:	90 e0       	ldi	r25, 0x00	; 0
    2086:	a0 e8       	ldi	r26, 0x80	; 128
    2088:	bf e3       	ldi	r27, 0x3F	; 63
    208a:	8d ab       	std	Y+53, r24	; 0x35
    208c:	9e ab       	std	Y+54, r25	; 0x36
    208e:	af ab       	std	Y+55, r26	; 0x37
    2090:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2092:	6d a9       	ldd	r22, Y+53	; 0x35
    2094:	7e a9       	ldd	r23, Y+54	; 0x36
    2096:	8f a9       	ldd	r24, Y+55	; 0x37
    2098:	98 ad       	ldd	r25, Y+56	; 0x38
    209a:	20 e0       	ldi	r18, 0x00	; 0
    209c:	30 e0       	ldi	r19, 0x00	; 0
    209e:	4a e7       	ldi	r20, 0x7A	; 122
    20a0:	55 e4       	ldi	r21, 0x45	; 69
    20a2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    20a6:	dc 01       	movw	r26, r24
    20a8:	cb 01       	movw	r24, r22
    20aa:	89 ab       	std	Y+49, r24	; 0x31
    20ac:	9a ab       	std	Y+50, r25	; 0x32
    20ae:	ab ab       	std	Y+51, r26	; 0x33
    20b0:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    20b2:	69 a9       	ldd	r22, Y+49	; 0x31
    20b4:	7a a9       	ldd	r23, Y+50	; 0x32
    20b6:	8b a9       	ldd	r24, Y+51	; 0x33
    20b8:	9c a9       	ldd	r25, Y+52	; 0x34
    20ba:	20 e0       	ldi	r18, 0x00	; 0
    20bc:	30 e0       	ldi	r19, 0x00	; 0
    20be:	40 e8       	ldi	r20, 0x80	; 128
    20c0:	5f e3       	ldi	r21, 0x3F	; 63
    20c2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    20c6:	88 23       	and	r24, r24
    20c8:	2c f4       	brge	.+10     	; 0x20d4 <writebittosend+0xd2>
		__ticks = 1;
    20ca:	81 e0       	ldi	r24, 0x01	; 1
    20cc:	90 e0       	ldi	r25, 0x00	; 0
    20ce:	98 ab       	std	Y+48, r25	; 0x30
    20d0:	8f a7       	std	Y+47, r24	; 0x2f
    20d2:	3f c0       	rjmp	.+126    	; 0x2152 <writebittosend+0x150>
	else if (__tmp > 65535)
    20d4:	69 a9       	ldd	r22, Y+49	; 0x31
    20d6:	7a a9       	ldd	r23, Y+50	; 0x32
    20d8:	8b a9       	ldd	r24, Y+51	; 0x33
    20da:	9c a9       	ldd	r25, Y+52	; 0x34
    20dc:	20 e0       	ldi	r18, 0x00	; 0
    20de:	3f ef       	ldi	r19, 0xFF	; 255
    20e0:	4f e7       	ldi	r20, 0x7F	; 127
    20e2:	57 e4       	ldi	r21, 0x47	; 71
    20e4:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    20e8:	18 16       	cp	r1, r24
    20ea:	4c f5       	brge	.+82     	; 0x213e <writebittosend+0x13c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    20ec:	6d a9       	ldd	r22, Y+53	; 0x35
    20ee:	7e a9       	ldd	r23, Y+54	; 0x36
    20f0:	8f a9       	ldd	r24, Y+55	; 0x37
    20f2:	98 ad       	ldd	r25, Y+56	; 0x38
    20f4:	20 e0       	ldi	r18, 0x00	; 0
    20f6:	30 e0       	ldi	r19, 0x00	; 0
    20f8:	40 e2       	ldi	r20, 0x20	; 32
    20fa:	51 e4       	ldi	r21, 0x41	; 65
    20fc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2100:	dc 01       	movw	r26, r24
    2102:	cb 01       	movw	r24, r22
    2104:	bc 01       	movw	r22, r24
    2106:	cd 01       	movw	r24, r26
    2108:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    210c:	dc 01       	movw	r26, r24
    210e:	cb 01       	movw	r24, r22
    2110:	98 ab       	std	Y+48, r25	; 0x30
    2112:	8f a7       	std	Y+47, r24	; 0x2f
    2114:	0f c0       	rjmp	.+30     	; 0x2134 <writebittosend+0x132>
    2116:	80 e9       	ldi	r24, 0x90	; 144
    2118:	91 e0       	ldi	r25, 0x01	; 1
    211a:	9e a7       	std	Y+46, r25	; 0x2e
    211c:	8d a7       	std	Y+45, r24	; 0x2d
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    211e:	8d a5       	ldd	r24, Y+45	; 0x2d
    2120:	9e a5       	ldd	r25, Y+46	; 0x2e
    2122:	01 97       	sbiw	r24, 0x01	; 1
    2124:	f1 f7       	brne	.-4      	; 0x2122 <writebittosend+0x120>
    2126:	9e a7       	std	Y+46, r25	; 0x2e
    2128:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    212a:	8f a5       	ldd	r24, Y+47	; 0x2f
    212c:	98 a9       	ldd	r25, Y+48	; 0x30
    212e:	01 97       	sbiw	r24, 0x01	; 1
    2130:	98 ab       	std	Y+48, r25	; 0x30
    2132:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2134:	8f a5       	ldd	r24, Y+47	; 0x2f
    2136:	98 a9       	ldd	r25, Y+48	; 0x30
    2138:	00 97       	sbiw	r24, 0x00	; 0
    213a:	69 f7       	brne	.-38     	; 0x2116 <writebittosend+0x114>
    213c:	14 c0       	rjmp	.+40     	; 0x2166 <writebittosend+0x164>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    213e:	69 a9       	ldd	r22, Y+49	; 0x31
    2140:	7a a9       	ldd	r23, Y+50	; 0x32
    2142:	8b a9       	ldd	r24, Y+51	; 0x33
    2144:	9c a9       	ldd	r25, Y+52	; 0x34
    2146:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    214a:	dc 01       	movw	r26, r24
    214c:	cb 01       	movw	r24, r22
    214e:	98 ab       	std	Y+48, r25	; 0x30
    2150:	8f a7       	std	Y+47, r24	; 0x2f
    2152:	8f a5       	ldd	r24, Y+47	; 0x2f
    2154:	98 a9       	ldd	r25, Y+48	; 0x30
    2156:	9c a7       	std	Y+44, r25	; 0x2c
    2158:	8b a7       	std	Y+43, r24	; 0x2b
    215a:	8b a5       	ldd	r24, Y+43	; 0x2b
    215c:	9c a5       	ldd	r25, Y+44	; 0x2c
    215e:	01 97       	sbiw	r24, 0x01	; 1
    2160:	f1 f7       	brne	.-4      	; 0x215e <writebittosend+0x15c>
    2162:	9c a7       	std	Y+44, r25	; 0x2c
    2164:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(1);
	DIO_voidSetPinValue( EN_PORT, EN_PIN, PIN_LOW);
    2166:	83 e0       	ldi	r24, 0x03	; 3
    2168:	61 e0       	ldi	r22, 0x01	; 1
    216a:	40 e0       	ldi	r20, 0x00	; 0
    216c:	0e 94 71 0d 	call	0x1ae2	; 0x1ae2 <DIO_voidSetPinValue>
    2170:	80 e0       	ldi	r24, 0x00	; 0
    2172:	90 e0       	ldi	r25, 0x00	; 0
    2174:	a0 ef       	ldi	r26, 0xF0	; 240
    2176:	b1 e4       	ldi	r27, 0x41	; 65
    2178:	8f a3       	std	Y+39, r24	; 0x27
    217a:	98 a7       	std	Y+40, r25	; 0x28
    217c:	a9 a7       	std	Y+41, r26	; 0x29
    217e:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2180:	6f a1       	ldd	r22, Y+39	; 0x27
    2182:	78 a5       	ldd	r23, Y+40	; 0x28
    2184:	89 a5       	ldd	r24, Y+41	; 0x29
    2186:	9a a5       	ldd	r25, Y+42	; 0x2a
    2188:	20 e0       	ldi	r18, 0x00	; 0
    218a:	30 e0       	ldi	r19, 0x00	; 0
    218c:	4a e7       	ldi	r20, 0x7A	; 122
    218e:	55 e4       	ldi	r21, 0x45	; 69
    2190:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2194:	dc 01       	movw	r26, r24
    2196:	cb 01       	movw	r24, r22
    2198:	8b a3       	std	Y+35, r24	; 0x23
    219a:	9c a3       	std	Y+36, r25	; 0x24
    219c:	ad a3       	std	Y+37, r26	; 0x25
    219e:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    21a0:	6b a1       	ldd	r22, Y+35	; 0x23
    21a2:	7c a1       	ldd	r23, Y+36	; 0x24
    21a4:	8d a1       	ldd	r24, Y+37	; 0x25
    21a6:	9e a1       	ldd	r25, Y+38	; 0x26
    21a8:	20 e0       	ldi	r18, 0x00	; 0
    21aa:	30 e0       	ldi	r19, 0x00	; 0
    21ac:	40 e8       	ldi	r20, 0x80	; 128
    21ae:	5f e3       	ldi	r21, 0x3F	; 63
    21b0:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    21b4:	88 23       	and	r24, r24
    21b6:	2c f4       	brge	.+10     	; 0x21c2 <writebittosend+0x1c0>
		__ticks = 1;
    21b8:	81 e0       	ldi	r24, 0x01	; 1
    21ba:	90 e0       	ldi	r25, 0x00	; 0
    21bc:	9a a3       	std	Y+34, r25	; 0x22
    21be:	89 a3       	std	Y+33, r24	; 0x21
    21c0:	3f c0       	rjmp	.+126    	; 0x2240 <writebittosend+0x23e>
	else if (__tmp > 65535)
    21c2:	6b a1       	ldd	r22, Y+35	; 0x23
    21c4:	7c a1       	ldd	r23, Y+36	; 0x24
    21c6:	8d a1       	ldd	r24, Y+37	; 0x25
    21c8:	9e a1       	ldd	r25, Y+38	; 0x26
    21ca:	20 e0       	ldi	r18, 0x00	; 0
    21cc:	3f ef       	ldi	r19, 0xFF	; 255
    21ce:	4f e7       	ldi	r20, 0x7F	; 127
    21d0:	57 e4       	ldi	r21, 0x47	; 71
    21d2:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    21d6:	18 16       	cp	r1, r24
    21d8:	4c f5       	brge	.+82     	; 0x222c <writebittosend+0x22a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    21da:	6f a1       	ldd	r22, Y+39	; 0x27
    21dc:	78 a5       	ldd	r23, Y+40	; 0x28
    21de:	89 a5       	ldd	r24, Y+41	; 0x29
    21e0:	9a a5       	ldd	r25, Y+42	; 0x2a
    21e2:	20 e0       	ldi	r18, 0x00	; 0
    21e4:	30 e0       	ldi	r19, 0x00	; 0
    21e6:	40 e2       	ldi	r20, 0x20	; 32
    21e8:	51 e4       	ldi	r21, 0x41	; 65
    21ea:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    21ee:	dc 01       	movw	r26, r24
    21f0:	cb 01       	movw	r24, r22
    21f2:	bc 01       	movw	r22, r24
    21f4:	cd 01       	movw	r24, r26
    21f6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    21fa:	dc 01       	movw	r26, r24
    21fc:	cb 01       	movw	r24, r22
    21fe:	9a a3       	std	Y+34, r25	; 0x22
    2200:	89 a3       	std	Y+33, r24	; 0x21
    2202:	0f c0       	rjmp	.+30     	; 0x2222 <writebittosend+0x220>
    2204:	80 e9       	ldi	r24, 0x90	; 144
    2206:	91 e0       	ldi	r25, 0x01	; 1
    2208:	98 a3       	std	Y+32, r25	; 0x20
    220a:	8f 8f       	std	Y+31, r24	; 0x1f
    220c:	8f 8d       	ldd	r24, Y+31	; 0x1f
    220e:	98 a1       	ldd	r25, Y+32	; 0x20
    2210:	01 97       	sbiw	r24, 0x01	; 1
    2212:	f1 f7       	brne	.-4      	; 0x2210 <writebittosend+0x20e>
    2214:	98 a3       	std	Y+32, r25	; 0x20
    2216:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2218:	89 a1       	ldd	r24, Y+33	; 0x21
    221a:	9a a1       	ldd	r25, Y+34	; 0x22
    221c:	01 97       	sbiw	r24, 0x01	; 1
    221e:	9a a3       	std	Y+34, r25	; 0x22
    2220:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2222:	89 a1       	ldd	r24, Y+33	; 0x21
    2224:	9a a1       	ldd	r25, Y+34	; 0x22
    2226:	00 97       	sbiw	r24, 0x00	; 0
    2228:	69 f7       	brne	.-38     	; 0x2204 <writebittosend+0x202>
    222a:	14 c0       	rjmp	.+40     	; 0x2254 <writebittosend+0x252>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    222c:	6b a1       	ldd	r22, Y+35	; 0x23
    222e:	7c a1       	ldd	r23, Y+36	; 0x24
    2230:	8d a1       	ldd	r24, Y+37	; 0x25
    2232:	9e a1       	ldd	r25, Y+38	; 0x26
    2234:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2238:	dc 01       	movw	r26, r24
    223a:	cb 01       	movw	r24, r22
    223c:	9a a3       	std	Y+34, r25	; 0x22
    223e:	89 a3       	std	Y+33, r24	; 0x21
    2240:	89 a1       	ldd	r24, Y+33	; 0x21
    2242:	9a a1       	ldd	r25, Y+34	; 0x22
    2244:	9e 8f       	std	Y+30, r25	; 0x1e
    2246:	8d 8f       	std	Y+29, r24	; 0x1d
    2248:	8d 8d       	ldd	r24, Y+29	; 0x1d
    224a:	9e 8d       	ldd	r25, Y+30	; 0x1e
    224c:	01 97       	sbiw	r24, 0x01	; 1
    224e:	f1 f7       	brne	.-4      	; 0x224c <writebittosend+0x24a>
    2250:	9e 8f       	std	Y+30, r25	; 0x1e
    2252:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(30);

	DIO_voidSetPinValue(D7_PORT, D7_PIN, (byte>>3) & 1 );
    2254:	89 ad       	ldd	r24, Y+57	; 0x39
    2256:	86 95       	lsr	r24
    2258:	86 95       	lsr	r24
    225a:	86 95       	lsr	r24
    225c:	98 2f       	mov	r25, r24
    225e:	91 70       	andi	r25, 0x01	; 1
    2260:	83 e0       	ldi	r24, 0x03	; 3
    2262:	67 e0       	ldi	r22, 0x07	; 7
    2264:	49 2f       	mov	r20, r25
    2266:	0e 94 71 0d 	call	0x1ae2	; 0x1ae2 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(D6_PORT, D6_PIN, (byte>>2) & 1 );
    226a:	89 ad       	ldd	r24, Y+57	; 0x39
    226c:	86 95       	lsr	r24
    226e:	86 95       	lsr	r24
    2270:	98 2f       	mov	r25, r24
    2272:	91 70       	andi	r25, 0x01	; 1
    2274:	83 e0       	ldi	r24, 0x03	; 3
    2276:	66 e0       	ldi	r22, 0x06	; 6
    2278:	49 2f       	mov	r20, r25
    227a:	0e 94 71 0d 	call	0x1ae2	; 0x1ae2 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(D5_PORT, D5_PIN, (byte>>1) & 1 );
    227e:	89 ad       	ldd	r24, Y+57	; 0x39
    2280:	86 95       	lsr	r24
    2282:	98 2f       	mov	r25, r24
    2284:	91 70       	andi	r25, 0x01	; 1
    2286:	83 e0       	ldi	r24, 0x03	; 3
    2288:	65 e0       	ldi	r22, 0x05	; 5
    228a:	49 2f       	mov	r20, r25
    228c:	0e 94 71 0d 	call	0x1ae2	; 0x1ae2 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(D4_PORT, D4_PIN, (byte>>0) & 1 );
    2290:	89 ad       	ldd	r24, Y+57	; 0x39
    2292:	98 2f       	mov	r25, r24
    2294:	91 70       	andi	r25, 0x01	; 1
    2296:	83 e0       	ldi	r24, 0x03	; 3
    2298:	64 e0       	ldi	r22, 0x04	; 4
    229a:	49 2f       	mov	r20, r25
    229c:	0e 94 71 0d 	call	0x1ae2	; 0x1ae2 <DIO_voidSetPinValue>

	DIO_voidSetPinValue( EN_PORT, EN_PIN, PIN_HIGH);
    22a0:	83 e0       	ldi	r24, 0x03	; 3
    22a2:	61 e0       	ldi	r22, 0x01	; 1
    22a4:	41 e0       	ldi	r20, 0x01	; 1
    22a6:	0e 94 71 0d 	call	0x1ae2	; 0x1ae2 <DIO_voidSetPinValue>
    22aa:	80 e0       	ldi	r24, 0x00	; 0
    22ac:	90 e0       	ldi	r25, 0x00	; 0
    22ae:	a0 e8       	ldi	r26, 0x80	; 128
    22b0:	bf e3       	ldi	r27, 0x3F	; 63
    22b2:	89 8f       	std	Y+25, r24	; 0x19
    22b4:	9a 8f       	std	Y+26, r25	; 0x1a
    22b6:	ab 8f       	std	Y+27, r26	; 0x1b
    22b8:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    22ba:	69 8d       	ldd	r22, Y+25	; 0x19
    22bc:	7a 8d       	ldd	r23, Y+26	; 0x1a
    22be:	8b 8d       	ldd	r24, Y+27	; 0x1b
    22c0:	9c 8d       	ldd	r25, Y+28	; 0x1c
    22c2:	20 e0       	ldi	r18, 0x00	; 0
    22c4:	30 e0       	ldi	r19, 0x00	; 0
    22c6:	4a e7       	ldi	r20, 0x7A	; 122
    22c8:	55 e4       	ldi	r21, 0x45	; 69
    22ca:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    22ce:	dc 01       	movw	r26, r24
    22d0:	cb 01       	movw	r24, r22
    22d2:	8d 8b       	std	Y+21, r24	; 0x15
    22d4:	9e 8b       	std	Y+22, r25	; 0x16
    22d6:	af 8b       	std	Y+23, r26	; 0x17
    22d8:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    22da:	6d 89       	ldd	r22, Y+21	; 0x15
    22dc:	7e 89       	ldd	r23, Y+22	; 0x16
    22de:	8f 89       	ldd	r24, Y+23	; 0x17
    22e0:	98 8d       	ldd	r25, Y+24	; 0x18
    22e2:	20 e0       	ldi	r18, 0x00	; 0
    22e4:	30 e0       	ldi	r19, 0x00	; 0
    22e6:	40 e8       	ldi	r20, 0x80	; 128
    22e8:	5f e3       	ldi	r21, 0x3F	; 63
    22ea:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    22ee:	88 23       	and	r24, r24
    22f0:	2c f4       	brge	.+10     	; 0x22fc <writebittosend+0x2fa>
		__ticks = 1;
    22f2:	81 e0       	ldi	r24, 0x01	; 1
    22f4:	90 e0       	ldi	r25, 0x00	; 0
    22f6:	9c 8b       	std	Y+20, r25	; 0x14
    22f8:	8b 8b       	std	Y+19, r24	; 0x13
    22fa:	3f c0       	rjmp	.+126    	; 0x237a <writebittosend+0x378>
	else if (__tmp > 65535)
    22fc:	6d 89       	ldd	r22, Y+21	; 0x15
    22fe:	7e 89       	ldd	r23, Y+22	; 0x16
    2300:	8f 89       	ldd	r24, Y+23	; 0x17
    2302:	98 8d       	ldd	r25, Y+24	; 0x18
    2304:	20 e0       	ldi	r18, 0x00	; 0
    2306:	3f ef       	ldi	r19, 0xFF	; 255
    2308:	4f e7       	ldi	r20, 0x7F	; 127
    230a:	57 e4       	ldi	r21, 0x47	; 71
    230c:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2310:	18 16       	cp	r1, r24
    2312:	4c f5       	brge	.+82     	; 0x2366 <writebittosend+0x364>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2314:	69 8d       	ldd	r22, Y+25	; 0x19
    2316:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2318:	8b 8d       	ldd	r24, Y+27	; 0x1b
    231a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    231c:	20 e0       	ldi	r18, 0x00	; 0
    231e:	30 e0       	ldi	r19, 0x00	; 0
    2320:	40 e2       	ldi	r20, 0x20	; 32
    2322:	51 e4       	ldi	r21, 0x41	; 65
    2324:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2328:	dc 01       	movw	r26, r24
    232a:	cb 01       	movw	r24, r22
    232c:	bc 01       	movw	r22, r24
    232e:	cd 01       	movw	r24, r26
    2330:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2334:	dc 01       	movw	r26, r24
    2336:	cb 01       	movw	r24, r22
    2338:	9c 8b       	std	Y+20, r25	; 0x14
    233a:	8b 8b       	std	Y+19, r24	; 0x13
    233c:	0f c0       	rjmp	.+30     	; 0x235c <writebittosend+0x35a>
    233e:	80 e9       	ldi	r24, 0x90	; 144
    2340:	91 e0       	ldi	r25, 0x01	; 1
    2342:	9a 8b       	std	Y+18, r25	; 0x12
    2344:	89 8b       	std	Y+17, r24	; 0x11
    2346:	89 89       	ldd	r24, Y+17	; 0x11
    2348:	9a 89       	ldd	r25, Y+18	; 0x12
    234a:	01 97       	sbiw	r24, 0x01	; 1
    234c:	f1 f7       	brne	.-4      	; 0x234a <writebittosend+0x348>
    234e:	9a 8b       	std	Y+18, r25	; 0x12
    2350:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2352:	8b 89       	ldd	r24, Y+19	; 0x13
    2354:	9c 89       	ldd	r25, Y+20	; 0x14
    2356:	01 97       	sbiw	r24, 0x01	; 1
    2358:	9c 8b       	std	Y+20, r25	; 0x14
    235a:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    235c:	8b 89       	ldd	r24, Y+19	; 0x13
    235e:	9c 89       	ldd	r25, Y+20	; 0x14
    2360:	00 97       	sbiw	r24, 0x00	; 0
    2362:	69 f7       	brne	.-38     	; 0x233e <writebittosend+0x33c>
    2364:	14 c0       	rjmp	.+40     	; 0x238e <writebittosend+0x38c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2366:	6d 89       	ldd	r22, Y+21	; 0x15
    2368:	7e 89       	ldd	r23, Y+22	; 0x16
    236a:	8f 89       	ldd	r24, Y+23	; 0x17
    236c:	98 8d       	ldd	r25, Y+24	; 0x18
    236e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2372:	dc 01       	movw	r26, r24
    2374:	cb 01       	movw	r24, r22
    2376:	9c 8b       	std	Y+20, r25	; 0x14
    2378:	8b 8b       	std	Y+19, r24	; 0x13
    237a:	8b 89       	ldd	r24, Y+19	; 0x13
    237c:	9c 89       	ldd	r25, Y+20	; 0x14
    237e:	98 8b       	std	Y+16, r25	; 0x10
    2380:	8f 87       	std	Y+15, r24	; 0x0f
    2382:	8f 85       	ldd	r24, Y+15	; 0x0f
    2384:	98 89       	ldd	r25, Y+16	; 0x10
    2386:	01 97       	sbiw	r24, 0x01	; 1
    2388:	f1 f7       	brne	.-4      	; 0x2386 <writebittosend+0x384>
    238a:	98 8b       	std	Y+16, r25	; 0x10
    238c:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1);
	DIO_voidSetPinValue( EN_PORT, EN_PIN, PIN_LOW);
    238e:	83 e0       	ldi	r24, 0x03	; 3
    2390:	61 e0       	ldi	r22, 0x01	; 1
    2392:	40 e0       	ldi	r20, 0x00	; 0
    2394:	0e 94 71 0d 	call	0x1ae2	; 0x1ae2 <DIO_voidSetPinValue>
    2398:	80 e0       	ldi	r24, 0x00	; 0
    239a:	90 e0       	ldi	r25, 0x00	; 0
    239c:	a0 ef       	ldi	r26, 0xF0	; 240
    239e:	b1 e4       	ldi	r27, 0x41	; 65
    23a0:	8b 87       	std	Y+11, r24	; 0x0b
    23a2:	9c 87       	std	Y+12, r25	; 0x0c
    23a4:	ad 87       	std	Y+13, r26	; 0x0d
    23a6:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    23a8:	6b 85       	ldd	r22, Y+11	; 0x0b
    23aa:	7c 85       	ldd	r23, Y+12	; 0x0c
    23ac:	8d 85       	ldd	r24, Y+13	; 0x0d
    23ae:	9e 85       	ldd	r25, Y+14	; 0x0e
    23b0:	20 e0       	ldi	r18, 0x00	; 0
    23b2:	30 e0       	ldi	r19, 0x00	; 0
    23b4:	4a e7       	ldi	r20, 0x7A	; 122
    23b6:	55 e4       	ldi	r21, 0x45	; 69
    23b8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    23bc:	dc 01       	movw	r26, r24
    23be:	cb 01       	movw	r24, r22
    23c0:	8f 83       	std	Y+7, r24	; 0x07
    23c2:	98 87       	std	Y+8, r25	; 0x08
    23c4:	a9 87       	std	Y+9, r26	; 0x09
    23c6:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    23c8:	6f 81       	ldd	r22, Y+7	; 0x07
    23ca:	78 85       	ldd	r23, Y+8	; 0x08
    23cc:	89 85       	ldd	r24, Y+9	; 0x09
    23ce:	9a 85       	ldd	r25, Y+10	; 0x0a
    23d0:	20 e0       	ldi	r18, 0x00	; 0
    23d2:	30 e0       	ldi	r19, 0x00	; 0
    23d4:	40 e8       	ldi	r20, 0x80	; 128
    23d6:	5f e3       	ldi	r21, 0x3F	; 63
    23d8:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    23dc:	88 23       	and	r24, r24
    23de:	2c f4       	brge	.+10     	; 0x23ea <writebittosend+0x3e8>
		__ticks = 1;
    23e0:	81 e0       	ldi	r24, 0x01	; 1
    23e2:	90 e0       	ldi	r25, 0x00	; 0
    23e4:	9e 83       	std	Y+6, r25	; 0x06
    23e6:	8d 83       	std	Y+5, r24	; 0x05
    23e8:	3f c0       	rjmp	.+126    	; 0x2468 <writebittosend+0x466>
	else if (__tmp > 65535)
    23ea:	6f 81       	ldd	r22, Y+7	; 0x07
    23ec:	78 85       	ldd	r23, Y+8	; 0x08
    23ee:	89 85       	ldd	r24, Y+9	; 0x09
    23f0:	9a 85       	ldd	r25, Y+10	; 0x0a
    23f2:	20 e0       	ldi	r18, 0x00	; 0
    23f4:	3f ef       	ldi	r19, 0xFF	; 255
    23f6:	4f e7       	ldi	r20, 0x7F	; 127
    23f8:	57 e4       	ldi	r21, 0x47	; 71
    23fa:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    23fe:	18 16       	cp	r1, r24
    2400:	4c f5       	brge	.+82     	; 0x2454 <writebittosend+0x452>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2402:	6b 85       	ldd	r22, Y+11	; 0x0b
    2404:	7c 85       	ldd	r23, Y+12	; 0x0c
    2406:	8d 85       	ldd	r24, Y+13	; 0x0d
    2408:	9e 85       	ldd	r25, Y+14	; 0x0e
    240a:	20 e0       	ldi	r18, 0x00	; 0
    240c:	30 e0       	ldi	r19, 0x00	; 0
    240e:	40 e2       	ldi	r20, 0x20	; 32
    2410:	51 e4       	ldi	r21, 0x41	; 65
    2412:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2416:	dc 01       	movw	r26, r24
    2418:	cb 01       	movw	r24, r22
    241a:	bc 01       	movw	r22, r24
    241c:	cd 01       	movw	r24, r26
    241e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2422:	dc 01       	movw	r26, r24
    2424:	cb 01       	movw	r24, r22
    2426:	9e 83       	std	Y+6, r25	; 0x06
    2428:	8d 83       	std	Y+5, r24	; 0x05
    242a:	0f c0       	rjmp	.+30     	; 0x244a <writebittosend+0x448>
    242c:	80 e9       	ldi	r24, 0x90	; 144
    242e:	91 e0       	ldi	r25, 0x01	; 1
    2430:	9c 83       	std	Y+4, r25	; 0x04
    2432:	8b 83       	std	Y+3, r24	; 0x03
    2434:	8b 81       	ldd	r24, Y+3	; 0x03
    2436:	9c 81       	ldd	r25, Y+4	; 0x04
    2438:	01 97       	sbiw	r24, 0x01	; 1
    243a:	f1 f7       	brne	.-4      	; 0x2438 <writebittosend+0x436>
    243c:	9c 83       	std	Y+4, r25	; 0x04
    243e:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2440:	8d 81       	ldd	r24, Y+5	; 0x05
    2442:	9e 81       	ldd	r25, Y+6	; 0x06
    2444:	01 97       	sbiw	r24, 0x01	; 1
    2446:	9e 83       	std	Y+6, r25	; 0x06
    2448:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    244a:	8d 81       	ldd	r24, Y+5	; 0x05
    244c:	9e 81       	ldd	r25, Y+6	; 0x06
    244e:	00 97       	sbiw	r24, 0x00	; 0
    2450:	69 f7       	brne	.-38     	; 0x242c <writebittosend+0x42a>
    2452:	14 c0       	rjmp	.+40     	; 0x247c <writebittosend+0x47a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2454:	6f 81       	ldd	r22, Y+7	; 0x07
    2456:	78 85       	ldd	r23, Y+8	; 0x08
    2458:	89 85       	ldd	r24, Y+9	; 0x09
    245a:	9a 85       	ldd	r25, Y+10	; 0x0a
    245c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2460:	dc 01       	movw	r26, r24
    2462:	cb 01       	movw	r24, r22
    2464:	9e 83       	std	Y+6, r25	; 0x06
    2466:	8d 83       	std	Y+5, r24	; 0x05
    2468:	8d 81       	ldd	r24, Y+5	; 0x05
    246a:	9e 81       	ldd	r25, Y+6	; 0x06
    246c:	9a 83       	std	Y+2, r25	; 0x02
    246e:	89 83       	std	Y+1, r24	; 0x01
    2470:	89 81       	ldd	r24, Y+1	; 0x01
    2472:	9a 81       	ldd	r25, Y+2	; 0x02
    2474:	01 97       	sbiw	r24, 0x01	; 1
    2476:	f1 f7       	brne	.-4      	; 0x2474 <writebittosend+0x472>
    2478:	9a 83       	std	Y+2, r25	; 0x02
    247a:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(30);

}
    247c:	e9 96       	adiw	r28, 0x39	; 57
    247e:	0f b6       	in	r0, 0x3f	; 63
    2480:	f8 94       	cli
    2482:	de bf       	out	0x3e, r29	; 62
    2484:	0f be       	out	0x3f, r0	; 63
    2486:	cd bf       	out	0x3d, r28	; 61
    2488:	cf 91       	pop	r28
    248a:	df 91       	pop	r29
    248c:	08 95       	ret

0000248e <LCD_INIT>:

void LCD_INIT(void)
{
    248e:	df 93       	push	r29
    2490:	cf 93       	push	r28
    2492:	cd b7       	in	r28, 0x3d	; 61
    2494:	de b7       	in	r29, 0x3e	; 62
    2496:	e8 97       	sbiw	r28, 0x38	; 56
    2498:	0f b6       	in	r0, 0x3f	; 63
    249a:	f8 94       	cli
    249c:	de bf       	out	0x3e, r29	; 62
    249e:	0f be       	out	0x3f, r0	; 63
    24a0:	cd bf       	out	0x3d, r28	; 61
    24a2:	80 e0       	ldi	r24, 0x00	; 0
    24a4:	90 e0       	ldi	r25, 0x00	; 0
    24a6:	a0 ef       	ldi	r26, 0xF0	; 240
    24a8:	b1 e4       	ldi	r27, 0x41	; 65
    24aa:	8d ab       	std	Y+53, r24	; 0x35
    24ac:	9e ab       	std	Y+54, r25	; 0x36
    24ae:	af ab       	std	Y+55, r26	; 0x37
    24b0:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    24b2:	6d a9       	ldd	r22, Y+53	; 0x35
    24b4:	7e a9       	ldd	r23, Y+54	; 0x36
    24b6:	8f a9       	ldd	r24, Y+55	; 0x37
    24b8:	98 ad       	ldd	r25, Y+56	; 0x38
    24ba:	20 e0       	ldi	r18, 0x00	; 0
    24bc:	30 e0       	ldi	r19, 0x00	; 0
    24be:	4a e7       	ldi	r20, 0x7A	; 122
    24c0:	55 e4       	ldi	r21, 0x45	; 69
    24c2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    24c6:	dc 01       	movw	r26, r24
    24c8:	cb 01       	movw	r24, r22
    24ca:	89 ab       	std	Y+49, r24	; 0x31
    24cc:	9a ab       	std	Y+50, r25	; 0x32
    24ce:	ab ab       	std	Y+51, r26	; 0x33
    24d0:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    24d2:	69 a9       	ldd	r22, Y+49	; 0x31
    24d4:	7a a9       	ldd	r23, Y+50	; 0x32
    24d6:	8b a9       	ldd	r24, Y+51	; 0x33
    24d8:	9c a9       	ldd	r25, Y+52	; 0x34
    24da:	20 e0       	ldi	r18, 0x00	; 0
    24dc:	30 e0       	ldi	r19, 0x00	; 0
    24de:	40 e8       	ldi	r20, 0x80	; 128
    24e0:	5f e3       	ldi	r21, 0x3F	; 63
    24e2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    24e6:	88 23       	and	r24, r24
    24e8:	2c f4       	brge	.+10     	; 0x24f4 <LCD_INIT+0x66>
		__ticks = 1;
    24ea:	81 e0       	ldi	r24, 0x01	; 1
    24ec:	90 e0       	ldi	r25, 0x00	; 0
    24ee:	98 ab       	std	Y+48, r25	; 0x30
    24f0:	8f a7       	std	Y+47, r24	; 0x2f
    24f2:	3f c0       	rjmp	.+126    	; 0x2572 <LCD_INIT+0xe4>
	else if (__tmp > 65535)
    24f4:	69 a9       	ldd	r22, Y+49	; 0x31
    24f6:	7a a9       	ldd	r23, Y+50	; 0x32
    24f8:	8b a9       	ldd	r24, Y+51	; 0x33
    24fa:	9c a9       	ldd	r25, Y+52	; 0x34
    24fc:	20 e0       	ldi	r18, 0x00	; 0
    24fe:	3f ef       	ldi	r19, 0xFF	; 255
    2500:	4f e7       	ldi	r20, 0x7F	; 127
    2502:	57 e4       	ldi	r21, 0x47	; 71
    2504:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2508:	18 16       	cp	r1, r24
    250a:	4c f5       	brge	.+82     	; 0x255e <LCD_INIT+0xd0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    250c:	6d a9       	ldd	r22, Y+53	; 0x35
    250e:	7e a9       	ldd	r23, Y+54	; 0x36
    2510:	8f a9       	ldd	r24, Y+55	; 0x37
    2512:	98 ad       	ldd	r25, Y+56	; 0x38
    2514:	20 e0       	ldi	r18, 0x00	; 0
    2516:	30 e0       	ldi	r19, 0x00	; 0
    2518:	40 e2       	ldi	r20, 0x20	; 32
    251a:	51 e4       	ldi	r21, 0x41	; 65
    251c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2520:	dc 01       	movw	r26, r24
    2522:	cb 01       	movw	r24, r22
    2524:	bc 01       	movw	r22, r24
    2526:	cd 01       	movw	r24, r26
    2528:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    252c:	dc 01       	movw	r26, r24
    252e:	cb 01       	movw	r24, r22
    2530:	98 ab       	std	Y+48, r25	; 0x30
    2532:	8f a7       	std	Y+47, r24	; 0x2f
    2534:	0f c0       	rjmp	.+30     	; 0x2554 <LCD_INIT+0xc6>
    2536:	80 e9       	ldi	r24, 0x90	; 144
    2538:	91 e0       	ldi	r25, 0x01	; 1
    253a:	9e a7       	std	Y+46, r25	; 0x2e
    253c:	8d a7       	std	Y+45, r24	; 0x2d
    253e:	8d a5       	ldd	r24, Y+45	; 0x2d
    2540:	9e a5       	ldd	r25, Y+46	; 0x2e
    2542:	01 97       	sbiw	r24, 0x01	; 1
    2544:	f1 f7       	brne	.-4      	; 0x2542 <LCD_INIT+0xb4>
    2546:	9e a7       	std	Y+46, r25	; 0x2e
    2548:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    254a:	8f a5       	ldd	r24, Y+47	; 0x2f
    254c:	98 a9       	ldd	r25, Y+48	; 0x30
    254e:	01 97       	sbiw	r24, 0x01	; 1
    2550:	98 ab       	std	Y+48, r25	; 0x30
    2552:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2554:	8f a5       	ldd	r24, Y+47	; 0x2f
    2556:	98 a9       	ldd	r25, Y+48	; 0x30
    2558:	00 97       	sbiw	r24, 0x00	; 0
    255a:	69 f7       	brne	.-38     	; 0x2536 <LCD_INIT+0xa8>
    255c:	14 c0       	rjmp	.+40     	; 0x2586 <LCD_INIT+0xf8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    255e:	69 a9       	ldd	r22, Y+49	; 0x31
    2560:	7a a9       	ldd	r23, Y+50	; 0x32
    2562:	8b a9       	ldd	r24, Y+51	; 0x33
    2564:	9c a9       	ldd	r25, Y+52	; 0x34
    2566:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    256a:	dc 01       	movw	r26, r24
    256c:	cb 01       	movw	r24, r22
    256e:	98 ab       	std	Y+48, r25	; 0x30
    2570:	8f a7       	std	Y+47, r24	; 0x2f
    2572:	8f a5       	ldd	r24, Y+47	; 0x2f
    2574:	98 a9       	ldd	r25, Y+48	; 0x30
    2576:	9c a7       	std	Y+44, r25	; 0x2c
    2578:	8b a7       	std	Y+43, r24	; 0x2b
    257a:	8b a5       	ldd	r24, Y+43	; 0x2b
    257c:	9c a5       	ldd	r25, Y+44	; 0x2c
    257e:	01 97       	sbiw	r24, 0x01	; 1
    2580:	f1 f7       	brne	.-4      	; 0x257e <LCD_INIT+0xf0>
    2582:	9c a7       	std	Y+44, r25	; 0x2c
    2584:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(30);
	DIO_voidSetPinDirection(RS_PORT, RS_PIN, PIN_OUTPUT);
    2586:	83 e0       	ldi	r24, 0x03	; 3
    2588:	62 e0       	ldi	r22, 0x02	; 2
    258a:	41 e0       	ldi	r20, 0x01	; 1
    258c:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(EN_PORT, EN_PIN, PIN_OUTPUT);
    2590:	83 e0       	ldi	r24, 0x03	; 3
    2592:	61 e0       	ldi	r22, 0x01	; 1
    2594:	41 e0       	ldi	r20, 0x01	; 1
    2596:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(D7_PORT, D7_PIN, PIN_OUTPUT);
    259a:	83 e0       	ldi	r24, 0x03	; 3
    259c:	67 e0       	ldi	r22, 0x07	; 7
    259e:	41 e0       	ldi	r20, 0x01	; 1
    25a0:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(D6_PORT, D6_PIN, PIN_OUTPUT);
    25a4:	83 e0       	ldi	r24, 0x03	; 3
    25a6:	66 e0       	ldi	r22, 0x06	; 6
    25a8:	41 e0       	ldi	r20, 0x01	; 1
    25aa:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(D5_PORT, D5_PIN, PIN_OUTPUT);
    25ae:	83 e0       	ldi	r24, 0x03	; 3
    25b0:	65 e0       	ldi	r22, 0x05	; 5
    25b2:	41 e0       	ldi	r20, 0x01	; 1
    25b4:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(D4_PORT, D4_PIN, PIN_OUTPUT);
    25b8:	83 e0       	ldi	r24, 0x03	; 3
    25ba:	64 e0       	ldi	r22, 0x04	; 4
    25bc:	41 e0       	ldi	r20, 0x01	; 1
    25be:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <DIO_voidSetPinDirection>



	LCD_WRITE_COMMAND(TWO_LINES_4_BIT);
    25c2:	88 e2       	ldi	r24, 0x28	; 40
    25c4:	0e 94 4c 14 	call	0x2898	; 0x2898 <LCD_WRITE_COMMAND>
    25c8:	80 e0       	ldi	r24, 0x00	; 0
    25ca:	90 e0       	ldi	r25, 0x00	; 0
    25cc:	a0 e0       	ldi	r26, 0x00	; 0
    25ce:	b0 e4       	ldi	r27, 0x40	; 64
    25d0:	8f a3       	std	Y+39, r24	; 0x27
    25d2:	98 a7       	std	Y+40, r25	; 0x28
    25d4:	a9 a7       	std	Y+41, r26	; 0x29
    25d6:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    25d8:	6f a1       	ldd	r22, Y+39	; 0x27
    25da:	78 a5       	ldd	r23, Y+40	; 0x28
    25dc:	89 a5       	ldd	r24, Y+41	; 0x29
    25de:	9a a5       	ldd	r25, Y+42	; 0x2a
    25e0:	20 e0       	ldi	r18, 0x00	; 0
    25e2:	30 e0       	ldi	r19, 0x00	; 0
    25e4:	4a e7       	ldi	r20, 0x7A	; 122
    25e6:	55 e4       	ldi	r21, 0x45	; 69
    25e8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    25ec:	dc 01       	movw	r26, r24
    25ee:	cb 01       	movw	r24, r22
    25f0:	8b a3       	std	Y+35, r24	; 0x23
    25f2:	9c a3       	std	Y+36, r25	; 0x24
    25f4:	ad a3       	std	Y+37, r26	; 0x25
    25f6:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    25f8:	6b a1       	ldd	r22, Y+35	; 0x23
    25fa:	7c a1       	ldd	r23, Y+36	; 0x24
    25fc:	8d a1       	ldd	r24, Y+37	; 0x25
    25fe:	9e a1       	ldd	r25, Y+38	; 0x26
    2600:	20 e0       	ldi	r18, 0x00	; 0
    2602:	30 e0       	ldi	r19, 0x00	; 0
    2604:	40 e8       	ldi	r20, 0x80	; 128
    2606:	5f e3       	ldi	r21, 0x3F	; 63
    2608:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    260c:	88 23       	and	r24, r24
    260e:	2c f4       	brge	.+10     	; 0x261a <LCD_INIT+0x18c>
		__ticks = 1;
    2610:	81 e0       	ldi	r24, 0x01	; 1
    2612:	90 e0       	ldi	r25, 0x00	; 0
    2614:	9a a3       	std	Y+34, r25	; 0x22
    2616:	89 a3       	std	Y+33, r24	; 0x21
    2618:	3f c0       	rjmp	.+126    	; 0x2698 <LCD_INIT+0x20a>
	else if (__tmp > 65535)
    261a:	6b a1       	ldd	r22, Y+35	; 0x23
    261c:	7c a1       	ldd	r23, Y+36	; 0x24
    261e:	8d a1       	ldd	r24, Y+37	; 0x25
    2620:	9e a1       	ldd	r25, Y+38	; 0x26
    2622:	20 e0       	ldi	r18, 0x00	; 0
    2624:	3f ef       	ldi	r19, 0xFF	; 255
    2626:	4f e7       	ldi	r20, 0x7F	; 127
    2628:	57 e4       	ldi	r21, 0x47	; 71
    262a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    262e:	18 16       	cp	r1, r24
    2630:	4c f5       	brge	.+82     	; 0x2684 <LCD_INIT+0x1f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2632:	6f a1       	ldd	r22, Y+39	; 0x27
    2634:	78 a5       	ldd	r23, Y+40	; 0x28
    2636:	89 a5       	ldd	r24, Y+41	; 0x29
    2638:	9a a5       	ldd	r25, Y+42	; 0x2a
    263a:	20 e0       	ldi	r18, 0x00	; 0
    263c:	30 e0       	ldi	r19, 0x00	; 0
    263e:	40 e2       	ldi	r20, 0x20	; 32
    2640:	51 e4       	ldi	r21, 0x41	; 65
    2642:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2646:	dc 01       	movw	r26, r24
    2648:	cb 01       	movw	r24, r22
    264a:	bc 01       	movw	r22, r24
    264c:	cd 01       	movw	r24, r26
    264e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2652:	dc 01       	movw	r26, r24
    2654:	cb 01       	movw	r24, r22
    2656:	9a a3       	std	Y+34, r25	; 0x22
    2658:	89 a3       	std	Y+33, r24	; 0x21
    265a:	0f c0       	rjmp	.+30     	; 0x267a <LCD_INIT+0x1ec>
    265c:	80 e9       	ldi	r24, 0x90	; 144
    265e:	91 e0       	ldi	r25, 0x01	; 1
    2660:	98 a3       	std	Y+32, r25	; 0x20
    2662:	8f 8f       	std	Y+31, r24	; 0x1f
    2664:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2666:	98 a1       	ldd	r25, Y+32	; 0x20
    2668:	01 97       	sbiw	r24, 0x01	; 1
    266a:	f1 f7       	brne	.-4      	; 0x2668 <LCD_INIT+0x1da>
    266c:	98 a3       	std	Y+32, r25	; 0x20
    266e:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2670:	89 a1       	ldd	r24, Y+33	; 0x21
    2672:	9a a1       	ldd	r25, Y+34	; 0x22
    2674:	01 97       	sbiw	r24, 0x01	; 1
    2676:	9a a3       	std	Y+34, r25	; 0x22
    2678:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    267a:	89 a1       	ldd	r24, Y+33	; 0x21
    267c:	9a a1       	ldd	r25, Y+34	; 0x22
    267e:	00 97       	sbiw	r24, 0x00	; 0
    2680:	69 f7       	brne	.-38     	; 0x265c <LCD_INIT+0x1ce>
    2682:	14 c0       	rjmp	.+40     	; 0x26ac <LCD_INIT+0x21e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2684:	6b a1       	ldd	r22, Y+35	; 0x23
    2686:	7c a1       	ldd	r23, Y+36	; 0x24
    2688:	8d a1       	ldd	r24, Y+37	; 0x25
    268a:	9e a1       	ldd	r25, Y+38	; 0x26
    268c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2690:	dc 01       	movw	r26, r24
    2692:	cb 01       	movw	r24, r22
    2694:	9a a3       	std	Y+34, r25	; 0x22
    2696:	89 a3       	std	Y+33, r24	; 0x21
    2698:	89 a1       	ldd	r24, Y+33	; 0x21
    269a:	9a a1       	ldd	r25, Y+34	; 0x22
    269c:	9e 8f       	std	Y+30, r25	; 0x1e
    269e:	8d 8f       	std	Y+29, r24	; 0x1d
    26a0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    26a2:	9e 8d       	ldd	r25, Y+30	; 0x1e
    26a4:	01 97       	sbiw	r24, 0x01	; 1
    26a6:	f1 f7       	brne	.-4      	; 0x26a4 <LCD_INIT+0x216>
    26a8:	9e 8f       	std	Y+30, r25	; 0x1e
    26aa:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(2);
	LCD_WRITE_COMMAND(DISPLAY_ON_CURSER_OFF);
    26ac:	8c e0       	ldi	r24, 0x0C	; 12
    26ae:	0e 94 4c 14 	call	0x2898	; 0x2898 <LCD_WRITE_COMMAND>
    26b2:	80 e0       	ldi	r24, 0x00	; 0
    26b4:	90 e0       	ldi	r25, 0x00	; 0
    26b6:	a0 e0       	ldi	r26, 0x00	; 0
    26b8:	b0 e4       	ldi	r27, 0x40	; 64
    26ba:	89 8f       	std	Y+25, r24	; 0x19
    26bc:	9a 8f       	std	Y+26, r25	; 0x1a
    26be:	ab 8f       	std	Y+27, r26	; 0x1b
    26c0:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    26c2:	69 8d       	ldd	r22, Y+25	; 0x19
    26c4:	7a 8d       	ldd	r23, Y+26	; 0x1a
    26c6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    26c8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    26ca:	20 e0       	ldi	r18, 0x00	; 0
    26cc:	30 e0       	ldi	r19, 0x00	; 0
    26ce:	4a e7       	ldi	r20, 0x7A	; 122
    26d0:	55 e4       	ldi	r21, 0x45	; 69
    26d2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    26d6:	dc 01       	movw	r26, r24
    26d8:	cb 01       	movw	r24, r22
    26da:	8d 8b       	std	Y+21, r24	; 0x15
    26dc:	9e 8b       	std	Y+22, r25	; 0x16
    26de:	af 8b       	std	Y+23, r26	; 0x17
    26e0:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    26e2:	6d 89       	ldd	r22, Y+21	; 0x15
    26e4:	7e 89       	ldd	r23, Y+22	; 0x16
    26e6:	8f 89       	ldd	r24, Y+23	; 0x17
    26e8:	98 8d       	ldd	r25, Y+24	; 0x18
    26ea:	20 e0       	ldi	r18, 0x00	; 0
    26ec:	30 e0       	ldi	r19, 0x00	; 0
    26ee:	40 e8       	ldi	r20, 0x80	; 128
    26f0:	5f e3       	ldi	r21, 0x3F	; 63
    26f2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    26f6:	88 23       	and	r24, r24
    26f8:	2c f4       	brge	.+10     	; 0x2704 <LCD_INIT+0x276>
		__ticks = 1;
    26fa:	81 e0       	ldi	r24, 0x01	; 1
    26fc:	90 e0       	ldi	r25, 0x00	; 0
    26fe:	9c 8b       	std	Y+20, r25	; 0x14
    2700:	8b 8b       	std	Y+19, r24	; 0x13
    2702:	3f c0       	rjmp	.+126    	; 0x2782 <LCD_INIT+0x2f4>
	else if (__tmp > 65535)
    2704:	6d 89       	ldd	r22, Y+21	; 0x15
    2706:	7e 89       	ldd	r23, Y+22	; 0x16
    2708:	8f 89       	ldd	r24, Y+23	; 0x17
    270a:	98 8d       	ldd	r25, Y+24	; 0x18
    270c:	20 e0       	ldi	r18, 0x00	; 0
    270e:	3f ef       	ldi	r19, 0xFF	; 255
    2710:	4f e7       	ldi	r20, 0x7F	; 127
    2712:	57 e4       	ldi	r21, 0x47	; 71
    2714:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2718:	18 16       	cp	r1, r24
    271a:	4c f5       	brge	.+82     	; 0x276e <LCD_INIT+0x2e0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    271c:	69 8d       	ldd	r22, Y+25	; 0x19
    271e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2720:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2722:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2724:	20 e0       	ldi	r18, 0x00	; 0
    2726:	30 e0       	ldi	r19, 0x00	; 0
    2728:	40 e2       	ldi	r20, 0x20	; 32
    272a:	51 e4       	ldi	r21, 0x41	; 65
    272c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2730:	dc 01       	movw	r26, r24
    2732:	cb 01       	movw	r24, r22
    2734:	bc 01       	movw	r22, r24
    2736:	cd 01       	movw	r24, r26
    2738:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    273c:	dc 01       	movw	r26, r24
    273e:	cb 01       	movw	r24, r22
    2740:	9c 8b       	std	Y+20, r25	; 0x14
    2742:	8b 8b       	std	Y+19, r24	; 0x13
    2744:	0f c0       	rjmp	.+30     	; 0x2764 <LCD_INIT+0x2d6>
    2746:	80 e9       	ldi	r24, 0x90	; 144
    2748:	91 e0       	ldi	r25, 0x01	; 1
    274a:	9a 8b       	std	Y+18, r25	; 0x12
    274c:	89 8b       	std	Y+17, r24	; 0x11
    274e:	89 89       	ldd	r24, Y+17	; 0x11
    2750:	9a 89       	ldd	r25, Y+18	; 0x12
    2752:	01 97       	sbiw	r24, 0x01	; 1
    2754:	f1 f7       	brne	.-4      	; 0x2752 <LCD_INIT+0x2c4>
    2756:	9a 8b       	std	Y+18, r25	; 0x12
    2758:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    275a:	8b 89       	ldd	r24, Y+19	; 0x13
    275c:	9c 89       	ldd	r25, Y+20	; 0x14
    275e:	01 97       	sbiw	r24, 0x01	; 1
    2760:	9c 8b       	std	Y+20, r25	; 0x14
    2762:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2764:	8b 89       	ldd	r24, Y+19	; 0x13
    2766:	9c 89       	ldd	r25, Y+20	; 0x14
    2768:	00 97       	sbiw	r24, 0x00	; 0
    276a:	69 f7       	brne	.-38     	; 0x2746 <LCD_INIT+0x2b8>
    276c:	14 c0       	rjmp	.+40     	; 0x2796 <LCD_INIT+0x308>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    276e:	6d 89       	ldd	r22, Y+21	; 0x15
    2770:	7e 89       	ldd	r23, Y+22	; 0x16
    2772:	8f 89       	ldd	r24, Y+23	; 0x17
    2774:	98 8d       	ldd	r25, Y+24	; 0x18
    2776:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    277a:	dc 01       	movw	r26, r24
    277c:	cb 01       	movw	r24, r22
    277e:	9c 8b       	std	Y+20, r25	; 0x14
    2780:	8b 8b       	std	Y+19, r24	; 0x13
    2782:	8b 89       	ldd	r24, Y+19	; 0x13
    2784:	9c 89       	ldd	r25, Y+20	; 0x14
    2786:	98 8b       	std	Y+16, r25	; 0x10
    2788:	8f 87       	std	Y+15, r24	; 0x0f
    278a:	8f 85       	ldd	r24, Y+15	; 0x0f
    278c:	98 89       	ldd	r25, Y+16	; 0x10
    278e:	01 97       	sbiw	r24, 0x01	; 1
    2790:	f1 f7       	brne	.-4      	; 0x278e <LCD_INIT+0x300>
    2792:	98 8b       	std	Y+16, r25	; 0x10
    2794:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(2);
	LCD_WRITE_COMMAND(CLEAR_SCREEN);
    2796:	81 e0       	ldi	r24, 0x01	; 1
    2798:	0e 94 4c 14 	call	0x2898	; 0x2898 <LCD_WRITE_COMMAND>
    279c:	80 e0       	ldi	r24, 0x00	; 0
    279e:	90 e0       	ldi	r25, 0x00	; 0
    27a0:	a0 e0       	ldi	r26, 0x00	; 0
    27a2:	b0 e4       	ldi	r27, 0x40	; 64
    27a4:	8b 87       	std	Y+11, r24	; 0x0b
    27a6:	9c 87       	std	Y+12, r25	; 0x0c
    27a8:	ad 87       	std	Y+13, r26	; 0x0d
    27aa:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    27ac:	6b 85       	ldd	r22, Y+11	; 0x0b
    27ae:	7c 85       	ldd	r23, Y+12	; 0x0c
    27b0:	8d 85       	ldd	r24, Y+13	; 0x0d
    27b2:	9e 85       	ldd	r25, Y+14	; 0x0e
    27b4:	20 e0       	ldi	r18, 0x00	; 0
    27b6:	30 e0       	ldi	r19, 0x00	; 0
    27b8:	4a e7       	ldi	r20, 0x7A	; 122
    27ba:	55 e4       	ldi	r21, 0x45	; 69
    27bc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    27c0:	dc 01       	movw	r26, r24
    27c2:	cb 01       	movw	r24, r22
    27c4:	8f 83       	std	Y+7, r24	; 0x07
    27c6:	98 87       	std	Y+8, r25	; 0x08
    27c8:	a9 87       	std	Y+9, r26	; 0x09
    27ca:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    27cc:	6f 81       	ldd	r22, Y+7	; 0x07
    27ce:	78 85       	ldd	r23, Y+8	; 0x08
    27d0:	89 85       	ldd	r24, Y+9	; 0x09
    27d2:	9a 85       	ldd	r25, Y+10	; 0x0a
    27d4:	20 e0       	ldi	r18, 0x00	; 0
    27d6:	30 e0       	ldi	r19, 0x00	; 0
    27d8:	40 e8       	ldi	r20, 0x80	; 128
    27da:	5f e3       	ldi	r21, 0x3F	; 63
    27dc:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    27e0:	88 23       	and	r24, r24
    27e2:	2c f4       	brge	.+10     	; 0x27ee <LCD_INIT+0x360>
		__ticks = 1;
    27e4:	81 e0       	ldi	r24, 0x01	; 1
    27e6:	90 e0       	ldi	r25, 0x00	; 0
    27e8:	9e 83       	std	Y+6, r25	; 0x06
    27ea:	8d 83       	std	Y+5, r24	; 0x05
    27ec:	3f c0       	rjmp	.+126    	; 0x286c <LCD_INIT+0x3de>
	else if (__tmp > 65535)
    27ee:	6f 81       	ldd	r22, Y+7	; 0x07
    27f0:	78 85       	ldd	r23, Y+8	; 0x08
    27f2:	89 85       	ldd	r24, Y+9	; 0x09
    27f4:	9a 85       	ldd	r25, Y+10	; 0x0a
    27f6:	20 e0       	ldi	r18, 0x00	; 0
    27f8:	3f ef       	ldi	r19, 0xFF	; 255
    27fa:	4f e7       	ldi	r20, 0x7F	; 127
    27fc:	57 e4       	ldi	r21, 0x47	; 71
    27fe:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2802:	18 16       	cp	r1, r24
    2804:	4c f5       	brge	.+82     	; 0x2858 <LCD_INIT+0x3ca>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2806:	6b 85       	ldd	r22, Y+11	; 0x0b
    2808:	7c 85       	ldd	r23, Y+12	; 0x0c
    280a:	8d 85       	ldd	r24, Y+13	; 0x0d
    280c:	9e 85       	ldd	r25, Y+14	; 0x0e
    280e:	20 e0       	ldi	r18, 0x00	; 0
    2810:	30 e0       	ldi	r19, 0x00	; 0
    2812:	40 e2       	ldi	r20, 0x20	; 32
    2814:	51 e4       	ldi	r21, 0x41	; 65
    2816:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    281a:	dc 01       	movw	r26, r24
    281c:	cb 01       	movw	r24, r22
    281e:	bc 01       	movw	r22, r24
    2820:	cd 01       	movw	r24, r26
    2822:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2826:	dc 01       	movw	r26, r24
    2828:	cb 01       	movw	r24, r22
    282a:	9e 83       	std	Y+6, r25	; 0x06
    282c:	8d 83       	std	Y+5, r24	; 0x05
    282e:	0f c0       	rjmp	.+30     	; 0x284e <LCD_INIT+0x3c0>
    2830:	80 e9       	ldi	r24, 0x90	; 144
    2832:	91 e0       	ldi	r25, 0x01	; 1
    2834:	9c 83       	std	Y+4, r25	; 0x04
    2836:	8b 83       	std	Y+3, r24	; 0x03
    2838:	8b 81       	ldd	r24, Y+3	; 0x03
    283a:	9c 81       	ldd	r25, Y+4	; 0x04
    283c:	01 97       	sbiw	r24, 0x01	; 1
    283e:	f1 f7       	brne	.-4      	; 0x283c <LCD_INIT+0x3ae>
    2840:	9c 83       	std	Y+4, r25	; 0x04
    2842:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2844:	8d 81       	ldd	r24, Y+5	; 0x05
    2846:	9e 81       	ldd	r25, Y+6	; 0x06
    2848:	01 97       	sbiw	r24, 0x01	; 1
    284a:	9e 83       	std	Y+6, r25	; 0x06
    284c:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    284e:	8d 81       	ldd	r24, Y+5	; 0x05
    2850:	9e 81       	ldd	r25, Y+6	; 0x06
    2852:	00 97       	sbiw	r24, 0x00	; 0
    2854:	69 f7       	brne	.-38     	; 0x2830 <LCD_INIT+0x3a2>
    2856:	14 c0       	rjmp	.+40     	; 0x2880 <LCD_INIT+0x3f2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2858:	6f 81       	ldd	r22, Y+7	; 0x07
    285a:	78 85       	ldd	r23, Y+8	; 0x08
    285c:	89 85       	ldd	r24, Y+9	; 0x09
    285e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2860:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2864:	dc 01       	movw	r26, r24
    2866:	cb 01       	movw	r24, r22
    2868:	9e 83       	std	Y+6, r25	; 0x06
    286a:	8d 83       	std	Y+5, r24	; 0x05
    286c:	8d 81       	ldd	r24, Y+5	; 0x05
    286e:	9e 81       	ldd	r25, Y+6	; 0x06
    2870:	9a 83       	std	Y+2, r25	; 0x02
    2872:	89 83       	std	Y+1, r24	; 0x01
    2874:	89 81       	ldd	r24, Y+1	; 0x01
    2876:	9a 81       	ldd	r25, Y+2	; 0x02
    2878:	01 97       	sbiw	r24, 0x01	; 1
    287a:	f1 f7       	brne	.-4      	; 0x2878 <LCD_INIT+0x3ea>
    287c:	9a 83       	std	Y+2, r25	; 0x02
    287e:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	LCD_WRITE_COMMAND(ENTRY_MODE_SET);
    2880:	86 e0       	ldi	r24, 0x06	; 6
    2882:	0e 94 4c 14 	call	0x2898	; 0x2898 <LCD_WRITE_COMMAND>


}
    2886:	e8 96       	adiw	r28, 0x38	; 56
    2888:	0f b6       	in	r0, 0x3f	; 63
    288a:	f8 94       	cli
    288c:	de bf       	out	0x3e, r29	; 62
    288e:	0f be       	out	0x3f, r0	; 63
    2890:	cd bf       	out	0x3d, r28	; 61
    2892:	cf 91       	pop	r28
    2894:	df 91       	pop	r29
    2896:	08 95       	ret

00002898 <LCD_WRITE_COMMAND>:

void LCD_WRITE_COMMAND(u8 command)
{
    2898:	df 93       	push	r29
    289a:	cf 93       	push	r28
    289c:	0f 92       	push	r0
    289e:	cd b7       	in	r28, 0x3d	; 61
    28a0:	de b7       	in	r29, 0x3e	; 62
    28a2:	89 83       	std	Y+1, r24	; 0x01
	DIO_voidSetPinValue(RS_PORT, RS_PIN, PIN_LOW);
    28a4:	83 e0       	ldi	r24, 0x03	; 3
    28a6:	62 e0       	ldi	r22, 0x02	; 2
    28a8:	40 e0       	ldi	r20, 0x00	; 0
    28aa:	0e 94 71 0d 	call	0x1ae2	; 0x1ae2 <DIO_voidSetPinValue>
	writebittosend(command);
    28ae:	89 81       	ldd	r24, Y+1	; 0x01
    28b0:	0e 94 01 10 	call	0x2002	; 0x2002 <writebittosend>
}
    28b4:	0f 90       	pop	r0
    28b6:	cf 91       	pop	r28
    28b8:	df 91       	pop	r29
    28ba:	08 95       	ret

000028bc <LCD_WRITE_DATA>:

void LCD_WRITE_DATA(u8 data)
{
    28bc:	df 93       	push	r29
    28be:	cf 93       	push	r28
    28c0:	0f 92       	push	r0
    28c2:	cd b7       	in	r28, 0x3d	; 61
    28c4:	de b7       	in	r29, 0x3e	; 62
    28c6:	89 83       	std	Y+1, r24	; 0x01
	DIO_voidSetPinValue(RS_PORT, RS_PIN, PIN_HIGH);
    28c8:	83 e0       	ldi	r24, 0x03	; 3
    28ca:	62 e0       	ldi	r22, 0x02	; 2
    28cc:	41 e0       	ldi	r20, 0x01	; 1
    28ce:	0e 94 71 0d 	call	0x1ae2	; 0x1ae2 <DIO_voidSetPinValue>
	writebittosend(data);
    28d2:	89 81       	ldd	r24, Y+1	; 0x01
    28d4:	0e 94 01 10 	call	0x2002	; 0x2002 <writebittosend>
}
    28d8:	0f 90       	pop	r0
    28da:	cf 91       	pop	r28
    28dc:	df 91       	pop	r29
    28de:	08 95       	ret

000028e0 <LCD_WRITE_STRING>:

void LCD_WRITE_STRING(u8 *str)
{
    28e0:	df 93       	push	r29
    28e2:	cf 93       	push	r28
    28e4:	00 d0       	rcall	.+0      	; 0x28e6 <LCD_WRITE_STRING+0x6>
    28e6:	00 d0       	rcall	.+0      	; 0x28e8 <LCD_WRITE_STRING+0x8>
    28e8:	00 d0       	rcall	.+0      	; 0x28ea <LCD_WRITE_STRING+0xa>
    28ea:	cd b7       	in	r28, 0x3d	; 61
    28ec:	de b7       	in	r29, 0x3e	; 62
    28ee:	9e 83       	std	Y+6, r25	; 0x06
    28f0:	8d 83       	std	Y+5, r24	; 0x05
	u32 i=0;
    28f2:	19 82       	std	Y+1, r1	; 0x01
    28f4:	1a 82       	std	Y+2, r1	; 0x02
    28f6:	1b 82       	std	Y+3, r1	; 0x03
    28f8:	1c 82       	std	Y+4, r1	; 0x04
    28fa:	15 c0       	rjmp	.+42     	; 0x2926 <LCD_WRITE_STRING+0x46>
	while(str[i] !='\0')
	{
		LCD_WRITE_DATA(str[i]);
    28fc:	29 81       	ldd	r18, Y+1	; 0x01
    28fe:	3a 81       	ldd	r19, Y+2	; 0x02
    2900:	8d 81       	ldd	r24, Y+5	; 0x05
    2902:	9e 81       	ldd	r25, Y+6	; 0x06
    2904:	fc 01       	movw	r30, r24
    2906:	e2 0f       	add	r30, r18
    2908:	f3 1f       	adc	r31, r19
    290a:	80 81       	ld	r24, Z
    290c:	0e 94 5e 14 	call	0x28bc	; 0x28bc <LCD_WRITE_DATA>
		i++;
    2910:	89 81       	ldd	r24, Y+1	; 0x01
    2912:	9a 81       	ldd	r25, Y+2	; 0x02
    2914:	ab 81       	ldd	r26, Y+3	; 0x03
    2916:	bc 81       	ldd	r27, Y+4	; 0x04
    2918:	01 96       	adiw	r24, 0x01	; 1
    291a:	a1 1d       	adc	r26, r1
    291c:	b1 1d       	adc	r27, r1
    291e:	89 83       	std	Y+1, r24	; 0x01
    2920:	9a 83       	std	Y+2, r25	; 0x02
    2922:	ab 83       	std	Y+3, r26	; 0x03
    2924:	bc 83       	std	Y+4, r27	; 0x04
}

void LCD_WRITE_STRING(u8 *str)
{
	u32 i=0;
	while(str[i] !='\0')
    2926:	29 81       	ldd	r18, Y+1	; 0x01
    2928:	3a 81       	ldd	r19, Y+2	; 0x02
    292a:	8d 81       	ldd	r24, Y+5	; 0x05
    292c:	9e 81       	ldd	r25, Y+6	; 0x06
    292e:	fc 01       	movw	r30, r24
    2930:	e2 0f       	add	r30, r18
    2932:	f3 1f       	adc	r31, r19
    2934:	80 81       	ld	r24, Z
    2936:	88 23       	and	r24, r24
    2938:	09 f7       	brne	.-62     	; 0x28fc <LCD_WRITE_STRING+0x1c>
	{
		LCD_WRITE_DATA(str[i]);
		i++;

	}
}
    293a:	26 96       	adiw	r28, 0x06	; 6
    293c:	0f b6       	in	r0, 0x3f	; 63
    293e:	f8 94       	cli
    2940:	de bf       	out	0x3e, r29	; 62
    2942:	0f be       	out	0x3f, r0	; 63
    2944:	cd bf       	out	0x3d, r28	; 61
    2946:	cf 91       	pop	r28
    2948:	df 91       	pop	r29
    294a:	08 95       	ret

0000294c <LCD_voidClear>:

void LCD_voidClear(void)
{
    294c:	df 93       	push	r29
    294e:	cf 93       	push	r28
    2950:	cd b7       	in	r28, 0x3d	; 61
    2952:	de b7       	in	r29, 0x3e	; 62
	LCD_WRITE_COMMAND(CLEAR_SCREEN);
    2954:	81 e0       	ldi	r24, 0x01	; 1
    2956:	0e 94 4c 14 	call	0x2898	; 0x2898 <LCD_WRITE_COMMAND>
}
    295a:	cf 91       	pop	r28
    295c:	df 91       	pop	r29
    295e:	08 95       	ret

00002960 <LCD_voidGoToXY>:
void LCD_voidGoToXY(u8 copy_u8row,u8 copy_u8col)
{
    2960:	df 93       	push	r29
    2962:	cf 93       	push	r28
    2964:	00 d0       	rcall	.+0      	; 0x2966 <LCD_voidGoToXY+0x6>
    2966:	cd b7       	in	r28, 0x3d	; 61
    2968:	de b7       	in	r29, 0x3e	; 62
    296a:	89 83       	std	Y+1, r24	; 0x01
    296c:	6a 83       	std	Y+2, r22	; 0x02

	static u8 local_address ;
	if(copy_u8row == 0)
    296e:	89 81       	ldd	r24, Y+1	; 0x01
    2970:	88 23       	and	r24, r24
    2972:	21 f4       	brne	.+8      	; 0x297c <LCD_voidGoToXY+0x1c>
	{
		local_address =copy_u8col ;
    2974:	8a 81       	ldd	r24, Y+2	; 0x02
    2976:	80 93 c6 00 	sts	0x00C6, r24
    297a:	07 c0       	rjmp	.+14     	; 0x298a <LCD_voidGoToXY+0x2a>
	}
	else if(copy_u8row == 1)
    297c:	89 81       	ldd	r24, Y+1	; 0x01
    297e:	81 30       	cpi	r24, 0x01	; 1
    2980:	21 f4       	brne	.+8      	; 0x298a <LCD_voidGoToXY+0x2a>
	{
		local_address =0x40+copy_u8col ;
    2982:	8a 81       	ldd	r24, Y+2	; 0x02
    2984:	80 5c       	subi	r24, 0xC0	; 192
    2986:	80 93 c6 00 	sts	0x00C6, r24
	}

}
    298a:	0f 90       	pop	r0
    298c:	0f 90       	pop	r0
    298e:	cf 91       	pop	r28
    2990:	df 91       	pop	r29
    2992:	08 95       	ret

00002994 <LCD_voidWriteInt>:
void LCD_voidWriteInt(int data)
{
    2994:	df 93       	push	r29
    2996:	cf 93       	push	r28
    2998:	cd b7       	in	r28, 0x3d	; 61
    299a:	de b7       	in	r29, 0x3e	; 62
    299c:	a2 97       	sbiw	r28, 0x22	; 34
    299e:	0f b6       	in	r0, 0x3f	; 63
    29a0:	f8 94       	cli
    29a2:	de bf       	out	0x3e, r29	; 62
    29a4:	0f be       	out	0x3f, r0	; 63
    29a6:	cd bf       	out	0x3d, r28	; 61
    29a8:	9a a3       	std	Y+34, r25	; 0x22
    29aa:	89 a3       	std	Y+33, r24	; 0x21
   u16 buff[16]; /* String to hold the ascii result */
   itoa(data,buff,10); /* Use itoa C function to convert the data to its corresponding ASCII value, 10 for decimal */
    29ac:	89 a1       	ldd	r24, Y+33	; 0x21
    29ae:	9a a1       	ldd	r25, Y+34	; 0x22
    29b0:	9e 01       	movw	r18, r28
    29b2:	2f 5f       	subi	r18, 0xFF	; 255
    29b4:	3f 4f       	sbci	r19, 0xFF	; 255
    29b6:	b9 01       	movw	r22, r18
    29b8:	4a e0       	ldi	r20, 0x0A	; 10
    29ba:	50 e0       	ldi	r21, 0x00	; 0
    29bc:	0e 94 ba 2a 	call	0x5574	; 0x5574 <itoa>
   LCD_WRITE_STRING(buff); /* Display the string */
    29c0:	ce 01       	movw	r24, r28
    29c2:	01 96       	adiw	r24, 0x01	; 1
    29c4:	0e 94 70 14 	call	0x28e0	; 0x28e0 <LCD_WRITE_STRING>
}
    29c8:	a2 96       	adiw	r28, 0x22	; 34
    29ca:	0f b6       	in	r0, 0x3f	; 63
    29cc:	f8 94       	cli
    29ce:	de bf       	out	0x3e, r29	; 62
    29d0:	0f be       	out	0x3f, r0	; 63
    29d2:	cd bf       	out	0x3d, r28	; 61
    29d4:	cf 91       	pop	r28
    29d6:	df 91       	pop	r29
    29d8:	08 95       	ret

000029da <HLED_VidInit>:
#include"..\..\LIB\LSTD_TYPES.h"
#include"..\..\MCAL\MDIO\MDIO_Interface.h"
#include"HLED_Interface.h"

void HLED_VidInit(LED_t *Copy_Led)
{
    29da:	df 93       	push	r29
    29dc:	cf 93       	push	r28
    29de:	00 d0       	rcall	.+0      	; 0x29e0 <HLED_VidInit+0x6>
    29e0:	cd b7       	in	r28, 0x3d	; 61
    29e2:	de b7       	in	r29, 0x3e	; 62
    29e4:	9a 83       	std	Y+2, r25	; 0x02
    29e6:	89 83       	std	Y+1, r24	; 0x01
	MDIO_Error_State_SetPinDirection(Copy_Led->Copy_u8Pin,Copy_Led->Copy_u8Port,PIN_OUTPUT);
    29e8:	e9 81       	ldd	r30, Y+1	; 0x01
    29ea:	fa 81       	ldd	r31, Y+2	; 0x02
    29ec:	81 81       	ldd	r24, Z+1	; 0x01
    29ee:	e9 81       	ldd	r30, Y+1	; 0x01
    29f0:	fa 81       	ldd	r31, Y+2	; 0x02
    29f2:	90 81       	ld	r25, Z
    29f4:	69 2f       	mov	r22, r25
    29f6:	41 e0       	ldi	r20, 0x01	; 1
    29f8:	0e 94 07 08 	call	0x100e	; 0x100e <MDIO_Error_State_SetPinDirection>
}
    29fc:	0f 90       	pop	r0
    29fe:	0f 90       	pop	r0
    2a00:	cf 91       	pop	r28
    2a02:	df 91       	pop	r29
    2a04:	08 95       	ret

00002a06 <HLED_VidLed_On>:
void HLED_VidLed_On(LED_t *Copy_Led)
{
    2a06:	df 93       	push	r29
    2a08:	cf 93       	push	r28
    2a0a:	00 d0       	rcall	.+0      	; 0x2a0c <HLED_VidLed_On+0x6>
    2a0c:	cd b7       	in	r28, 0x3d	; 61
    2a0e:	de b7       	in	r29, 0x3e	; 62
    2a10:	9a 83       	std	Y+2, r25	; 0x02
    2a12:	89 83       	std	Y+1, r24	; 0x01
	MDIO_Error_State_SetPinValue(Copy_Led->Copy_u8Pin,Copy_Led->Copy_u8Port,PIN_HIGH);
    2a14:	e9 81       	ldd	r30, Y+1	; 0x01
    2a16:	fa 81       	ldd	r31, Y+2	; 0x02
    2a18:	81 81       	ldd	r24, Z+1	; 0x01
    2a1a:	e9 81       	ldd	r30, Y+1	; 0x01
    2a1c:	fa 81       	ldd	r31, Y+2	; 0x02
    2a1e:	90 81       	ld	r25, Z
    2a20:	69 2f       	mov	r22, r25
    2a22:	41 e0       	ldi	r20, 0x01	; 1
    2a24:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <MDIO_Error_State_SetPinValue>
}
    2a28:	0f 90       	pop	r0
    2a2a:	0f 90       	pop	r0
    2a2c:	cf 91       	pop	r28
    2a2e:	df 91       	pop	r29
    2a30:	08 95       	ret

00002a32 <HLED_VidLed_Off>:
void HLED_VidLed_Off(LED_t *Copy_Led)
{
    2a32:	df 93       	push	r29
    2a34:	cf 93       	push	r28
    2a36:	00 d0       	rcall	.+0      	; 0x2a38 <HLED_VidLed_Off+0x6>
    2a38:	cd b7       	in	r28, 0x3d	; 61
    2a3a:	de b7       	in	r29, 0x3e	; 62
    2a3c:	9a 83       	std	Y+2, r25	; 0x02
    2a3e:	89 83       	std	Y+1, r24	; 0x01
	MDIO_Error_State_SetPinValue(Copy_Led->Copy_u8Pin,Copy_Led->Copy_u8Port,PIN_LOW);
    2a40:	e9 81       	ldd	r30, Y+1	; 0x01
    2a42:	fa 81       	ldd	r31, Y+2	; 0x02
    2a44:	81 81       	ldd	r24, Z+1	; 0x01
    2a46:	e9 81       	ldd	r30, Y+1	; 0x01
    2a48:	fa 81       	ldd	r31, Y+2	; 0x02
    2a4a:	90 81       	ld	r25, Z
    2a4c:	69 2f       	mov	r22, r25
    2a4e:	40 e0       	ldi	r20, 0x00	; 0
    2a50:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <MDIO_Error_State_SetPinValue>
}
    2a54:	0f 90       	pop	r0
    2a56:	0f 90       	pop	r0
    2a58:	cf 91       	pop	r28
    2a5a:	df 91       	pop	r29
    2a5c:	08 95       	ret

00002a5e <HLED_VidLed_Toggle>:
void HLED_VidLed_Toggle(LED_t *Copy_Led)
{
    2a5e:	df 93       	push	r29
    2a60:	cf 93       	push	r28
    2a62:	00 d0       	rcall	.+0      	; 0x2a64 <HLED_VidLed_Toggle+0x6>
    2a64:	cd b7       	in	r28, 0x3d	; 61
    2a66:	de b7       	in	r29, 0x3e	; 62
    2a68:	9a 83       	std	Y+2, r25	; 0x02
    2a6a:	89 83       	std	Y+1, r24	; 0x01
	/*Toggle Function*/
	static u8 Flag=0;
	if(Flag==0)
    2a6c:	80 91 c7 00 	lds	r24, 0x00C7
    2a70:	88 23       	and	r24, r24
    2a72:	69 f4       	brne	.+26     	; 0x2a8e <HLED_VidLed_Toggle+0x30>
	{
	MDIO_Error_State_SetPinValue(Copy_Led->Copy_u8Pin,Copy_Led->Copy_u8Port,PIN_HIGH);
    2a74:	e9 81       	ldd	r30, Y+1	; 0x01
    2a76:	fa 81       	ldd	r31, Y+2	; 0x02
    2a78:	81 81       	ldd	r24, Z+1	; 0x01
    2a7a:	e9 81       	ldd	r30, Y+1	; 0x01
    2a7c:	fa 81       	ldd	r31, Y+2	; 0x02
    2a7e:	90 81       	ld	r25, Z
    2a80:	69 2f       	mov	r22, r25
    2a82:	41 e0       	ldi	r20, 0x01	; 1
    2a84:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <MDIO_Error_State_SetPinValue>
	Flag=1;
    2a88:	81 e0       	ldi	r24, 0x01	; 1
    2a8a:	80 93 c7 00 	sts	0x00C7, r24
	}
	if(Flag==1)
    2a8e:	80 91 c7 00 	lds	r24, 0x00C7
    2a92:	81 30       	cpi	r24, 0x01	; 1
    2a94:	61 f4       	brne	.+24     	; 0x2aae <HLED_VidLed_Toggle+0x50>
	{
	MDIO_Error_State_SetPinValue(Copy_Led->Copy_u8Pin,Copy_Led->Copy_u8Port,PIN_LOW);
    2a96:	e9 81       	ldd	r30, Y+1	; 0x01
    2a98:	fa 81       	ldd	r31, Y+2	; 0x02
    2a9a:	81 81       	ldd	r24, Z+1	; 0x01
    2a9c:	e9 81       	ldd	r30, Y+1	; 0x01
    2a9e:	fa 81       	ldd	r31, Y+2	; 0x02
    2aa0:	90 81       	ld	r25, Z
    2aa2:	69 2f       	mov	r22, r25
    2aa4:	40 e0       	ldi	r20, 0x00	; 0
    2aa6:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <MDIO_Error_State_SetPinValue>
	Flag=0;
    2aaa:	10 92 c7 00 	sts	0x00C7, r1
	}

}
    2aae:	0f 90       	pop	r0
    2ab0:	0f 90       	pop	r0
    2ab2:	cf 91       	pop	r28
    2ab4:	df 91       	pop	r29
    2ab6:	08 95       	ret

00002ab8 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    2ab8:	df 93       	push	r29
    2aba:	cf 93       	push	r28
    2abc:	cd b7       	in	r28, 0x3d	; 61
    2abe:	de b7       	in	r29, 0x3e	; 62
    2ac0:	27 97       	sbiw	r28, 0x07	; 7
    2ac2:	0f b6       	in	r0, 0x3f	; 63
    2ac4:	f8 94       	cli
    2ac6:	de bf       	out	0x3e, r29	; 62
    2ac8:	0f be       	out	0x3f, r0	; 63
    2aca:	cd bf       	out	0x3d, r28	; 61
    2acc:	9d 83       	std	Y+5, r25	; 0x05
    2ace:	8c 83       	std	Y+4, r24	; 0x04
    2ad0:	6e 83       	std	Y+6, r22	; 0x06
    2ad2:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    2ad4:	8a e1       	ldi	r24, 0x1A	; 26
    2ad6:	90 e0       	ldi	r25, 0x00	; 0
    2ad8:	0e 94 34 18 	call	0x3068	; 0x3068 <pvPortMalloc>
    2adc:	9a 83       	std	Y+2, r25	; 0x02
    2ade:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    2ae0:	89 81       	ldd	r24, Y+1	; 0x01
    2ae2:	9a 81       	ldd	r25, Y+2	; 0x02
    2ae4:	00 97       	sbiw	r24, 0x00	; 0
    2ae6:	09 f4       	brne	.+2      	; 0x2aea <xCoRoutineCreate+0x32>
    2ae8:	6f c0       	rjmp	.+222    	; 0x2bc8 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    2aea:	80 91 c8 00 	lds	r24, 0x00C8
    2aee:	90 91 c9 00 	lds	r25, 0x00C9
    2af2:	00 97       	sbiw	r24, 0x00	; 0
    2af4:	41 f4       	brne	.+16     	; 0x2b06 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    2af6:	89 81       	ldd	r24, Y+1	; 0x01
    2af8:	9a 81       	ldd	r25, Y+2	; 0x02
    2afa:	90 93 c9 00 	sts	0x00C9, r25
    2afe:	80 93 c8 00 	sts	0x00C8, r24
			prvInitialiseCoRoutineLists();
    2b02:	0e 94 c3 17 	call	0x2f86	; 0x2f86 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    2b06:	8e 81       	ldd	r24, Y+6	; 0x06
    2b08:	82 30       	cpi	r24, 0x02	; 2
    2b0a:	10 f0       	brcs	.+4      	; 0x2b10 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    2b0c:	81 e0       	ldi	r24, 0x01	; 1
    2b0e:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    2b10:	e9 81       	ldd	r30, Y+1	; 0x01
    2b12:	fa 81       	ldd	r31, Y+2	; 0x02
    2b14:	11 8e       	std	Z+25, r1	; 0x19
    2b16:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    2b18:	e9 81       	ldd	r30, Y+1	; 0x01
    2b1a:	fa 81       	ldd	r31, Y+2	; 0x02
    2b1c:	8e 81       	ldd	r24, Y+6	; 0x06
    2b1e:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    2b20:	e9 81       	ldd	r30, Y+1	; 0x01
    2b22:	fa 81       	ldd	r31, Y+2	; 0x02
    2b24:	8f 81       	ldd	r24, Y+7	; 0x07
    2b26:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    2b28:	e9 81       	ldd	r30, Y+1	; 0x01
    2b2a:	fa 81       	ldd	r31, Y+2	; 0x02
    2b2c:	8c 81       	ldd	r24, Y+4	; 0x04
    2b2e:	9d 81       	ldd	r25, Y+5	; 0x05
    2b30:	91 83       	std	Z+1, r25	; 0x01
    2b32:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    2b34:	89 81       	ldd	r24, Y+1	; 0x01
    2b36:	9a 81       	ldd	r25, Y+2	; 0x02
    2b38:	02 96       	adiw	r24, 0x02	; 2
    2b3a:	0e 94 ca 18 	call	0x3194	; 0x3194 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    2b3e:	89 81       	ldd	r24, Y+1	; 0x01
    2b40:	9a 81       	ldd	r25, Y+2	; 0x02
    2b42:	0c 96       	adiw	r24, 0x0c	; 12
    2b44:	0e 94 ca 18 	call	0x3194	; 0x3194 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    2b48:	e9 81       	ldd	r30, Y+1	; 0x01
    2b4a:	fa 81       	ldd	r31, Y+2	; 0x02
    2b4c:	89 81       	ldd	r24, Y+1	; 0x01
    2b4e:	9a 81       	ldd	r25, Y+2	; 0x02
    2b50:	91 87       	std	Z+9, r25	; 0x09
    2b52:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    2b54:	e9 81       	ldd	r30, Y+1	; 0x01
    2b56:	fa 81       	ldd	r31, Y+2	; 0x02
    2b58:	89 81       	ldd	r24, Y+1	; 0x01
    2b5a:	9a 81       	ldd	r25, Y+2	; 0x02
    2b5c:	93 8b       	std	Z+19, r25	; 0x13
    2b5e:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2b60:	8e 81       	ldd	r24, Y+6	; 0x06
    2b62:	28 2f       	mov	r18, r24
    2b64:	30 e0       	ldi	r19, 0x00	; 0
    2b66:	84 e0       	ldi	r24, 0x04	; 4
    2b68:	90 e0       	ldi	r25, 0x00	; 0
    2b6a:	82 1b       	sub	r24, r18
    2b6c:	93 0b       	sbc	r25, r19
    2b6e:	e9 81       	ldd	r30, Y+1	; 0x01
    2b70:	fa 81       	ldd	r31, Y+2	; 0x02
    2b72:	95 87       	std	Z+13, r25	; 0x0d
    2b74:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    2b76:	e9 81       	ldd	r30, Y+1	; 0x01
    2b78:	fa 81       	ldd	r31, Y+2	; 0x02
    2b7a:	96 89       	ldd	r25, Z+22	; 0x16
    2b7c:	80 91 ca 00 	lds	r24, 0x00CA
    2b80:	89 17       	cp	r24, r25
    2b82:	28 f4       	brcc	.+10     	; 0x2b8e <xCoRoutineCreate+0xd6>
    2b84:	e9 81       	ldd	r30, Y+1	; 0x01
    2b86:	fa 81       	ldd	r31, Y+2	; 0x02
    2b88:	86 89       	ldd	r24, Z+22	; 0x16
    2b8a:	80 93 ca 00 	sts	0x00CA, r24
    2b8e:	e9 81       	ldd	r30, Y+1	; 0x01
    2b90:	fa 81       	ldd	r31, Y+2	; 0x02
    2b92:	86 89       	ldd	r24, Z+22	; 0x16
    2b94:	28 2f       	mov	r18, r24
    2b96:	30 e0       	ldi	r19, 0x00	; 0
    2b98:	c9 01       	movw	r24, r18
    2b9a:	88 0f       	add	r24, r24
    2b9c:	99 1f       	adc	r25, r25
    2b9e:	88 0f       	add	r24, r24
    2ba0:	99 1f       	adc	r25, r25
    2ba2:	88 0f       	add	r24, r24
    2ba4:	99 1f       	adc	r25, r25
    2ba6:	82 0f       	add	r24, r18
    2ba8:	93 1f       	adc	r25, r19
    2baa:	ac 01       	movw	r20, r24
    2bac:	4f 52       	subi	r20, 0x2F	; 47
    2bae:	5f 4f       	sbci	r21, 0xFF	; 255
    2bb0:	89 81       	ldd	r24, Y+1	; 0x01
    2bb2:	9a 81       	ldd	r25, Y+2	; 0x02
    2bb4:	9c 01       	movw	r18, r24
    2bb6:	2e 5f       	subi	r18, 0xFE	; 254
    2bb8:	3f 4f       	sbci	r19, 0xFF	; 255
    2bba:	ca 01       	movw	r24, r20
    2bbc:	b9 01       	movw	r22, r18
    2bbe:	0e 94 da 18 	call	0x31b4	; 0x31b4 <vListInsertEnd>

		xReturn = pdPASS;
    2bc2:	81 e0       	ldi	r24, 0x01	; 1
    2bc4:	8b 83       	std	Y+3, r24	; 0x03
    2bc6:	02 c0       	rjmp	.+4      	; 0x2bcc <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2bc8:	8f ef       	ldi	r24, 0xFF	; 255
    2bca:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
    2bcc:	8b 81       	ldd	r24, Y+3	; 0x03
}
    2bce:	27 96       	adiw	r28, 0x07	; 7
    2bd0:	0f b6       	in	r0, 0x3f	; 63
    2bd2:	f8 94       	cli
    2bd4:	de bf       	out	0x3e, r29	; 62
    2bd6:	0f be       	out	0x3f, r0	; 63
    2bd8:	cd bf       	out	0x3d, r28	; 61
    2bda:	cf 91       	pop	r28
    2bdc:	df 91       	pop	r29
    2bde:	08 95       	ret

00002be0 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    2be0:	df 93       	push	r29
    2be2:	cf 93       	push	r28
    2be4:	00 d0       	rcall	.+0      	; 0x2be6 <vCoRoutineAddToDelayedList+0x6>
    2be6:	00 d0       	rcall	.+0      	; 0x2be8 <vCoRoutineAddToDelayedList+0x8>
    2be8:	00 d0       	rcall	.+0      	; 0x2bea <vCoRoutineAddToDelayedList+0xa>
    2bea:	cd b7       	in	r28, 0x3d	; 61
    2bec:	de b7       	in	r29, 0x3e	; 62
    2bee:	9c 83       	std	Y+4, r25	; 0x04
    2bf0:	8b 83       	std	Y+3, r24	; 0x03
    2bf2:	7e 83       	std	Y+6, r23	; 0x06
    2bf4:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    2bf6:	20 91 cb 00 	lds	r18, 0x00CB
    2bfa:	30 91 cc 00 	lds	r19, 0x00CC
    2bfe:	8b 81       	ldd	r24, Y+3	; 0x03
    2c00:	9c 81       	ldd	r25, Y+4	; 0x04
    2c02:	82 0f       	add	r24, r18
    2c04:	93 1f       	adc	r25, r19
    2c06:	9a 83       	std	Y+2, r25	; 0x02
    2c08:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2c0a:	80 91 c8 00 	lds	r24, 0x00C8
    2c0e:	90 91 c9 00 	lds	r25, 0x00C9
    2c12:	02 96       	adiw	r24, 0x02	; 2
    2c14:	0e 94 92 19 	call	0x3324	; 0x3324 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    2c18:	e0 91 c8 00 	lds	r30, 0x00C8
    2c1c:	f0 91 c9 00 	lds	r31, 0x00C9
    2c20:	89 81       	ldd	r24, Y+1	; 0x01
    2c22:	9a 81       	ldd	r25, Y+2	; 0x02
    2c24:	93 83       	std	Z+3, r25	; 0x03
    2c26:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    2c28:	20 91 cb 00 	lds	r18, 0x00CB
    2c2c:	30 91 cc 00 	lds	r19, 0x00CC
    2c30:	89 81       	ldd	r24, Y+1	; 0x01
    2c32:	9a 81       	ldd	r25, Y+2	; 0x02
    2c34:	82 17       	cp	r24, r18
    2c36:	93 07       	cpc	r25, r19
    2c38:	70 f4       	brcc	.+28     	; 0x2c56 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2c3a:	80 91 f7 00 	lds	r24, 0x00F7
    2c3e:	90 91 f8 00 	lds	r25, 0x00F8
    2c42:	20 91 c8 00 	lds	r18, 0x00C8
    2c46:	30 91 c9 00 	lds	r19, 0x00C9
    2c4a:	2e 5f       	subi	r18, 0xFE	; 254
    2c4c:	3f 4f       	sbci	r19, 0xFF	; 255
    2c4e:	b9 01       	movw	r22, r18
    2c50:	0e 94 26 19 	call	0x324c	; 0x324c <vListInsert>
    2c54:	0d c0       	rjmp	.+26     	; 0x2c70 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2c56:	80 91 f5 00 	lds	r24, 0x00F5
    2c5a:	90 91 f6 00 	lds	r25, 0x00F6
    2c5e:	20 91 c8 00 	lds	r18, 0x00C8
    2c62:	30 91 c9 00 	lds	r19, 0x00C9
    2c66:	2e 5f       	subi	r18, 0xFE	; 254
    2c68:	3f 4f       	sbci	r19, 0xFF	; 255
    2c6a:	b9 01       	movw	r22, r18
    2c6c:	0e 94 26 19 	call	0x324c	; 0x324c <vListInsert>
	}

	if( pxEventList )
    2c70:	8d 81       	ldd	r24, Y+5	; 0x05
    2c72:	9e 81       	ldd	r25, Y+6	; 0x06
    2c74:	00 97       	sbiw	r24, 0x00	; 0
    2c76:	61 f0       	breq	.+24     	; 0x2c90 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    2c78:	80 91 c8 00 	lds	r24, 0x00C8
    2c7c:	90 91 c9 00 	lds	r25, 0x00C9
    2c80:	9c 01       	movw	r18, r24
    2c82:	24 5f       	subi	r18, 0xF4	; 244
    2c84:	3f 4f       	sbci	r19, 0xFF	; 255
    2c86:	8d 81       	ldd	r24, Y+5	; 0x05
    2c88:	9e 81       	ldd	r25, Y+6	; 0x06
    2c8a:	b9 01       	movw	r22, r18
    2c8c:	0e 94 26 19 	call	0x324c	; 0x324c <vListInsert>
	}
}
    2c90:	26 96       	adiw	r28, 0x06	; 6
    2c92:	0f b6       	in	r0, 0x3f	; 63
    2c94:	f8 94       	cli
    2c96:	de bf       	out	0x3e, r29	; 62
    2c98:	0f be       	out	0x3f, r0	; 63
    2c9a:	cd bf       	out	0x3d, r28	; 61
    2c9c:	cf 91       	pop	r28
    2c9e:	df 91       	pop	r29
    2ca0:	08 95       	ret

00002ca2 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    2ca2:	df 93       	push	r29
    2ca4:	cf 93       	push	r28
    2ca6:	00 d0       	rcall	.+0      	; 0x2ca8 <prvCheckPendingReadyList+0x6>
    2ca8:	cd b7       	in	r28, 0x3d	; 61
    2caa:	de b7       	in	r29, 0x3e	; 62
    2cac:	3a c0       	rjmp	.+116    	; 0x2d22 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    2cae:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    2cb0:	e0 91 fe 00 	lds	r30, 0x00FE
    2cb4:	f0 91 ff 00 	lds	r31, 0x00FF
    2cb8:	86 81       	ldd	r24, Z+6	; 0x06
    2cba:	97 81       	ldd	r25, Z+7	; 0x07
    2cbc:	9a 83       	std	Y+2, r25	; 0x02
    2cbe:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2cc0:	89 81       	ldd	r24, Y+1	; 0x01
    2cc2:	9a 81       	ldd	r25, Y+2	; 0x02
    2cc4:	0c 96       	adiw	r24, 0x0c	; 12
    2cc6:	0e 94 92 19 	call	0x3324	; 0x3324 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    2cca:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    2ccc:	89 81       	ldd	r24, Y+1	; 0x01
    2cce:	9a 81       	ldd	r25, Y+2	; 0x02
    2cd0:	02 96       	adiw	r24, 0x02	; 2
    2cd2:	0e 94 92 19 	call	0x3324	; 0x3324 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    2cd6:	e9 81       	ldd	r30, Y+1	; 0x01
    2cd8:	fa 81       	ldd	r31, Y+2	; 0x02
    2cda:	96 89       	ldd	r25, Z+22	; 0x16
    2cdc:	80 91 ca 00 	lds	r24, 0x00CA
    2ce0:	89 17       	cp	r24, r25
    2ce2:	28 f4       	brcc	.+10     	; 0x2cee <prvCheckPendingReadyList+0x4c>
    2ce4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ce6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ce8:	86 89       	ldd	r24, Z+22	; 0x16
    2cea:	80 93 ca 00 	sts	0x00CA, r24
    2cee:	e9 81       	ldd	r30, Y+1	; 0x01
    2cf0:	fa 81       	ldd	r31, Y+2	; 0x02
    2cf2:	86 89       	ldd	r24, Z+22	; 0x16
    2cf4:	28 2f       	mov	r18, r24
    2cf6:	30 e0       	ldi	r19, 0x00	; 0
    2cf8:	c9 01       	movw	r24, r18
    2cfa:	88 0f       	add	r24, r24
    2cfc:	99 1f       	adc	r25, r25
    2cfe:	88 0f       	add	r24, r24
    2d00:	99 1f       	adc	r25, r25
    2d02:	88 0f       	add	r24, r24
    2d04:	99 1f       	adc	r25, r25
    2d06:	82 0f       	add	r24, r18
    2d08:	93 1f       	adc	r25, r19
    2d0a:	ac 01       	movw	r20, r24
    2d0c:	4f 52       	subi	r20, 0x2F	; 47
    2d0e:	5f 4f       	sbci	r21, 0xFF	; 255
    2d10:	89 81       	ldd	r24, Y+1	; 0x01
    2d12:	9a 81       	ldd	r25, Y+2	; 0x02
    2d14:	9c 01       	movw	r18, r24
    2d16:	2e 5f       	subi	r18, 0xFE	; 254
    2d18:	3f 4f       	sbci	r19, 0xFF	; 255
    2d1a:	ca 01       	movw	r24, r20
    2d1c:	b9 01       	movw	r22, r18
    2d1e:	0e 94 da 18 	call	0x31b4	; 0x31b4 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    2d22:	80 91 f9 00 	lds	r24, 0x00F9
    2d26:	88 23       	and	r24, r24
    2d28:	09 f0       	breq	.+2      	; 0x2d2c <prvCheckPendingReadyList+0x8a>
    2d2a:	c1 cf       	rjmp	.-126    	; 0x2cae <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    2d2c:	0f 90       	pop	r0
    2d2e:	0f 90       	pop	r0
    2d30:	cf 91       	pop	r28
    2d32:	df 91       	pop	r29
    2d34:	08 95       	ret

00002d36 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    2d36:	df 93       	push	r29
    2d38:	cf 93       	push	r28
    2d3a:	00 d0       	rcall	.+0      	; 0x2d3c <prvCheckDelayedList+0x6>
    2d3c:	00 d0       	rcall	.+0      	; 0x2d3e <prvCheckDelayedList+0x8>
    2d3e:	cd b7       	in	r28, 0x3d	; 61
    2d40:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    2d42:	0e 94 7e 25 	call	0x4afc	; 0x4afc <xTaskGetTickCount>
    2d46:	20 91 cd 00 	lds	r18, 0x00CD
    2d4a:	30 91 ce 00 	lds	r19, 0x00CE
    2d4e:	82 1b       	sub	r24, r18
    2d50:	93 0b       	sbc	r25, r19
    2d52:	90 93 d0 00 	sts	0x00D0, r25
    2d56:	80 93 cf 00 	sts	0x00CF, r24
    2d5a:	85 c0       	rjmp	.+266    	; 0x2e66 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    2d5c:	80 91 cb 00 	lds	r24, 0x00CB
    2d60:	90 91 cc 00 	lds	r25, 0x00CC
    2d64:	01 96       	adiw	r24, 0x01	; 1
    2d66:	90 93 cc 00 	sts	0x00CC, r25
    2d6a:	80 93 cb 00 	sts	0x00CB, r24
		xPassedTicks--;
    2d6e:	80 91 cf 00 	lds	r24, 0x00CF
    2d72:	90 91 d0 00 	lds	r25, 0x00D0
    2d76:	01 97       	sbiw	r24, 0x01	; 1
    2d78:	90 93 d0 00 	sts	0x00D0, r25
    2d7c:	80 93 cf 00 	sts	0x00CF, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    2d80:	80 91 cb 00 	lds	r24, 0x00CB
    2d84:	90 91 cc 00 	lds	r25, 0x00CC
    2d88:	00 97       	sbiw	r24, 0x00	; 0
    2d8a:	09 f0       	breq	.+2      	; 0x2d8e <prvCheckDelayedList+0x58>
    2d8c:	64 c0       	rjmp	.+200    	; 0x2e56 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    2d8e:	80 91 f5 00 	lds	r24, 0x00F5
    2d92:	90 91 f6 00 	lds	r25, 0x00F6
    2d96:	9a 83       	std	Y+2, r25	; 0x02
    2d98:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    2d9a:	80 91 f7 00 	lds	r24, 0x00F7
    2d9e:	90 91 f8 00 	lds	r25, 0x00F8
    2da2:	90 93 f6 00 	sts	0x00F6, r25
    2da6:	80 93 f5 00 	sts	0x00F5, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    2daa:	89 81       	ldd	r24, Y+1	; 0x01
    2dac:	9a 81       	ldd	r25, Y+2	; 0x02
    2dae:	90 93 f8 00 	sts	0x00F8, r25
    2db2:	80 93 f7 00 	sts	0x00F7, r24
    2db6:	4f c0       	rjmp	.+158    	; 0x2e56 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    2db8:	e0 91 f5 00 	lds	r30, 0x00F5
    2dbc:	f0 91 f6 00 	lds	r31, 0x00F6
    2dc0:	05 80       	ldd	r0, Z+5	; 0x05
    2dc2:	f6 81       	ldd	r31, Z+6	; 0x06
    2dc4:	e0 2d       	mov	r30, r0
    2dc6:	86 81       	ldd	r24, Z+6	; 0x06
    2dc8:	97 81       	ldd	r25, Z+7	; 0x07
    2dca:	9c 83       	std	Y+4, r25	; 0x04
    2dcc:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    2dce:	eb 81       	ldd	r30, Y+3	; 0x03
    2dd0:	fc 81       	ldd	r31, Y+4	; 0x04
    2dd2:	22 81       	ldd	r18, Z+2	; 0x02
    2dd4:	33 81       	ldd	r19, Z+3	; 0x03
    2dd6:	80 91 cb 00 	lds	r24, 0x00CB
    2dda:	90 91 cc 00 	lds	r25, 0x00CC
    2dde:	82 17       	cp	r24, r18
    2de0:	93 07       	cpc	r25, r19
    2de2:	08 f4       	brcc	.+2      	; 0x2de6 <prvCheckDelayedList+0xb0>
    2de4:	40 c0       	rjmp	.+128    	; 0x2e66 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    2de6:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    2de8:	8b 81       	ldd	r24, Y+3	; 0x03
    2dea:	9c 81       	ldd	r25, Y+4	; 0x04
    2dec:	02 96       	adiw	r24, 0x02	; 2
    2dee:	0e 94 92 19 	call	0x3324	; 0x3324 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    2df2:	eb 81       	ldd	r30, Y+3	; 0x03
    2df4:	fc 81       	ldd	r31, Y+4	; 0x04
    2df6:	84 89       	ldd	r24, Z+20	; 0x14
    2df8:	95 89       	ldd	r25, Z+21	; 0x15
    2dfa:	00 97       	sbiw	r24, 0x00	; 0
    2dfc:	29 f0       	breq	.+10     	; 0x2e08 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    2dfe:	8b 81       	ldd	r24, Y+3	; 0x03
    2e00:	9c 81       	ldd	r25, Y+4	; 0x04
    2e02:	0c 96       	adiw	r24, 0x0c	; 12
    2e04:	0e 94 92 19 	call	0x3324	; 0x3324 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    2e08:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    2e0a:	eb 81       	ldd	r30, Y+3	; 0x03
    2e0c:	fc 81       	ldd	r31, Y+4	; 0x04
    2e0e:	96 89       	ldd	r25, Z+22	; 0x16
    2e10:	80 91 ca 00 	lds	r24, 0x00CA
    2e14:	89 17       	cp	r24, r25
    2e16:	28 f4       	brcc	.+10     	; 0x2e22 <prvCheckDelayedList+0xec>
    2e18:	eb 81       	ldd	r30, Y+3	; 0x03
    2e1a:	fc 81       	ldd	r31, Y+4	; 0x04
    2e1c:	86 89       	ldd	r24, Z+22	; 0x16
    2e1e:	80 93 ca 00 	sts	0x00CA, r24
    2e22:	eb 81       	ldd	r30, Y+3	; 0x03
    2e24:	fc 81       	ldd	r31, Y+4	; 0x04
    2e26:	86 89       	ldd	r24, Z+22	; 0x16
    2e28:	28 2f       	mov	r18, r24
    2e2a:	30 e0       	ldi	r19, 0x00	; 0
    2e2c:	c9 01       	movw	r24, r18
    2e2e:	88 0f       	add	r24, r24
    2e30:	99 1f       	adc	r25, r25
    2e32:	88 0f       	add	r24, r24
    2e34:	99 1f       	adc	r25, r25
    2e36:	88 0f       	add	r24, r24
    2e38:	99 1f       	adc	r25, r25
    2e3a:	82 0f       	add	r24, r18
    2e3c:	93 1f       	adc	r25, r19
    2e3e:	ac 01       	movw	r20, r24
    2e40:	4f 52       	subi	r20, 0x2F	; 47
    2e42:	5f 4f       	sbci	r21, 0xFF	; 255
    2e44:	8b 81       	ldd	r24, Y+3	; 0x03
    2e46:	9c 81       	ldd	r25, Y+4	; 0x04
    2e48:	9c 01       	movw	r18, r24
    2e4a:	2e 5f       	subi	r18, 0xFE	; 254
    2e4c:	3f 4f       	sbci	r19, 0xFF	; 255
    2e4e:	ca 01       	movw	r24, r20
    2e50:	b9 01       	movw	r22, r18
    2e52:	0e 94 da 18 	call	0x31b4	; 0x31b4 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2e56:	e0 91 f5 00 	lds	r30, 0x00F5
    2e5a:	f0 91 f6 00 	lds	r31, 0x00F6
    2e5e:	80 81       	ld	r24, Z
    2e60:	88 23       	and	r24, r24
    2e62:	09 f0       	breq	.+2      	; 0x2e66 <prvCheckDelayedList+0x130>
    2e64:	a9 cf       	rjmp	.-174    	; 0x2db8 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    2e66:	80 91 cf 00 	lds	r24, 0x00CF
    2e6a:	90 91 d0 00 	lds	r25, 0x00D0
    2e6e:	00 97       	sbiw	r24, 0x00	; 0
    2e70:	09 f0       	breq	.+2      	; 0x2e74 <prvCheckDelayedList+0x13e>
    2e72:	74 cf       	rjmp	.-280    	; 0x2d5c <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    2e74:	80 91 cb 00 	lds	r24, 0x00CB
    2e78:	90 91 cc 00 	lds	r25, 0x00CC
    2e7c:	90 93 ce 00 	sts	0x00CE, r25
    2e80:	80 93 cd 00 	sts	0x00CD, r24
}
    2e84:	0f 90       	pop	r0
    2e86:	0f 90       	pop	r0
    2e88:	0f 90       	pop	r0
    2e8a:	0f 90       	pop	r0
    2e8c:	cf 91       	pop	r28
    2e8e:	df 91       	pop	r29
    2e90:	08 95       	ret

00002e92 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    2e92:	df 93       	push	r29
    2e94:	cf 93       	push	r28
    2e96:	00 d0       	rcall	.+0      	; 0x2e98 <vCoRoutineSchedule+0x6>
    2e98:	cd b7       	in	r28, 0x3d	; 61
    2e9a:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    2e9c:	0e 94 51 16 	call	0x2ca2	; 0x2ca2 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    2ea0:	0e 94 9b 16 	call	0x2d36	; 0x2d36 <prvCheckDelayedList>
    2ea4:	0a c0       	rjmp	.+20     	; 0x2eba <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    2ea6:	80 91 ca 00 	lds	r24, 0x00CA
    2eaa:	88 23       	and	r24, r24
    2eac:	09 f4       	brne	.+2      	; 0x2eb0 <vCoRoutineSchedule+0x1e>
    2eae:	66 c0       	rjmp	.+204    	; 0x2f7c <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    2eb0:	80 91 ca 00 	lds	r24, 0x00CA
    2eb4:	81 50       	subi	r24, 0x01	; 1
    2eb6:	80 93 ca 00 	sts	0x00CA, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2eba:	80 91 ca 00 	lds	r24, 0x00CA
    2ebe:	28 2f       	mov	r18, r24
    2ec0:	30 e0       	ldi	r19, 0x00	; 0
    2ec2:	c9 01       	movw	r24, r18
    2ec4:	88 0f       	add	r24, r24
    2ec6:	99 1f       	adc	r25, r25
    2ec8:	88 0f       	add	r24, r24
    2eca:	99 1f       	adc	r25, r25
    2ecc:	88 0f       	add	r24, r24
    2ece:	99 1f       	adc	r25, r25
    2ed0:	82 0f       	add	r24, r18
    2ed2:	93 1f       	adc	r25, r19
    2ed4:	fc 01       	movw	r30, r24
    2ed6:	ef 52       	subi	r30, 0x2F	; 47
    2ed8:	ff 4f       	sbci	r31, 0xFF	; 255
    2eda:	80 81       	ld	r24, Z
    2edc:	88 23       	and	r24, r24
    2ede:	19 f3       	breq	.-58     	; 0x2ea6 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    2ee0:	80 91 ca 00 	lds	r24, 0x00CA
    2ee4:	28 2f       	mov	r18, r24
    2ee6:	30 e0       	ldi	r19, 0x00	; 0
    2ee8:	c9 01       	movw	r24, r18
    2eea:	88 0f       	add	r24, r24
    2eec:	99 1f       	adc	r25, r25
    2eee:	88 0f       	add	r24, r24
    2ef0:	99 1f       	adc	r25, r25
    2ef2:	88 0f       	add	r24, r24
    2ef4:	99 1f       	adc	r25, r25
    2ef6:	82 0f       	add	r24, r18
    2ef8:	93 1f       	adc	r25, r19
    2efa:	8f 52       	subi	r24, 0x2F	; 47
    2efc:	9f 4f       	sbci	r25, 0xFF	; 255
    2efe:	9a 83       	std	Y+2, r25	; 0x02
    2f00:	89 83       	std	Y+1, r24	; 0x01
    2f02:	e9 81       	ldd	r30, Y+1	; 0x01
    2f04:	fa 81       	ldd	r31, Y+2	; 0x02
    2f06:	01 80       	ldd	r0, Z+1	; 0x01
    2f08:	f2 81       	ldd	r31, Z+2	; 0x02
    2f0a:	e0 2d       	mov	r30, r0
    2f0c:	82 81       	ldd	r24, Z+2	; 0x02
    2f0e:	93 81       	ldd	r25, Z+3	; 0x03
    2f10:	e9 81       	ldd	r30, Y+1	; 0x01
    2f12:	fa 81       	ldd	r31, Y+2	; 0x02
    2f14:	92 83       	std	Z+2, r25	; 0x02
    2f16:	81 83       	std	Z+1, r24	; 0x01
    2f18:	e9 81       	ldd	r30, Y+1	; 0x01
    2f1a:	fa 81       	ldd	r31, Y+2	; 0x02
    2f1c:	21 81       	ldd	r18, Z+1	; 0x01
    2f1e:	32 81       	ldd	r19, Z+2	; 0x02
    2f20:	89 81       	ldd	r24, Y+1	; 0x01
    2f22:	9a 81       	ldd	r25, Y+2	; 0x02
    2f24:	03 96       	adiw	r24, 0x03	; 3
    2f26:	28 17       	cp	r18, r24
    2f28:	39 07       	cpc	r19, r25
    2f2a:	59 f4       	brne	.+22     	; 0x2f42 <vCoRoutineSchedule+0xb0>
    2f2c:	e9 81       	ldd	r30, Y+1	; 0x01
    2f2e:	fa 81       	ldd	r31, Y+2	; 0x02
    2f30:	01 80       	ldd	r0, Z+1	; 0x01
    2f32:	f2 81       	ldd	r31, Z+2	; 0x02
    2f34:	e0 2d       	mov	r30, r0
    2f36:	82 81       	ldd	r24, Z+2	; 0x02
    2f38:	93 81       	ldd	r25, Z+3	; 0x03
    2f3a:	e9 81       	ldd	r30, Y+1	; 0x01
    2f3c:	fa 81       	ldd	r31, Y+2	; 0x02
    2f3e:	92 83       	std	Z+2, r25	; 0x02
    2f40:	81 83       	std	Z+1, r24	; 0x01
    2f42:	e9 81       	ldd	r30, Y+1	; 0x01
    2f44:	fa 81       	ldd	r31, Y+2	; 0x02
    2f46:	01 80       	ldd	r0, Z+1	; 0x01
    2f48:	f2 81       	ldd	r31, Z+2	; 0x02
    2f4a:	e0 2d       	mov	r30, r0
    2f4c:	86 81       	ldd	r24, Z+6	; 0x06
    2f4e:	97 81       	ldd	r25, Z+7	; 0x07
    2f50:	90 93 c9 00 	sts	0x00C9, r25
    2f54:	80 93 c8 00 	sts	0x00C8, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2f58:	e0 91 c8 00 	lds	r30, 0x00C8
    2f5c:	f0 91 c9 00 	lds	r31, 0x00C9
    2f60:	40 81       	ld	r20, Z
    2f62:	51 81       	ldd	r21, Z+1	; 0x01
    2f64:	80 91 c8 00 	lds	r24, 0x00C8
    2f68:	90 91 c9 00 	lds	r25, 0x00C9
    2f6c:	e0 91 c8 00 	lds	r30, 0x00C8
    2f70:	f0 91 c9 00 	lds	r31, 0x00C9
    2f74:	27 89       	ldd	r18, Z+23	; 0x17
    2f76:	62 2f       	mov	r22, r18
    2f78:	fa 01       	movw	r30, r20
    2f7a:	09 95       	icall

	return;
}
    2f7c:	0f 90       	pop	r0
    2f7e:	0f 90       	pop	r0
    2f80:	cf 91       	pop	r28
    2f82:	df 91       	pop	r29
    2f84:	08 95       	ret

00002f86 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    2f86:	df 93       	push	r29
    2f88:	cf 93       	push	r28
    2f8a:	0f 92       	push	r0
    2f8c:	cd b7       	in	r28, 0x3d	; 61
    2f8e:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2f90:	19 82       	std	Y+1, r1	; 0x01
    2f92:	13 c0       	rjmp	.+38     	; 0x2fba <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    2f94:	89 81       	ldd	r24, Y+1	; 0x01
    2f96:	28 2f       	mov	r18, r24
    2f98:	30 e0       	ldi	r19, 0x00	; 0
    2f9a:	c9 01       	movw	r24, r18
    2f9c:	88 0f       	add	r24, r24
    2f9e:	99 1f       	adc	r25, r25
    2fa0:	88 0f       	add	r24, r24
    2fa2:	99 1f       	adc	r25, r25
    2fa4:	88 0f       	add	r24, r24
    2fa6:	99 1f       	adc	r25, r25
    2fa8:	82 0f       	add	r24, r18
    2faa:	93 1f       	adc	r25, r19
    2fac:	8f 52       	subi	r24, 0x2F	; 47
    2fae:	9f 4f       	sbci	r25, 0xFF	; 255
    2fb0:	0e 94 a0 18 	call	0x3140	; 0x3140 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2fb4:	89 81       	ldd	r24, Y+1	; 0x01
    2fb6:	8f 5f       	subi	r24, 0xFF	; 255
    2fb8:	89 83       	std	Y+1, r24	; 0x01
    2fba:	89 81       	ldd	r24, Y+1	; 0x01
    2fbc:	82 30       	cpi	r24, 0x02	; 2
    2fbe:	50 f3       	brcs	.-44     	; 0x2f94 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    2fc0:	83 ee       	ldi	r24, 0xE3	; 227
    2fc2:	90 e0       	ldi	r25, 0x00	; 0
    2fc4:	0e 94 a0 18 	call	0x3140	; 0x3140 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    2fc8:	8c ee       	ldi	r24, 0xEC	; 236
    2fca:	90 e0       	ldi	r25, 0x00	; 0
    2fcc:	0e 94 a0 18 	call	0x3140	; 0x3140 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    2fd0:	89 ef       	ldi	r24, 0xF9	; 249
    2fd2:	90 e0       	ldi	r25, 0x00	; 0
    2fd4:	0e 94 a0 18 	call	0x3140	; 0x3140 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    2fd8:	83 ee       	ldi	r24, 0xE3	; 227
    2fda:	90 e0       	ldi	r25, 0x00	; 0
    2fdc:	90 93 f6 00 	sts	0x00F6, r25
    2fe0:	80 93 f5 00 	sts	0x00F5, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    2fe4:	8c ee       	ldi	r24, 0xEC	; 236
    2fe6:	90 e0       	ldi	r25, 0x00	; 0
    2fe8:	90 93 f8 00 	sts	0x00F8, r25
    2fec:	80 93 f7 00 	sts	0x00F7, r24
}
    2ff0:	0f 90       	pop	r0
    2ff2:	cf 91       	pop	r28
    2ff4:	df 91       	pop	r29
    2ff6:	08 95       	ret

00002ff8 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    2ff8:	df 93       	push	r29
    2ffa:	cf 93       	push	r28
    2ffc:	00 d0       	rcall	.+0      	; 0x2ffe <xCoRoutineRemoveFromEventList+0x6>
    2ffe:	00 d0       	rcall	.+0      	; 0x3000 <xCoRoutineRemoveFromEventList+0x8>
    3000:	0f 92       	push	r0
    3002:	cd b7       	in	r28, 0x3d	; 61
    3004:	de b7       	in	r29, 0x3e	; 62
    3006:	9d 83       	std	Y+5, r25	; 0x05
    3008:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    300a:	ec 81       	ldd	r30, Y+4	; 0x04
    300c:	fd 81       	ldd	r31, Y+5	; 0x05
    300e:	05 80       	ldd	r0, Z+5	; 0x05
    3010:	f6 81       	ldd	r31, Z+6	; 0x06
    3012:	e0 2d       	mov	r30, r0
    3014:	86 81       	ldd	r24, Z+6	; 0x06
    3016:	97 81       	ldd	r25, Z+7	; 0x07
    3018:	9b 83       	std	Y+3, r25	; 0x03
    301a:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    301c:	8a 81       	ldd	r24, Y+2	; 0x02
    301e:	9b 81       	ldd	r25, Y+3	; 0x03
    3020:	0c 96       	adiw	r24, 0x0c	; 12
    3022:	0e 94 92 19 	call	0x3324	; 0x3324 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    3026:	8a 81       	ldd	r24, Y+2	; 0x02
    3028:	9b 81       	ldd	r25, Y+3	; 0x03
    302a:	9c 01       	movw	r18, r24
    302c:	24 5f       	subi	r18, 0xF4	; 244
    302e:	3f 4f       	sbci	r19, 0xFF	; 255
    3030:	89 ef       	ldi	r24, 0xF9	; 249
    3032:	90 e0       	ldi	r25, 0x00	; 0
    3034:	b9 01       	movw	r22, r18
    3036:	0e 94 da 18 	call	0x31b4	; 0x31b4 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    303a:	ea 81       	ldd	r30, Y+2	; 0x02
    303c:	fb 81       	ldd	r31, Y+3	; 0x03
    303e:	96 89       	ldd	r25, Z+22	; 0x16
    3040:	e0 91 c8 00 	lds	r30, 0x00C8
    3044:	f0 91 c9 00 	lds	r31, 0x00C9
    3048:	86 89       	ldd	r24, Z+22	; 0x16
    304a:	98 17       	cp	r25, r24
    304c:	18 f0       	brcs	.+6      	; 0x3054 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    304e:	81 e0       	ldi	r24, 0x01	; 1
    3050:	89 83       	std	Y+1, r24	; 0x01
    3052:	01 c0       	rjmp	.+2      	; 0x3056 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    3054:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3056:	89 81       	ldd	r24, Y+1	; 0x01
}
    3058:	0f 90       	pop	r0
    305a:	0f 90       	pop	r0
    305c:	0f 90       	pop	r0
    305e:	0f 90       	pop	r0
    3060:	0f 90       	pop	r0
    3062:	cf 91       	pop	r28
    3064:	df 91       	pop	r29
    3066:	08 95       	ret

00003068 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    3068:	df 93       	push	r29
    306a:	cf 93       	push	r28
    306c:	00 d0       	rcall	.+0      	; 0x306e <pvPortMalloc+0x6>
    306e:	00 d0       	rcall	.+0      	; 0x3070 <pvPortMalloc+0x8>
    3070:	cd b7       	in	r28, 0x3d	; 61
    3072:	de b7       	in	r29, 0x3e	; 62
    3074:	9c 83       	std	Y+4, r25	; 0x04
    3076:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    3078:	1a 82       	std	Y+2, r1	; 0x02
    307a:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    307c:	0e 94 e8 24 	call	0x49d0	; 0x49d0 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    3080:	80 91 02 01 	lds	r24, 0x0102
    3084:	90 91 03 01 	lds	r25, 0x0103
    3088:	2b 81       	ldd	r18, Y+3	; 0x03
    308a:	3c 81       	ldd	r19, Y+4	; 0x04
    308c:	82 0f       	add	r24, r18
    308e:	93 1f       	adc	r25, r19
    3090:	23 e0       	ldi	r18, 0x03	; 3
    3092:	88 3e       	cpi	r24, 0xE8	; 232
    3094:	92 07       	cpc	r25, r18
    3096:	18 f5       	brcc	.+70     	; 0x30de <pvPortMalloc+0x76>
    3098:	20 91 02 01 	lds	r18, 0x0102
    309c:	30 91 03 01 	lds	r19, 0x0103
    30a0:	8b 81       	ldd	r24, Y+3	; 0x03
    30a2:	9c 81       	ldd	r25, Y+4	; 0x04
    30a4:	28 0f       	add	r18, r24
    30a6:	39 1f       	adc	r19, r25
    30a8:	80 91 02 01 	lds	r24, 0x0102
    30ac:	90 91 03 01 	lds	r25, 0x0103
    30b0:	82 17       	cp	r24, r18
    30b2:	93 07       	cpc	r25, r19
    30b4:	a0 f4       	brcc	.+40     	; 0x30de <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    30b6:	80 91 02 01 	lds	r24, 0x0102
    30ba:	90 91 03 01 	lds	r25, 0x0103
    30be:	8c 5f       	subi	r24, 0xFC	; 252
    30c0:	9e 4f       	sbci	r25, 0xFE	; 254
    30c2:	9a 83       	std	Y+2, r25	; 0x02
    30c4:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    30c6:	20 91 02 01 	lds	r18, 0x0102
    30ca:	30 91 03 01 	lds	r19, 0x0103
    30ce:	8b 81       	ldd	r24, Y+3	; 0x03
    30d0:	9c 81       	ldd	r25, Y+4	; 0x04
    30d2:	82 0f       	add	r24, r18
    30d4:	93 1f       	adc	r25, r19
    30d6:	90 93 03 01 	sts	0x0103, r25
    30da:	80 93 02 01 	sts	0x0102, r24
		}	
	}
	xTaskResumeAll();
    30de:	0e 94 f4 24 	call	0x49e8	; 0x49e8 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    30e2:	89 81       	ldd	r24, Y+1	; 0x01
    30e4:	9a 81       	ldd	r25, Y+2	; 0x02
}
    30e6:	0f 90       	pop	r0
    30e8:	0f 90       	pop	r0
    30ea:	0f 90       	pop	r0
    30ec:	0f 90       	pop	r0
    30ee:	cf 91       	pop	r28
    30f0:	df 91       	pop	r29
    30f2:	08 95       	ret

000030f4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    30f4:	df 93       	push	r29
    30f6:	cf 93       	push	r28
    30f8:	00 d0       	rcall	.+0      	; 0x30fa <vPortFree+0x6>
    30fa:	cd b7       	in	r28, 0x3d	; 61
    30fc:	de b7       	in	r29, 0x3e	; 62
    30fe:	9a 83       	std	Y+2, r25	; 0x02
    3100:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    3102:	0f 90       	pop	r0
    3104:	0f 90       	pop	r0
    3106:	cf 91       	pop	r28
    3108:	df 91       	pop	r29
    310a:	08 95       	ret

0000310c <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    310c:	df 93       	push	r29
    310e:	cf 93       	push	r28
    3110:	cd b7       	in	r28, 0x3d	; 61
    3112:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    3114:	10 92 03 01 	sts	0x0103, r1
    3118:	10 92 02 01 	sts	0x0102, r1
}
    311c:	cf 91       	pop	r28
    311e:	df 91       	pop	r29
    3120:	08 95       	ret

00003122 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    3122:	df 93       	push	r29
    3124:	cf 93       	push	r28
    3126:	cd b7       	in	r28, 0x3d	; 61
    3128:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    312a:	20 91 02 01 	lds	r18, 0x0102
    312e:	30 91 03 01 	lds	r19, 0x0103
    3132:	88 ee       	ldi	r24, 0xE8	; 232
    3134:	93 e0       	ldi	r25, 0x03	; 3
    3136:	82 1b       	sub	r24, r18
    3138:	93 0b       	sbc	r25, r19
}
    313a:	cf 91       	pop	r28
    313c:	df 91       	pop	r29
    313e:	08 95       	ret

00003140 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    3140:	df 93       	push	r29
    3142:	cf 93       	push	r28
    3144:	00 d0       	rcall	.+0      	; 0x3146 <vListInitialise+0x6>
    3146:	cd b7       	in	r28, 0x3d	; 61
    3148:	de b7       	in	r29, 0x3e	; 62
    314a:	9a 83       	std	Y+2, r25	; 0x02
    314c:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    314e:	89 81       	ldd	r24, Y+1	; 0x01
    3150:	9a 81       	ldd	r25, Y+2	; 0x02
    3152:	03 96       	adiw	r24, 0x03	; 3
    3154:	e9 81       	ldd	r30, Y+1	; 0x01
    3156:	fa 81       	ldd	r31, Y+2	; 0x02
    3158:	92 83       	std	Z+2, r25	; 0x02
    315a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    315c:	e9 81       	ldd	r30, Y+1	; 0x01
    315e:	fa 81       	ldd	r31, Y+2	; 0x02
    3160:	8f ef       	ldi	r24, 0xFF	; 255
    3162:	9f ef       	ldi	r25, 0xFF	; 255
    3164:	94 83       	std	Z+4, r25	; 0x04
    3166:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    3168:	89 81       	ldd	r24, Y+1	; 0x01
    316a:	9a 81       	ldd	r25, Y+2	; 0x02
    316c:	03 96       	adiw	r24, 0x03	; 3
    316e:	e9 81       	ldd	r30, Y+1	; 0x01
    3170:	fa 81       	ldd	r31, Y+2	; 0x02
    3172:	96 83       	std	Z+6, r25	; 0x06
    3174:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    3176:	89 81       	ldd	r24, Y+1	; 0x01
    3178:	9a 81       	ldd	r25, Y+2	; 0x02
    317a:	03 96       	adiw	r24, 0x03	; 3
    317c:	e9 81       	ldd	r30, Y+1	; 0x01
    317e:	fa 81       	ldd	r31, Y+2	; 0x02
    3180:	90 87       	std	Z+8, r25	; 0x08
    3182:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    3184:	e9 81       	ldd	r30, Y+1	; 0x01
    3186:	fa 81       	ldd	r31, Y+2	; 0x02
    3188:	10 82       	st	Z, r1
}
    318a:	0f 90       	pop	r0
    318c:	0f 90       	pop	r0
    318e:	cf 91       	pop	r28
    3190:	df 91       	pop	r29
    3192:	08 95       	ret

00003194 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    3194:	df 93       	push	r29
    3196:	cf 93       	push	r28
    3198:	00 d0       	rcall	.+0      	; 0x319a <vListInitialiseItem+0x6>
    319a:	cd b7       	in	r28, 0x3d	; 61
    319c:	de b7       	in	r29, 0x3e	; 62
    319e:	9a 83       	std	Y+2, r25	; 0x02
    31a0:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    31a2:	e9 81       	ldd	r30, Y+1	; 0x01
    31a4:	fa 81       	ldd	r31, Y+2	; 0x02
    31a6:	11 86       	std	Z+9, r1	; 0x09
    31a8:	10 86       	std	Z+8, r1	; 0x08
}
    31aa:	0f 90       	pop	r0
    31ac:	0f 90       	pop	r0
    31ae:	cf 91       	pop	r28
    31b0:	df 91       	pop	r29
    31b2:	08 95       	ret

000031b4 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    31b4:	df 93       	push	r29
    31b6:	cf 93       	push	r28
    31b8:	00 d0       	rcall	.+0      	; 0x31ba <vListInsertEnd+0x6>
    31ba:	00 d0       	rcall	.+0      	; 0x31bc <vListInsertEnd+0x8>
    31bc:	00 d0       	rcall	.+0      	; 0x31be <vListInsertEnd+0xa>
    31be:	cd b7       	in	r28, 0x3d	; 61
    31c0:	de b7       	in	r29, 0x3e	; 62
    31c2:	9c 83       	std	Y+4, r25	; 0x04
    31c4:	8b 83       	std	Y+3, r24	; 0x03
    31c6:	7e 83       	std	Y+6, r23	; 0x06
    31c8:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    31ca:	eb 81       	ldd	r30, Y+3	; 0x03
    31cc:	fc 81       	ldd	r31, Y+4	; 0x04
    31ce:	81 81       	ldd	r24, Z+1	; 0x01
    31d0:	92 81       	ldd	r25, Z+2	; 0x02
    31d2:	9a 83       	std	Y+2, r25	; 0x02
    31d4:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    31d6:	e9 81       	ldd	r30, Y+1	; 0x01
    31d8:	fa 81       	ldd	r31, Y+2	; 0x02
    31da:	82 81       	ldd	r24, Z+2	; 0x02
    31dc:	93 81       	ldd	r25, Z+3	; 0x03
    31de:	ed 81       	ldd	r30, Y+5	; 0x05
    31e0:	fe 81       	ldd	r31, Y+6	; 0x06
    31e2:	93 83       	std	Z+3, r25	; 0x03
    31e4:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    31e6:	eb 81       	ldd	r30, Y+3	; 0x03
    31e8:	fc 81       	ldd	r31, Y+4	; 0x04
    31ea:	81 81       	ldd	r24, Z+1	; 0x01
    31ec:	92 81       	ldd	r25, Z+2	; 0x02
    31ee:	ed 81       	ldd	r30, Y+5	; 0x05
    31f0:	fe 81       	ldd	r31, Y+6	; 0x06
    31f2:	95 83       	std	Z+5, r25	; 0x05
    31f4:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    31f6:	e9 81       	ldd	r30, Y+1	; 0x01
    31f8:	fa 81       	ldd	r31, Y+2	; 0x02
    31fa:	02 80       	ldd	r0, Z+2	; 0x02
    31fc:	f3 81       	ldd	r31, Z+3	; 0x03
    31fe:	e0 2d       	mov	r30, r0
    3200:	8d 81       	ldd	r24, Y+5	; 0x05
    3202:	9e 81       	ldd	r25, Y+6	; 0x06
    3204:	95 83       	std	Z+5, r25	; 0x05
    3206:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    3208:	8d 81       	ldd	r24, Y+5	; 0x05
    320a:	9e 81       	ldd	r25, Y+6	; 0x06
    320c:	e9 81       	ldd	r30, Y+1	; 0x01
    320e:	fa 81       	ldd	r31, Y+2	; 0x02
    3210:	93 83       	std	Z+3, r25	; 0x03
    3212:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    3214:	8d 81       	ldd	r24, Y+5	; 0x05
    3216:	9e 81       	ldd	r25, Y+6	; 0x06
    3218:	eb 81       	ldd	r30, Y+3	; 0x03
    321a:	fc 81       	ldd	r31, Y+4	; 0x04
    321c:	92 83       	std	Z+2, r25	; 0x02
    321e:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    3220:	ed 81       	ldd	r30, Y+5	; 0x05
    3222:	fe 81       	ldd	r31, Y+6	; 0x06
    3224:	8b 81       	ldd	r24, Y+3	; 0x03
    3226:	9c 81       	ldd	r25, Y+4	; 0x04
    3228:	91 87       	std	Z+9, r25	; 0x09
    322a:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    322c:	eb 81       	ldd	r30, Y+3	; 0x03
    322e:	fc 81       	ldd	r31, Y+4	; 0x04
    3230:	80 81       	ld	r24, Z
    3232:	8f 5f       	subi	r24, 0xFF	; 255
    3234:	eb 81       	ldd	r30, Y+3	; 0x03
    3236:	fc 81       	ldd	r31, Y+4	; 0x04
    3238:	80 83       	st	Z, r24
}
    323a:	26 96       	adiw	r28, 0x06	; 6
    323c:	0f b6       	in	r0, 0x3f	; 63
    323e:	f8 94       	cli
    3240:	de bf       	out	0x3e, r29	; 62
    3242:	0f be       	out	0x3f, r0	; 63
    3244:	cd bf       	out	0x3d, r28	; 61
    3246:	cf 91       	pop	r28
    3248:	df 91       	pop	r29
    324a:	08 95       	ret

0000324c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    324c:	df 93       	push	r29
    324e:	cf 93       	push	r28
    3250:	cd b7       	in	r28, 0x3d	; 61
    3252:	de b7       	in	r29, 0x3e	; 62
    3254:	28 97       	sbiw	r28, 0x08	; 8
    3256:	0f b6       	in	r0, 0x3f	; 63
    3258:	f8 94       	cli
    325a:	de bf       	out	0x3e, r29	; 62
    325c:	0f be       	out	0x3f, r0	; 63
    325e:	cd bf       	out	0x3d, r28	; 61
    3260:	9e 83       	std	Y+6, r25	; 0x06
    3262:	8d 83       	std	Y+5, r24	; 0x05
    3264:	78 87       	std	Y+8, r23	; 0x08
    3266:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    3268:	ef 81       	ldd	r30, Y+7	; 0x07
    326a:	f8 85       	ldd	r31, Y+8	; 0x08
    326c:	80 81       	ld	r24, Z
    326e:	91 81       	ldd	r25, Z+1	; 0x01
    3270:	9a 83       	std	Y+2, r25	; 0x02
    3272:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    3274:	89 81       	ldd	r24, Y+1	; 0x01
    3276:	9a 81       	ldd	r25, Y+2	; 0x02
    3278:	2f ef       	ldi	r18, 0xFF	; 255
    327a:	8f 3f       	cpi	r24, 0xFF	; 255
    327c:	92 07       	cpc	r25, r18
    327e:	39 f4       	brne	.+14     	; 0x328e <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    3280:	ed 81       	ldd	r30, Y+5	; 0x05
    3282:	fe 81       	ldd	r31, Y+6	; 0x06
    3284:	87 81       	ldd	r24, Z+7	; 0x07
    3286:	90 85       	ldd	r25, Z+8	; 0x08
    3288:	9c 83       	std	Y+4, r25	; 0x04
    328a:	8b 83       	std	Y+3, r24	; 0x03
    328c:	18 c0       	rjmp	.+48     	; 0x32be <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    328e:	8d 81       	ldd	r24, Y+5	; 0x05
    3290:	9e 81       	ldd	r25, Y+6	; 0x06
    3292:	03 96       	adiw	r24, 0x03	; 3
    3294:	9c 83       	std	Y+4, r25	; 0x04
    3296:	8b 83       	std	Y+3, r24	; 0x03
    3298:	06 c0       	rjmp	.+12     	; 0x32a6 <vListInsert+0x5a>
    329a:	eb 81       	ldd	r30, Y+3	; 0x03
    329c:	fc 81       	ldd	r31, Y+4	; 0x04
    329e:	82 81       	ldd	r24, Z+2	; 0x02
    32a0:	93 81       	ldd	r25, Z+3	; 0x03
    32a2:	9c 83       	std	Y+4, r25	; 0x04
    32a4:	8b 83       	std	Y+3, r24	; 0x03
    32a6:	eb 81       	ldd	r30, Y+3	; 0x03
    32a8:	fc 81       	ldd	r31, Y+4	; 0x04
    32aa:	02 80       	ldd	r0, Z+2	; 0x02
    32ac:	f3 81       	ldd	r31, Z+3	; 0x03
    32ae:	e0 2d       	mov	r30, r0
    32b0:	20 81       	ld	r18, Z
    32b2:	31 81       	ldd	r19, Z+1	; 0x01
    32b4:	89 81       	ldd	r24, Y+1	; 0x01
    32b6:	9a 81       	ldd	r25, Y+2	; 0x02
    32b8:	82 17       	cp	r24, r18
    32ba:	93 07       	cpc	r25, r19
    32bc:	70 f7       	brcc	.-36     	; 0x329a <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    32be:	eb 81       	ldd	r30, Y+3	; 0x03
    32c0:	fc 81       	ldd	r31, Y+4	; 0x04
    32c2:	82 81       	ldd	r24, Z+2	; 0x02
    32c4:	93 81       	ldd	r25, Z+3	; 0x03
    32c6:	ef 81       	ldd	r30, Y+7	; 0x07
    32c8:	f8 85       	ldd	r31, Y+8	; 0x08
    32ca:	93 83       	std	Z+3, r25	; 0x03
    32cc:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    32ce:	ef 81       	ldd	r30, Y+7	; 0x07
    32d0:	f8 85       	ldd	r31, Y+8	; 0x08
    32d2:	02 80       	ldd	r0, Z+2	; 0x02
    32d4:	f3 81       	ldd	r31, Z+3	; 0x03
    32d6:	e0 2d       	mov	r30, r0
    32d8:	8f 81       	ldd	r24, Y+7	; 0x07
    32da:	98 85       	ldd	r25, Y+8	; 0x08
    32dc:	95 83       	std	Z+5, r25	; 0x05
    32de:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    32e0:	ef 81       	ldd	r30, Y+7	; 0x07
    32e2:	f8 85       	ldd	r31, Y+8	; 0x08
    32e4:	8b 81       	ldd	r24, Y+3	; 0x03
    32e6:	9c 81       	ldd	r25, Y+4	; 0x04
    32e8:	95 83       	std	Z+5, r25	; 0x05
    32ea:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    32ec:	8f 81       	ldd	r24, Y+7	; 0x07
    32ee:	98 85       	ldd	r25, Y+8	; 0x08
    32f0:	eb 81       	ldd	r30, Y+3	; 0x03
    32f2:	fc 81       	ldd	r31, Y+4	; 0x04
    32f4:	93 83       	std	Z+3, r25	; 0x03
    32f6:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    32f8:	ef 81       	ldd	r30, Y+7	; 0x07
    32fa:	f8 85       	ldd	r31, Y+8	; 0x08
    32fc:	8d 81       	ldd	r24, Y+5	; 0x05
    32fe:	9e 81       	ldd	r25, Y+6	; 0x06
    3300:	91 87       	std	Z+9, r25	; 0x09
    3302:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    3304:	ed 81       	ldd	r30, Y+5	; 0x05
    3306:	fe 81       	ldd	r31, Y+6	; 0x06
    3308:	80 81       	ld	r24, Z
    330a:	8f 5f       	subi	r24, 0xFF	; 255
    330c:	ed 81       	ldd	r30, Y+5	; 0x05
    330e:	fe 81       	ldd	r31, Y+6	; 0x06
    3310:	80 83       	st	Z, r24
}
    3312:	28 96       	adiw	r28, 0x08	; 8
    3314:	0f b6       	in	r0, 0x3f	; 63
    3316:	f8 94       	cli
    3318:	de bf       	out	0x3e, r29	; 62
    331a:	0f be       	out	0x3f, r0	; 63
    331c:	cd bf       	out	0x3d, r28	; 61
    331e:	cf 91       	pop	r28
    3320:	df 91       	pop	r29
    3322:	08 95       	ret

00003324 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    3324:	df 93       	push	r29
    3326:	cf 93       	push	r28
    3328:	00 d0       	rcall	.+0      	; 0x332a <vListRemove+0x6>
    332a:	00 d0       	rcall	.+0      	; 0x332c <vListRemove+0x8>
    332c:	cd b7       	in	r28, 0x3d	; 61
    332e:	de b7       	in	r29, 0x3e	; 62
    3330:	9c 83       	std	Y+4, r25	; 0x04
    3332:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    3334:	eb 81       	ldd	r30, Y+3	; 0x03
    3336:	fc 81       	ldd	r31, Y+4	; 0x04
    3338:	a2 81       	ldd	r26, Z+2	; 0x02
    333a:	b3 81       	ldd	r27, Z+3	; 0x03
    333c:	eb 81       	ldd	r30, Y+3	; 0x03
    333e:	fc 81       	ldd	r31, Y+4	; 0x04
    3340:	84 81       	ldd	r24, Z+4	; 0x04
    3342:	95 81       	ldd	r25, Z+5	; 0x05
    3344:	15 96       	adiw	r26, 0x05	; 5
    3346:	9c 93       	st	X, r25
    3348:	8e 93       	st	-X, r24
    334a:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    334c:	eb 81       	ldd	r30, Y+3	; 0x03
    334e:	fc 81       	ldd	r31, Y+4	; 0x04
    3350:	a4 81       	ldd	r26, Z+4	; 0x04
    3352:	b5 81       	ldd	r27, Z+5	; 0x05
    3354:	eb 81       	ldd	r30, Y+3	; 0x03
    3356:	fc 81       	ldd	r31, Y+4	; 0x04
    3358:	82 81       	ldd	r24, Z+2	; 0x02
    335a:	93 81       	ldd	r25, Z+3	; 0x03
    335c:	13 96       	adiw	r26, 0x03	; 3
    335e:	9c 93       	st	X, r25
    3360:	8e 93       	st	-X, r24
    3362:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    3364:	eb 81       	ldd	r30, Y+3	; 0x03
    3366:	fc 81       	ldd	r31, Y+4	; 0x04
    3368:	80 85       	ldd	r24, Z+8	; 0x08
    336a:	91 85       	ldd	r25, Z+9	; 0x09
    336c:	9a 83       	std	Y+2, r25	; 0x02
    336e:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    3370:	e9 81       	ldd	r30, Y+1	; 0x01
    3372:	fa 81       	ldd	r31, Y+2	; 0x02
    3374:	21 81       	ldd	r18, Z+1	; 0x01
    3376:	32 81       	ldd	r19, Z+2	; 0x02
    3378:	8b 81       	ldd	r24, Y+3	; 0x03
    337a:	9c 81       	ldd	r25, Y+4	; 0x04
    337c:	28 17       	cp	r18, r24
    337e:	39 07       	cpc	r19, r25
    3380:	41 f4       	brne	.+16     	; 0x3392 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    3382:	eb 81       	ldd	r30, Y+3	; 0x03
    3384:	fc 81       	ldd	r31, Y+4	; 0x04
    3386:	84 81       	ldd	r24, Z+4	; 0x04
    3388:	95 81       	ldd	r25, Z+5	; 0x05
    338a:	e9 81       	ldd	r30, Y+1	; 0x01
    338c:	fa 81       	ldd	r31, Y+2	; 0x02
    338e:	92 83       	std	Z+2, r25	; 0x02
    3390:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    3392:	eb 81       	ldd	r30, Y+3	; 0x03
    3394:	fc 81       	ldd	r31, Y+4	; 0x04
    3396:	11 86       	std	Z+9, r1	; 0x09
    3398:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    339a:	e9 81       	ldd	r30, Y+1	; 0x01
    339c:	fa 81       	ldd	r31, Y+2	; 0x02
    339e:	80 81       	ld	r24, Z
    33a0:	81 50       	subi	r24, 0x01	; 1
    33a2:	e9 81       	ldd	r30, Y+1	; 0x01
    33a4:	fa 81       	ldd	r31, Y+2	; 0x02
    33a6:	80 83       	st	Z, r24
}
    33a8:	0f 90       	pop	r0
    33aa:	0f 90       	pop	r0
    33ac:	0f 90       	pop	r0
    33ae:	0f 90       	pop	r0
    33b0:	cf 91       	pop	r28
    33b2:	df 91       	pop	r29
    33b4:	08 95       	ret

000033b6 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    33b6:	df 93       	push	r29
    33b8:	cf 93       	push	r28
    33ba:	cd b7       	in	r28, 0x3d	; 61
    33bc:	de b7       	in	r29, 0x3e	; 62
    33be:	28 97       	sbiw	r28, 0x08	; 8
    33c0:	0f b6       	in	r0, 0x3f	; 63
    33c2:	f8 94       	cli
    33c4:	de bf       	out	0x3e, r29	; 62
    33c6:	0f be       	out	0x3f, r0	; 63
    33c8:	cd bf       	out	0x3d, r28	; 61
    33ca:	9c 83       	std	Y+4, r25	; 0x04
    33cc:	8b 83       	std	Y+3, r24	; 0x03
    33ce:	7e 83       	std	Y+6, r23	; 0x06
    33d0:	6d 83       	std	Y+5, r22	; 0x05
    33d2:	58 87       	std	Y+8, r21	; 0x08
    33d4:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    33d6:	eb 81       	ldd	r30, Y+3	; 0x03
    33d8:	fc 81       	ldd	r31, Y+4	; 0x04
    33da:	81 e1       	ldi	r24, 0x11	; 17
    33dc:	80 83       	st	Z, r24
	pxTopOfStack--;
    33de:	8b 81       	ldd	r24, Y+3	; 0x03
    33e0:	9c 81       	ldd	r25, Y+4	; 0x04
    33e2:	01 97       	sbiw	r24, 0x01	; 1
    33e4:	9c 83       	std	Y+4, r25	; 0x04
    33e6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    33e8:	eb 81       	ldd	r30, Y+3	; 0x03
    33ea:	fc 81       	ldd	r31, Y+4	; 0x04
    33ec:	82 e2       	ldi	r24, 0x22	; 34
    33ee:	80 83       	st	Z, r24
	pxTopOfStack--;
    33f0:	8b 81       	ldd	r24, Y+3	; 0x03
    33f2:	9c 81       	ldd	r25, Y+4	; 0x04
    33f4:	01 97       	sbiw	r24, 0x01	; 1
    33f6:	9c 83       	std	Y+4, r25	; 0x04
    33f8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    33fa:	eb 81       	ldd	r30, Y+3	; 0x03
    33fc:	fc 81       	ldd	r31, Y+4	; 0x04
    33fe:	83 e3       	ldi	r24, 0x33	; 51
    3400:	80 83       	st	Z, r24
	pxTopOfStack--;
    3402:	8b 81       	ldd	r24, Y+3	; 0x03
    3404:	9c 81       	ldd	r25, Y+4	; 0x04
    3406:	01 97       	sbiw	r24, 0x01	; 1
    3408:	9c 83       	std	Y+4, r25	; 0x04
    340a:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    340c:	8d 81       	ldd	r24, Y+5	; 0x05
    340e:	9e 81       	ldd	r25, Y+6	; 0x06
    3410:	9a 83       	std	Y+2, r25	; 0x02
    3412:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    3414:	89 81       	ldd	r24, Y+1	; 0x01
    3416:	eb 81       	ldd	r30, Y+3	; 0x03
    3418:	fc 81       	ldd	r31, Y+4	; 0x04
    341a:	80 83       	st	Z, r24
	pxTopOfStack--;
    341c:	8b 81       	ldd	r24, Y+3	; 0x03
    341e:	9c 81       	ldd	r25, Y+4	; 0x04
    3420:	01 97       	sbiw	r24, 0x01	; 1
    3422:	9c 83       	std	Y+4, r25	; 0x04
    3424:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    3426:	89 81       	ldd	r24, Y+1	; 0x01
    3428:	9a 81       	ldd	r25, Y+2	; 0x02
    342a:	89 2f       	mov	r24, r25
    342c:	99 27       	eor	r25, r25
    342e:	9a 83       	std	Y+2, r25	; 0x02
    3430:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    3432:	89 81       	ldd	r24, Y+1	; 0x01
    3434:	eb 81       	ldd	r30, Y+3	; 0x03
    3436:	fc 81       	ldd	r31, Y+4	; 0x04
    3438:	80 83       	st	Z, r24
	pxTopOfStack--;
    343a:	8b 81       	ldd	r24, Y+3	; 0x03
    343c:	9c 81       	ldd	r25, Y+4	; 0x04
    343e:	01 97       	sbiw	r24, 0x01	; 1
    3440:	9c 83       	std	Y+4, r25	; 0x04
    3442:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    3444:	eb 81       	ldd	r30, Y+3	; 0x03
    3446:	fc 81       	ldd	r31, Y+4	; 0x04
    3448:	10 82       	st	Z, r1
	pxTopOfStack--;
    344a:	8b 81       	ldd	r24, Y+3	; 0x03
    344c:	9c 81       	ldd	r25, Y+4	; 0x04
    344e:	01 97       	sbiw	r24, 0x01	; 1
    3450:	9c 83       	std	Y+4, r25	; 0x04
    3452:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    3454:	eb 81       	ldd	r30, Y+3	; 0x03
    3456:	fc 81       	ldd	r31, Y+4	; 0x04
    3458:	80 e8       	ldi	r24, 0x80	; 128
    345a:	80 83       	st	Z, r24
	pxTopOfStack--;
    345c:	8b 81       	ldd	r24, Y+3	; 0x03
    345e:	9c 81       	ldd	r25, Y+4	; 0x04
    3460:	01 97       	sbiw	r24, 0x01	; 1
    3462:	9c 83       	std	Y+4, r25	; 0x04
    3464:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    3466:	eb 81       	ldd	r30, Y+3	; 0x03
    3468:	fc 81       	ldd	r31, Y+4	; 0x04
    346a:	10 82       	st	Z, r1
	pxTopOfStack--;
    346c:	8b 81       	ldd	r24, Y+3	; 0x03
    346e:	9c 81       	ldd	r25, Y+4	; 0x04
    3470:	01 97       	sbiw	r24, 0x01	; 1
    3472:	9c 83       	std	Y+4, r25	; 0x04
    3474:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    3476:	eb 81       	ldd	r30, Y+3	; 0x03
    3478:	fc 81       	ldd	r31, Y+4	; 0x04
    347a:	82 e0       	ldi	r24, 0x02	; 2
    347c:	80 83       	st	Z, r24
	pxTopOfStack--;
    347e:	8b 81       	ldd	r24, Y+3	; 0x03
    3480:	9c 81       	ldd	r25, Y+4	; 0x04
    3482:	01 97       	sbiw	r24, 0x01	; 1
    3484:	9c 83       	std	Y+4, r25	; 0x04
    3486:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    3488:	eb 81       	ldd	r30, Y+3	; 0x03
    348a:	fc 81       	ldd	r31, Y+4	; 0x04
    348c:	83 e0       	ldi	r24, 0x03	; 3
    348e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3490:	8b 81       	ldd	r24, Y+3	; 0x03
    3492:	9c 81       	ldd	r25, Y+4	; 0x04
    3494:	01 97       	sbiw	r24, 0x01	; 1
    3496:	9c 83       	std	Y+4, r25	; 0x04
    3498:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    349a:	eb 81       	ldd	r30, Y+3	; 0x03
    349c:	fc 81       	ldd	r31, Y+4	; 0x04
    349e:	84 e0       	ldi	r24, 0x04	; 4
    34a0:	80 83       	st	Z, r24
	pxTopOfStack--;
    34a2:	8b 81       	ldd	r24, Y+3	; 0x03
    34a4:	9c 81       	ldd	r25, Y+4	; 0x04
    34a6:	01 97       	sbiw	r24, 0x01	; 1
    34a8:	9c 83       	std	Y+4, r25	; 0x04
    34aa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    34ac:	eb 81       	ldd	r30, Y+3	; 0x03
    34ae:	fc 81       	ldd	r31, Y+4	; 0x04
    34b0:	85 e0       	ldi	r24, 0x05	; 5
    34b2:	80 83       	st	Z, r24
	pxTopOfStack--;
    34b4:	8b 81       	ldd	r24, Y+3	; 0x03
    34b6:	9c 81       	ldd	r25, Y+4	; 0x04
    34b8:	01 97       	sbiw	r24, 0x01	; 1
    34ba:	9c 83       	std	Y+4, r25	; 0x04
    34bc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    34be:	eb 81       	ldd	r30, Y+3	; 0x03
    34c0:	fc 81       	ldd	r31, Y+4	; 0x04
    34c2:	86 e0       	ldi	r24, 0x06	; 6
    34c4:	80 83       	st	Z, r24
	pxTopOfStack--;
    34c6:	8b 81       	ldd	r24, Y+3	; 0x03
    34c8:	9c 81       	ldd	r25, Y+4	; 0x04
    34ca:	01 97       	sbiw	r24, 0x01	; 1
    34cc:	9c 83       	std	Y+4, r25	; 0x04
    34ce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    34d0:	eb 81       	ldd	r30, Y+3	; 0x03
    34d2:	fc 81       	ldd	r31, Y+4	; 0x04
    34d4:	87 e0       	ldi	r24, 0x07	; 7
    34d6:	80 83       	st	Z, r24
	pxTopOfStack--;
    34d8:	8b 81       	ldd	r24, Y+3	; 0x03
    34da:	9c 81       	ldd	r25, Y+4	; 0x04
    34dc:	01 97       	sbiw	r24, 0x01	; 1
    34de:	9c 83       	std	Y+4, r25	; 0x04
    34e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    34e2:	eb 81       	ldd	r30, Y+3	; 0x03
    34e4:	fc 81       	ldd	r31, Y+4	; 0x04
    34e6:	88 e0       	ldi	r24, 0x08	; 8
    34e8:	80 83       	st	Z, r24
	pxTopOfStack--;
    34ea:	8b 81       	ldd	r24, Y+3	; 0x03
    34ec:	9c 81       	ldd	r25, Y+4	; 0x04
    34ee:	01 97       	sbiw	r24, 0x01	; 1
    34f0:	9c 83       	std	Y+4, r25	; 0x04
    34f2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    34f4:	eb 81       	ldd	r30, Y+3	; 0x03
    34f6:	fc 81       	ldd	r31, Y+4	; 0x04
    34f8:	89 e0       	ldi	r24, 0x09	; 9
    34fa:	80 83       	st	Z, r24
	pxTopOfStack--;
    34fc:	8b 81       	ldd	r24, Y+3	; 0x03
    34fe:	9c 81       	ldd	r25, Y+4	; 0x04
    3500:	01 97       	sbiw	r24, 0x01	; 1
    3502:	9c 83       	std	Y+4, r25	; 0x04
    3504:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    3506:	eb 81       	ldd	r30, Y+3	; 0x03
    3508:	fc 81       	ldd	r31, Y+4	; 0x04
    350a:	80 e1       	ldi	r24, 0x10	; 16
    350c:	80 83       	st	Z, r24
	pxTopOfStack--;
    350e:	8b 81       	ldd	r24, Y+3	; 0x03
    3510:	9c 81       	ldd	r25, Y+4	; 0x04
    3512:	01 97       	sbiw	r24, 0x01	; 1
    3514:	9c 83       	std	Y+4, r25	; 0x04
    3516:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    3518:	eb 81       	ldd	r30, Y+3	; 0x03
    351a:	fc 81       	ldd	r31, Y+4	; 0x04
    351c:	81 e1       	ldi	r24, 0x11	; 17
    351e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3520:	8b 81       	ldd	r24, Y+3	; 0x03
    3522:	9c 81       	ldd	r25, Y+4	; 0x04
    3524:	01 97       	sbiw	r24, 0x01	; 1
    3526:	9c 83       	std	Y+4, r25	; 0x04
    3528:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    352a:	eb 81       	ldd	r30, Y+3	; 0x03
    352c:	fc 81       	ldd	r31, Y+4	; 0x04
    352e:	82 e1       	ldi	r24, 0x12	; 18
    3530:	80 83       	st	Z, r24
	pxTopOfStack--;
    3532:	8b 81       	ldd	r24, Y+3	; 0x03
    3534:	9c 81       	ldd	r25, Y+4	; 0x04
    3536:	01 97       	sbiw	r24, 0x01	; 1
    3538:	9c 83       	std	Y+4, r25	; 0x04
    353a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    353c:	eb 81       	ldd	r30, Y+3	; 0x03
    353e:	fc 81       	ldd	r31, Y+4	; 0x04
    3540:	83 e1       	ldi	r24, 0x13	; 19
    3542:	80 83       	st	Z, r24
	pxTopOfStack--;
    3544:	8b 81       	ldd	r24, Y+3	; 0x03
    3546:	9c 81       	ldd	r25, Y+4	; 0x04
    3548:	01 97       	sbiw	r24, 0x01	; 1
    354a:	9c 83       	std	Y+4, r25	; 0x04
    354c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    354e:	eb 81       	ldd	r30, Y+3	; 0x03
    3550:	fc 81       	ldd	r31, Y+4	; 0x04
    3552:	84 e1       	ldi	r24, 0x14	; 20
    3554:	80 83       	st	Z, r24
	pxTopOfStack--;
    3556:	8b 81       	ldd	r24, Y+3	; 0x03
    3558:	9c 81       	ldd	r25, Y+4	; 0x04
    355a:	01 97       	sbiw	r24, 0x01	; 1
    355c:	9c 83       	std	Y+4, r25	; 0x04
    355e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    3560:	eb 81       	ldd	r30, Y+3	; 0x03
    3562:	fc 81       	ldd	r31, Y+4	; 0x04
    3564:	85 e1       	ldi	r24, 0x15	; 21
    3566:	80 83       	st	Z, r24
	pxTopOfStack--;
    3568:	8b 81       	ldd	r24, Y+3	; 0x03
    356a:	9c 81       	ldd	r25, Y+4	; 0x04
    356c:	01 97       	sbiw	r24, 0x01	; 1
    356e:	9c 83       	std	Y+4, r25	; 0x04
    3570:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    3572:	eb 81       	ldd	r30, Y+3	; 0x03
    3574:	fc 81       	ldd	r31, Y+4	; 0x04
    3576:	86 e1       	ldi	r24, 0x16	; 22
    3578:	80 83       	st	Z, r24
	pxTopOfStack--;
    357a:	8b 81       	ldd	r24, Y+3	; 0x03
    357c:	9c 81       	ldd	r25, Y+4	; 0x04
    357e:	01 97       	sbiw	r24, 0x01	; 1
    3580:	9c 83       	std	Y+4, r25	; 0x04
    3582:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    3584:	eb 81       	ldd	r30, Y+3	; 0x03
    3586:	fc 81       	ldd	r31, Y+4	; 0x04
    3588:	87 e1       	ldi	r24, 0x17	; 23
    358a:	80 83       	st	Z, r24
	pxTopOfStack--;
    358c:	8b 81       	ldd	r24, Y+3	; 0x03
    358e:	9c 81       	ldd	r25, Y+4	; 0x04
    3590:	01 97       	sbiw	r24, 0x01	; 1
    3592:	9c 83       	std	Y+4, r25	; 0x04
    3594:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    3596:	eb 81       	ldd	r30, Y+3	; 0x03
    3598:	fc 81       	ldd	r31, Y+4	; 0x04
    359a:	88 e1       	ldi	r24, 0x18	; 24
    359c:	80 83       	st	Z, r24
	pxTopOfStack--;
    359e:	8b 81       	ldd	r24, Y+3	; 0x03
    35a0:	9c 81       	ldd	r25, Y+4	; 0x04
    35a2:	01 97       	sbiw	r24, 0x01	; 1
    35a4:	9c 83       	std	Y+4, r25	; 0x04
    35a6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    35a8:	eb 81       	ldd	r30, Y+3	; 0x03
    35aa:	fc 81       	ldd	r31, Y+4	; 0x04
    35ac:	89 e1       	ldi	r24, 0x19	; 25
    35ae:	80 83       	st	Z, r24
	pxTopOfStack--;
    35b0:	8b 81       	ldd	r24, Y+3	; 0x03
    35b2:	9c 81       	ldd	r25, Y+4	; 0x04
    35b4:	01 97       	sbiw	r24, 0x01	; 1
    35b6:	9c 83       	std	Y+4, r25	; 0x04
    35b8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    35ba:	eb 81       	ldd	r30, Y+3	; 0x03
    35bc:	fc 81       	ldd	r31, Y+4	; 0x04
    35be:	80 e2       	ldi	r24, 0x20	; 32
    35c0:	80 83       	st	Z, r24
	pxTopOfStack--;
    35c2:	8b 81       	ldd	r24, Y+3	; 0x03
    35c4:	9c 81       	ldd	r25, Y+4	; 0x04
    35c6:	01 97       	sbiw	r24, 0x01	; 1
    35c8:	9c 83       	std	Y+4, r25	; 0x04
    35ca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    35cc:	eb 81       	ldd	r30, Y+3	; 0x03
    35ce:	fc 81       	ldd	r31, Y+4	; 0x04
    35d0:	81 e2       	ldi	r24, 0x21	; 33
    35d2:	80 83       	st	Z, r24
	pxTopOfStack--;
    35d4:	8b 81       	ldd	r24, Y+3	; 0x03
    35d6:	9c 81       	ldd	r25, Y+4	; 0x04
    35d8:	01 97       	sbiw	r24, 0x01	; 1
    35da:	9c 83       	std	Y+4, r25	; 0x04
    35dc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    35de:	eb 81       	ldd	r30, Y+3	; 0x03
    35e0:	fc 81       	ldd	r31, Y+4	; 0x04
    35e2:	82 e2       	ldi	r24, 0x22	; 34
    35e4:	80 83       	st	Z, r24
	pxTopOfStack--;
    35e6:	8b 81       	ldd	r24, Y+3	; 0x03
    35e8:	9c 81       	ldd	r25, Y+4	; 0x04
    35ea:	01 97       	sbiw	r24, 0x01	; 1
    35ec:	9c 83       	std	Y+4, r25	; 0x04
    35ee:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    35f0:	eb 81       	ldd	r30, Y+3	; 0x03
    35f2:	fc 81       	ldd	r31, Y+4	; 0x04
    35f4:	83 e2       	ldi	r24, 0x23	; 35
    35f6:	80 83       	st	Z, r24
	pxTopOfStack--;
    35f8:	8b 81       	ldd	r24, Y+3	; 0x03
    35fa:	9c 81       	ldd	r25, Y+4	; 0x04
    35fc:	01 97       	sbiw	r24, 0x01	; 1
    35fe:	9c 83       	std	Y+4, r25	; 0x04
    3600:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    3602:	8f 81       	ldd	r24, Y+7	; 0x07
    3604:	98 85       	ldd	r25, Y+8	; 0x08
    3606:	9a 83       	std	Y+2, r25	; 0x02
    3608:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    360a:	89 81       	ldd	r24, Y+1	; 0x01
    360c:	eb 81       	ldd	r30, Y+3	; 0x03
    360e:	fc 81       	ldd	r31, Y+4	; 0x04
    3610:	80 83       	st	Z, r24
	pxTopOfStack--;
    3612:	8b 81       	ldd	r24, Y+3	; 0x03
    3614:	9c 81       	ldd	r25, Y+4	; 0x04
    3616:	01 97       	sbiw	r24, 0x01	; 1
    3618:	9c 83       	std	Y+4, r25	; 0x04
    361a:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    361c:	89 81       	ldd	r24, Y+1	; 0x01
    361e:	9a 81       	ldd	r25, Y+2	; 0x02
    3620:	89 2f       	mov	r24, r25
    3622:	99 27       	eor	r25, r25
    3624:	9a 83       	std	Y+2, r25	; 0x02
    3626:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    3628:	89 81       	ldd	r24, Y+1	; 0x01
    362a:	eb 81       	ldd	r30, Y+3	; 0x03
    362c:	fc 81       	ldd	r31, Y+4	; 0x04
    362e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3630:	8b 81       	ldd	r24, Y+3	; 0x03
    3632:	9c 81       	ldd	r25, Y+4	; 0x04
    3634:	01 97       	sbiw	r24, 0x01	; 1
    3636:	9c 83       	std	Y+4, r25	; 0x04
    3638:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    363a:	eb 81       	ldd	r30, Y+3	; 0x03
    363c:	fc 81       	ldd	r31, Y+4	; 0x04
    363e:	86 e2       	ldi	r24, 0x26	; 38
    3640:	80 83       	st	Z, r24
	pxTopOfStack--;
    3642:	8b 81       	ldd	r24, Y+3	; 0x03
    3644:	9c 81       	ldd	r25, Y+4	; 0x04
    3646:	01 97       	sbiw	r24, 0x01	; 1
    3648:	9c 83       	std	Y+4, r25	; 0x04
    364a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    364c:	eb 81       	ldd	r30, Y+3	; 0x03
    364e:	fc 81       	ldd	r31, Y+4	; 0x04
    3650:	87 e2       	ldi	r24, 0x27	; 39
    3652:	80 83       	st	Z, r24
	pxTopOfStack--;
    3654:	8b 81       	ldd	r24, Y+3	; 0x03
    3656:	9c 81       	ldd	r25, Y+4	; 0x04
    3658:	01 97       	sbiw	r24, 0x01	; 1
    365a:	9c 83       	std	Y+4, r25	; 0x04
    365c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    365e:	eb 81       	ldd	r30, Y+3	; 0x03
    3660:	fc 81       	ldd	r31, Y+4	; 0x04
    3662:	88 e2       	ldi	r24, 0x28	; 40
    3664:	80 83       	st	Z, r24
	pxTopOfStack--;
    3666:	8b 81       	ldd	r24, Y+3	; 0x03
    3668:	9c 81       	ldd	r25, Y+4	; 0x04
    366a:	01 97       	sbiw	r24, 0x01	; 1
    366c:	9c 83       	std	Y+4, r25	; 0x04
    366e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    3670:	eb 81       	ldd	r30, Y+3	; 0x03
    3672:	fc 81       	ldd	r31, Y+4	; 0x04
    3674:	89 e2       	ldi	r24, 0x29	; 41
    3676:	80 83       	st	Z, r24
	pxTopOfStack--;
    3678:	8b 81       	ldd	r24, Y+3	; 0x03
    367a:	9c 81       	ldd	r25, Y+4	; 0x04
    367c:	01 97       	sbiw	r24, 0x01	; 1
    367e:	9c 83       	std	Y+4, r25	; 0x04
    3680:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    3682:	eb 81       	ldd	r30, Y+3	; 0x03
    3684:	fc 81       	ldd	r31, Y+4	; 0x04
    3686:	80 e3       	ldi	r24, 0x30	; 48
    3688:	80 83       	st	Z, r24
	pxTopOfStack--;
    368a:	8b 81       	ldd	r24, Y+3	; 0x03
    368c:	9c 81       	ldd	r25, Y+4	; 0x04
    368e:	01 97       	sbiw	r24, 0x01	; 1
    3690:	9c 83       	std	Y+4, r25	; 0x04
    3692:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    3694:	eb 81       	ldd	r30, Y+3	; 0x03
    3696:	fc 81       	ldd	r31, Y+4	; 0x04
    3698:	81 e3       	ldi	r24, 0x31	; 49
    369a:	80 83       	st	Z, r24
	pxTopOfStack--;
    369c:	8b 81       	ldd	r24, Y+3	; 0x03
    369e:	9c 81       	ldd	r25, Y+4	; 0x04
    36a0:	01 97       	sbiw	r24, 0x01	; 1
    36a2:	9c 83       	std	Y+4, r25	; 0x04
    36a4:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    36a6:	8b 81       	ldd	r24, Y+3	; 0x03
    36a8:	9c 81       	ldd	r25, Y+4	; 0x04
}
    36aa:	28 96       	adiw	r28, 0x08	; 8
    36ac:	0f b6       	in	r0, 0x3f	; 63
    36ae:	f8 94       	cli
    36b0:	de bf       	out	0x3e, r29	; 62
    36b2:	0f be       	out	0x3f, r0	; 63
    36b4:	cd bf       	out	0x3d, r28	; 61
    36b6:	cf 91       	pop	r28
    36b8:	df 91       	pop	r29
    36ba:	08 95       	ret

000036bc <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    36bc:	df 93       	push	r29
    36be:	cf 93       	push	r28
    36c0:	cd b7       	in	r28, 0x3d	; 61
    36c2:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    36c4:	0e 94 4e 1c 	call	0x389c	; 0x389c <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    36c8:	a0 91 ec 04 	lds	r26, 0x04EC
    36cc:	b0 91 ed 04 	lds	r27, 0x04ED
    36d0:	cd 91       	ld	r28, X+
    36d2:	cd bf       	out	0x3d, r28	; 61
    36d4:	dd 91       	ld	r29, X+
    36d6:	de bf       	out	0x3e, r29	; 62
    36d8:	ff 91       	pop	r31
    36da:	ef 91       	pop	r30
    36dc:	df 91       	pop	r29
    36de:	cf 91       	pop	r28
    36e0:	bf 91       	pop	r27
    36e2:	af 91       	pop	r26
    36e4:	9f 91       	pop	r25
    36e6:	8f 91       	pop	r24
    36e8:	7f 91       	pop	r23
    36ea:	6f 91       	pop	r22
    36ec:	5f 91       	pop	r21
    36ee:	4f 91       	pop	r20
    36f0:	3f 91       	pop	r19
    36f2:	2f 91       	pop	r18
    36f4:	1f 91       	pop	r17
    36f6:	0f 91       	pop	r16
    36f8:	ff 90       	pop	r15
    36fa:	ef 90       	pop	r14
    36fc:	df 90       	pop	r13
    36fe:	cf 90       	pop	r12
    3700:	bf 90       	pop	r11
    3702:	af 90       	pop	r10
    3704:	9f 90       	pop	r9
    3706:	8f 90       	pop	r8
    3708:	7f 90       	pop	r7
    370a:	6f 90       	pop	r6
    370c:	5f 90       	pop	r5
    370e:	4f 90       	pop	r4
    3710:	3f 90       	pop	r3
    3712:	2f 90       	pop	r2
    3714:	1f 90       	pop	r1
    3716:	0f 90       	pop	r0
    3718:	0f be       	out	0x3f, r0	; 63
    371a:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    371c:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    371e:	81 e0       	ldi	r24, 0x01	; 1
}
    3720:	cf 91       	pop	r28
    3722:	df 91       	pop	r29
    3724:	08 95       	ret

00003726 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    3726:	df 93       	push	r29
    3728:	cf 93       	push	r28
    372a:	cd b7       	in	r28, 0x3d	; 61
    372c:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    372e:	cf 91       	pop	r28
    3730:	df 91       	pop	r29
    3732:	08 95       	ret

00003734 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    3734:	0f 92       	push	r0
    3736:	0f b6       	in	r0, 0x3f	; 63
    3738:	f8 94       	cli
    373a:	0f 92       	push	r0
    373c:	1f 92       	push	r1
    373e:	11 24       	eor	r1, r1
    3740:	2f 92       	push	r2
    3742:	3f 92       	push	r3
    3744:	4f 92       	push	r4
    3746:	5f 92       	push	r5
    3748:	6f 92       	push	r6
    374a:	7f 92       	push	r7
    374c:	8f 92       	push	r8
    374e:	9f 92       	push	r9
    3750:	af 92       	push	r10
    3752:	bf 92       	push	r11
    3754:	cf 92       	push	r12
    3756:	df 92       	push	r13
    3758:	ef 92       	push	r14
    375a:	ff 92       	push	r15
    375c:	0f 93       	push	r16
    375e:	1f 93       	push	r17
    3760:	2f 93       	push	r18
    3762:	3f 93       	push	r19
    3764:	4f 93       	push	r20
    3766:	5f 93       	push	r21
    3768:	6f 93       	push	r22
    376a:	7f 93       	push	r23
    376c:	8f 93       	push	r24
    376e:	9f 93       	push	r25
    3770:	af 93       	push	r26
    3772:	bf 93       	push	r27
    3774:	cf 93       	push	r28
    3776:	df 93       	push	r29
    3778:	ef 93       	push	r30
    377a:	ff 93       	push	r31
    377c:	a0 91 ec 04 	lds	r26, 0x04EC
    3780:	b0 91 ed 04 	lds	r27, 0x04ED
    3784:	0d b6       	in	r0, 0x3d	; 61
    3786:	0d 92       	st	X+, r0
    3788:	0e b6       	in	r0, 0x3e	; 62
    378a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    378c:	0e 94 88 26 	call	0x4d10	; 0x4d10 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3790:	a0 91 ec 04 	lds	r26, 0x04EC
    3794:	b0 91 ed 04 	lds	r27, 0x04ED
    3798:	cd 91       	ld	r28, X+
    379a:	cd bf       	out	0x3d, r28	; 61
    379c:	dd 91       	ld	r29, X+
    379e:	de bf       	out	0x3e, r29	; 62
    37a0:	ff 91       	pop	r31
    37a2:	ef 91       	pop	r30
    37a4:	df 91       	pop	r29
    37a6:	cf 91       	pop	r28
    37a8:	bf 91       	pop	r27
    37aa:	af 91       	pop	r26
    37ac:	9f 91       	pop	r25
    37ae:	8f 91       	pop	r24
    37b0:	7f 91       	pop	r23
    37b2:	6f 91       	pop	r22
    37b4:	5f 91       	pop	r21
    37b6:	4f 91       	pop	r20
    37b8:	3f 91       	pop	r19
    37ba:	2f 91       	pop	r18
    37bc:	1f 91       	pop	r17
    37be:	0f 91       	pop	r16
    37c0:	ff 90       	pop	r15
    37c2:	ef 90       	pop	r14
    37c4:	df 90       	pop	r13
    37c6:	cf 90       	pop	r12
    37c8:	bf 90       	pop	r11
    37ca:	af 90       	pop	r10
    37cc:	9f 90       	pop	r9
    37ce:	8f 90       	pop	r8
    37d0:	7f 90       	pop	r7
    37d2:	6f 90       	pop	r6
    37d4:	5f 90       	pop	r5
    37d6:	4f 90       	pop	r4
    37d8:	3f 90       	pop	r3
    37da:	2f 90       	pop	r2
    37dc:	1f 90       	pop	r1
    37de:	0f 90       	pop	r0
    37e0:	0f be       	out	0x3f, r0	; 63
    37e2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    37e4:	08 95       	ret

000037e6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    37e6:	0f 92       	push	r0
    37e8:	0f b6       	in	r0, 0x3f	; 63
    37ea:	f8 94       	cli
    37ec:	0f 92       	push	r0
    37ee:	1f 92       	push	r1
    37f0:	11 24       	eor	r1, r1
    37f2:	2f 92       	push	r2
    37f4:	3f 92       	push	r3
    37f6:	4f 92       	push	r4
    37f8:	5f 92       	push	r5
    37fa:	6f 92       	push	r6
    37fc:	7f 92       	push	r7
    37fe:	8f 92       	push	r8
    3800:	9f 92       	push	r9
    3802:	af 92       	push	r10
    3804:	bf 92       	push	r11
    3806:	cf 92       	push	r12
    3808:	df 92       	push	r13
    380a:	ef 92       	push	r14
    380c:	ff 92       	push	r15
    380e:	0f 93       	push	r16
    3810:	1f 93       	push	r17
    3812:	2f 93       	push	r18
    3814:	3f 93       	push	r19
    3816:	4f 93       	push	r20
    3818:	5f 93       	push	r21
    381a:	6f 93       	push	r22
    381c:	7f 93       	push	r23
    381e:	8f 93       	push	r24
    3820:	9f 93       	push	r25
    3822:	af 93       	push	r26
    3824:	bf 93       	push	r27
    3826:	cf 93       	push	r28
    3828:	df 93       	push	r29
    382a:	ef 93       	push	r30
    382c:	ff 93       	push	r31
    382e:	a0 91 ec 04 	lds	r26, 0x04EC
    3832:	b0 91 ed 04 	lds	r27, 0x04ED
    3836:	0d b6       	in	r0, 0x3d	; 61
    3838:	0d 92       	st	X+, r0
    383a:	0e b6       	in	r0, 0x3e	; 62
    383c:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    383e:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <vTaskIncrementTick>
	vTaskSwitchContext();
    3842:	0e 94 88 26 	call	0x4d10	; 0x4d10 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3846:	a0 91 ec 04 	lds	r26, 0x04EC
    384a:	b0 91 ed 04 	lds	r27, 0x04ED
    384e:	cd 91       	ld	r28, X+
    3850:	cd bf       	out	0x3d, r28	; 61
    3852:	dd 91       	ld	r29, X+
    3854:	de bf       	out	0x3e, r29	; 62
    3856:	ff 91       	pop	r31
    3858:	ef 91       	pop	r30
    385a:	df 91       	pop	r29
    385c:	cf 91       	pop	r28
    385e:	bf 91       	pop	r27
    3860:	af 91       	pop	r26
    3862:	9f 91       	pop	r25
    3864:	8f 91       	pop	r24
    3866:	7f 91       	pop	r23
    3868:	6f 91       	pop	r22
    386a:	5f 91       	pop	r21
    386c:	4f 91       	pop	r20
    386e:	3f 91       	pop	r19
    3870:	2f 91       	pop	r18
    3872:	1f 91       	pop	r17
    3874:	0f 91       	pop	r16
    3876:	ff 90       	pop	r15
    3878:	ef 90       	pop	r14
    387a:	df 90       	pop	r13
    387c:	cf 90       	pop	r12
    387e:	bf 90       	pop	r11
    3880:	af 90       	pop	r10
    3882:	9f 90       	pop	r9
    3884:	8f 90       	pop	r8
    3886:	7f 90       	pop	r7
    3888:	6f 90       	pop	r6
    388a:	5f 90       	pop	r5
    388c:	4f 90       	pop	r4
    388e:	3f 90       	pop	r3
    3890:	2f 90       	pop	r2
    3892:	1f 90       	pop	r1
    3894:	0f 90       	pop	r0
    3896:	0f be       	out	0x3f, r0	; 63
    3898:	0f 90       	pop	r0

	asm volatile ( "ret" );
    389a:	08 95       	ret

0000389c <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    389c:	df 93       	push	r29
    389e:	cf 93       	push	r28
    38a0:	00 d0       	rcall	.+0      	; 0x38a2 <prvSetupTimerInterrupt+0x6>
    38a2:	00 d0       	rcall	.+0      	; 0x38a4 <prvSetupTimerInterrupt+0x8>
    38a4:	00 d0       	rcall	.+0      	; 0x38a6 <prvSetupTimerInterrupt+0xa>
    38a6:	cd b7       	in	r28, 0x3d	; 61
    38a8:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    38aa:	80 e8       	ldi	r24, 0x80	; 128
    38ac:	9e e3       	ldi	r25, 0x3E	; 62
    38ae:	a0 e0       	ldi	r26, 0x00	; 0
    38b0:	b0 e0       	ldi	r27, 0x00	; 0
    38b2:	8b 83       	std	Y+3, r24	; 0x03
    38b4:	9c 83       	std	Y+4, r25	; 0x04
    38b6:	ad 83       	std	Y+5, r26	; 0x05
    38b8:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    38ba:	8b 81       	ldd	r24, Y+3	; 0x03
    38bc:	9c 81       	ldd	r25, Y+4	; 0x04
    38be:	ad 81       	ldd	r26, Y+5	; 0x05
    38c0:	be 81       	ldd	r27, Y+6	; 0x06
    38c2:	68 94       	set
    38c4:	15 f8       	bld	r1, 5
    38c6:	b6 95       	lsr	r27
    38c8:	a7 95       	ror	r26
    38ca:	97 95       	ror	r25
    38cc:	87 95       	ror	r24
    38ce:	16 94       	lsr	r1
    38d0:	d1 f7       	brne	.-12     	; 0x38c6 <prvSetupTimerInterrupt+0x2a>
    38d2:	8b 83       	std	Y+3, r24	; 0x03
    38d4:	9c 83       	std	Y+4, r25	; 0x04
    38d6:	ad 83       	std	Y+5, r26	; 0x05
    38d8:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    38da:	8b 81       	ldd	r24, Y+3	; 0x03
    38dc:	9c 81       	ldd	r25, Y+4	; 0x04
    38de:	ad 81       	ldd	r26, Y+5	; 0x05
    38e0:	be 81       	ldd	r27, Y+6	; 0x06
    38e2:	01 97       	sbiw	r24, 0x01	; 1
    38e4:	a1 09       	sbc	r26, r1
    38e6:	b1 09       	sbc	r27, r1
    38e8:	8b 83       	std	Y+3, r24	; 0x03
    38ea:	9c 83       	std	Y+4, r25	; 0x04
    38ec:	ad 83       	std	Y+5, r26	; 0x05
    38ee:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    38f0:	8b 81       	ldd	r24, Y+3	; 0x03
    38f2:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    38f4:	8b 81       	ldd	r24, Y+3	; 0x03
    38f6:	9c 81       	ldd	r25, Y+4	; 0x04
    38f8:	ad 81       	ldd	r26, Y+5	; 0x05
    38fa:	be 81       	ldd	r27, Y+6	; 0x06
    38fc:	89 2f       	mov	r24, r25
    38fe:	9a 2f       	mov	r25, r26
    3900:	ab 2f       	mov	r26, r27
    3902:	bb 27       	eor	r27, r27
    3904:	8b 83       	std	Y+3, r24	; 0x03
    3906:	9c 83       	std	Y+4, r25	; 0x04
    3908:	ad 83       	std	Y+5, r26	; 0x05
    390a:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    390c:	8b 81       	ldd	r24, Y+3	; 0x03
    390e:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    3910:	eb e4       	ldi	r30, 0x4B	; 75
    3912:	f0 e0       	ldi	r31, 0x00	; 0
    3914:	8a 81       	ldd	r24, Y+2	; 0x02
    3916:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    3918:	ea e4       	ldi	r30, 0x4A	; 74
    391a:	f0 e0       	ldi	r31, 0x00	; 0
    391c:	89 81       	ldd	r24, Y+1	; 0x01
    391e:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    3920:	8b e0       	ldi	r24, 0x0B	; 11
    3922:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    3924:	ee e4       	ldi	r30, 0x4E	; 78
    3926:	f0 e0       	ldi	r31, 0x00	; 0
    3928:	89 81       	ldd	r24, Y+1	; 0x01
    392a:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    392c:	e9 e5       	ldi	r30, 0x59	; 89
    392e:	f0 e0       	ldi	r31, 0x00	; 0
    3930:	80 81       	ld	r24, Z
    3932:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    3934:	89 81       	ldd	r24, Y+1	; 0x01
    3936:	80 61       	ori	r24, 0x10	; 16
    3938:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    393a:	e9 e5       	ldi	r30, 0x59	; 89
    393c:	f0 e0       	ldi	r31, 0x00	; 0
    393e:	89 81       	ldd	r24, Y+1	; 0x01
    3940:	80 83       	st	Z, r24
}
    3942:	26 96       	adiw	r28, 0x06	; 6
    3944:	0f b6       	in	r0, 0x3f	; 63
    3946:	f8 94       	cli
    3948:	de bf       	out	0x3e, r29	; 62
    394a:	0f be       	out	0x3f, r0	; 63
    394c:	cd bf       	out	0x3d, r28	; 61
    394e:	cf 91       	pop	r28
    3950:	df 91       	pop	r29
    3952:	08 95       	ret

00003954 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    3954:	0e 94 f3 1b 	call	0x37e6	; 0x37e6 <vPortYieldFromTick>
		asm volatile ( "reti" );
    3958:	18 95       	reti

0000395a <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    395a:	df 93       	push	r29
    395c:	cf 93       	push	r28
    395e:	cd b7       	in	r28, 0x3d	; 61
    3960:	de b7       	in	r29, 0x3e	; 62
    3962:	28 97       	sbiw	r28, 0x08	; 8
    3964:	0f b6       	in	r0, 0x3f	; 63
    3966:	f8 94       	cli
    3968:	de bf       	out	0x3e, r29	; 62
    396a:	0f be       	out	0x3f, r0	; 63
    396c:	cd bf       	out	0x3d, r28	; 61
    396e:	8f 83       	std	Y+7, r24	; 0x07
    3970:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    3972:	1a 82       	std	Y+2, r1	; 0x02
    3974:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    3976:	8f 81       	ldd	r24, Y+7	; 0x07
    3978:	88 23       	and	r24, r24
    397a:	09 f4       	brne	.+2      	; 0x397e <xQueueCreate+0x24>
    397c:	8c c0       	rjmp	.+280    	; 0x3a96 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    397e:	8f e1       	ldi	r24, 0x1F	; 31
    3980:	90 e0       	ldi	r25, 0x00	; 0
    3982:	0e 94 34 18 	call	0x3068	; 0x3068 <pvPortMalloc>
    3986:	9e 83       	std	Y+6, r25	; 0x06
    3988:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    398a:	8d 81       	ldd	r24, Y+5	; 0x05
    398c:	9e 81       	ldd	r25, Y+6	; 0x06
    398e:	00 97       	sbiw	r24, 0x00	; 0
    3990:	09 f4       	brne	.+2      	; 0x3994 <xQueueCreate+0x3a>
    3992:	81 c0       	rjmp	.+258    	; 0x3a96 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    3994:	8f 81       	ldd	r24, Y+7	; 0x07
    3996:	28 2f       	mov	r18, r24
    3998:	30 e0       	ldi	r19, 0x00	; 0
    399a:	88 85       	ldd	r24, Y+8	; 0x08
    399c:	88 2f       	mov	r24, r24
    399e:	90 e0       	ldi	r25, 0x00	; 0
    39a0:	ac 01       	movw	r20, r24
    39a2:	24 9f       	mul	r18, r20
    39a4:	c0 01       	movw	r24, r0
    39a6:	25 9f       	mul	r18, r21
    39a8:	90 0d       	add	r25, r0
    39aa:	34 9f       	mul	r19, r20
    39ac:	90 0d       	add	r25, r0
    39ae:	11 24       	eor	r1, r1
    39b0:	01 96       	adiw	r24, 0x01	; 1
    39b2:	9c 83       	std	Y+4, r25	; 0x04
    39b4:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    39b6:	8b 81       	ldd	r24, Y+3	; 0x03
    39b8:	9c 81       	ldd	r25, Y+4	; 0x04
    39ba:	0e 94 34 18 	call	0x3068	; 0x3068 <pvPortMalloc>
    39be:	ed 81       	ldd	r30, Y+5	; 0x05
    39c0:	fe 81       	ldd	r31, Y+6	; 0x06
    39c2:	91 83       	std	Z+1, r25	; 0x01
    39c4:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    39c6:	ed 81       	ldd	r30, Y+5	; 0x05
    39c8:	fe 81       	ldd	r31, Y+6	; 0x06
    39ca:	80 81       	ld	r24, Z
    39cc:	91 81       	ldd	r25, Z+1	; 0x01
    39ce:	00 97       	sbiw	r24, 0x00	; 0
    39d0:	09 f4       	brne	.+2      	; 0x39d4 <xQueueCreate+0x7a>
    39d2:	5d c0       	rjmp	.+186    	; 0x3a8e <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    39d4:	ed 81       	ldd	r30, Y+5	; 0x05
    39d6:	fe 81       	ldd	r31, Y+6	; 0x06
    39d8:	40 81       	ld	r20, Z
    39da:	51 81       	ldd	r21, Z+1	; 0x01
    39dc:	8f 81       	ldd	r24, Y+7	; 0x07
    39de:	28 2f       	mov	r18, r24
    39e0:	30 e0       	ldi	r19, 0x00	; 0
    39e2:	88 85       	ldd	r24, Y+8	; 0x08
    39e4:	88 2f       	mov	r24, r24
    39e6:	90 e0       	ldi	r25, 0x00	; 0
    39e8:	bc 01       	movw	r22, r24
    39ea:	26 9f       	mul	r18, r22
    39ec:	c0 01       	movw	r24, r0
    39ee:	27 9f       	mul	r18, r23
    39f0:	90 0d       	add	r25, r0
    39f2:	36 9f       	mul	r19, r22
    39f4:	90 0d       	add	r25, r0
    39f6:	11 24       	eor	r1, r1
    39f8:	84 0f       	add	r24, r20
    39fa:	95 1f       	adc	r25, r21
    39fc:	ed 81       	ldd	r30, Y+5	; 0x05
    39fe:	fe 81       	ldd	r31, Y+6	; 0x06
    3a00:	93 83       	std	Z+3, r25	; 0x03
    3a02:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    3a04:	ed 81       	ldd	r30, Y+5	; 0x05
    3a06:	fe 81       	ldd	r31, Y+6	; 0x06
    3a08:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    3a0a:	ed 81       	ldd	r30, Y+5	; 0x05
    3a0c:	fe 81       	ldd	r31, Y+6	; 0x06
    3a0e:	80 81       	ld	r24, Z
    3a10:	91 81       	ldd	r25, Z+1	; 0x01
    3a12:	ed 81       	ldd	r30, Y+5	; 0x05
    3a14:	fe 81       	ldd	r31, Y+6	; 0x06
    3a16:	95 83       	std	Z+5, r25	; 0x05
    3a18:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    3a1a:	ed 81       	ldd	r30, Y+5	; 0x05
    3a1c:	fe 81       	ldd	r31, Y+6	; 0x06
    3a1e:	40 81       	ld	r20, Z
    3a20:	51 81       	ldd	r21, Z+1	; 0x01
    3a22:	8f 81       	ldd	r24, Y+7	; 0x07
    3a24:	88 2f       	mov	r24, r24
    3a26:	90 e0       	ldi	r25, 0x00	; 0
    3a28:	9c 01       	movw	r18, r24
    3a2a:	21 50       	subi	r18, 0x01	; 1
    3a2c:	30 40       	sbci	r19, 0x00	; 0
    3a2e:	88 85       	ldd	r24, Y+8	; 0x08
    3a30:	88 2f       	mov	r24, r24
    3a32:	90 e0       	ldi	r25, 0x00	; 0
    3a34:	bc 01       	movw	r22, r24
    3a36:	26 9f       	mul	r18, r22
    3a38:	c0 01       	movw	r24, r0
    3a3a:	27 9f       	mul	r18, r23
    3a3c:	90 0d       	add	r25, r0
    3a3e:	36 9f       	mul	r19, r22
    3a40:	90 0d       	add	r25, r0
    3a42:	11 24       	eor	r1, r1
    3a44:	84 0f       	add	r24, r20
    3a46:	95 1f       	adc	r25, r21
    3a48:	ed 81       	ldd	r30, Y+5	; 0x05
    3a4a:	fe 81       	ldd	r31, Y+6	; 0x06
    3a4c:	97 83       	std	Z+7, r25	; 0x07
    3a4e:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    3a50:	ed 81       	ldd	r30, Y+5	; 0x05
    3a52:	fe 81       	ldd	r31, Y+6	; 0x06
    3a54:	8f 81       	ldd	r24, Y+7	; 0x07
    3a56:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    3a58:	ed 81       	ldd	r30, Y+5	; 0x05
    3a5a:	fe 81       	ldd	r31, Y+6	; 0x06
    3a5c:	88 85       	ldd	r24, Y+8	; 0x08
    3a5e:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    3a60:	ed 81       	ldd	r30, Y+5	; 0x05
    3a62:	fe 81       	ldd	r31, Y+6	; 0x06
    3a64:	8f ef       	ldi	r24, 0xFF	; 255
    3a66:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    3a68:	ed 81       	ldd	r30, Y+5	; 0x05
    3a6a:	fe 81       	ldd	r31, Y+6	; 0x06
    3a6c:	8f ef       	ldi	r24, 0xFF	; 255
    3a6e:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    3a70:	8d 81       	ldd	r24, Y+5	; 0x05
    3a72:	9e 81       	ldd	r25, Y+6	; 0x06
    3a74:	08 96       	adiw	r24, 0x08	; 8
    3a76:	0e 94 a0 18 	call	0x3140	; 0x3140 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    3a7a:	8d 81       	ldd	r24, Y+5	; 0x05
    3a7c:	9e 81       	ldd	r25, Y+6	; 0x06
    3a7e:	41 96       	adiw	r24, 0x11	; 17
    3a80:	0e 94 a0 18 	call	0x3140	; 0x3140 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    3a84:	8d 81       	ldd	r24, Y+5	; 0x05
    3a86:	9e 81       	ldd	r25, Y+6	; 0x06
    3a88:	9a 83       	std	Y+2, r25	; 0x02
    3a8a:	89 83       	std	Y+1, r24	; 0x01
    3a8c:	04 c0       	rjmp	.+8      	; 0x3a96 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    3a8e:	8d 81       	ldd	r24, Y+5	; 0x05
    3a90:	9e 81       	ldd	r25, Y+6	; 0x06
    3a92:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    3a96:	89 81       	ldd	r24, Y+1	; 0x01
    3a98:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3a9a:	28 96       	adiw	r28, 0x08	; 8
    3a9c:	0f b6       	in	r0, 0x3f	; 63
    3a9e:	f8 94       	cli
    3aa0:	de bf       	out	0x3e, r29	; 62
    3aa2:	0f be       	out	0x3f, r0	; 63
    3aa4:	cd bf       	out	0x3d, r28	; 61
    3aa6:	cf 91       	pop	r28
    3aa8:	df 91       	pop	r29
    3aaa:	08 95       	ret

00003aac <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
	{
    3aac:	df 93       	push	r29
    3aae:	cf 93       	push	r28
    3ab0:	00 d0       	rcall	.+0      	; 0x3ab2 <xQueueCreateCountingSemaphore+0x6>
    3ab2:	00 d0       	rcall	.+0      	; 0x3ab4 <xQueueCreateCountingSemaphore+0x8>
    3ab4:	cd b7       	in	r28, 0x3d	; 61
    3ab6:	de b7       	in	r29, 0x3e	; 62
    3ab8:	8b 83       	std	Y+3, r24	; 0x03
    3aba:	6c 83       	std	Y+4, r22	; 0x04
	xQueueHandle pxHandle;

		pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH );
    3abc:	8b 81       	ldd	r24, Y+3	; 0x03
    3abe:	60 e0       	ldi	r22, 0x00	; 0
    3ac0:	0e 94 ad 1c 	call	0x395a	; 0x395a <xQueueCreate>
    3ac4:	9a 83       	std	Y+2, r25	; 0x02
    3ac6:	89 83       	std	Y+1, r24	; 0x01

		if( pxHandle != NULL )
    3ac8:	89 81       	ldd	r24, Y+1	; 0x01
    3aca:	9a 81       	ldd	r25, Y+2	; 0x02
    3acc:	00 97       	sbiw	r24, 0x00	; 0
    3ace:	21 f0       	breq	.+8      	; 0x3ad8 <xQueueCreateCountingSemaphore+0x2c>
		{
			pxHandle->uxMessagesWaiting = uxInitialCount;
    3ad0:	e9 81       	ldd	r30, Y+1	; 0x01
    3ad2:	fa 81       	ldd	r31, Y+2	; 0x02
    3ad4:	8c 81       	ldd	r24, Y+4	; 0x04
    3ad6:	82 8f       	std	Z+26, r24	; 0x1a
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( pxHandle );
		return pxHandle;
    3ad8:	89 81       	ldd	r24, Y+1	; 0x01
    3ada:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    3adc:	0f 90       	pop	r0
    3ade:	0f 90       	pop	r0
    3ae0:	0f 90       	pop	r0
    3ae2:	0f 90       	pop	r0
    3ae4:	cf 91       	pop	r28
    3ae6:	df 91       	pop	r29
    3ae8:	08 95       	ret

00003aea <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    3aea:	df 93       	push	r29
    3aec:	cf 93       	push	r28
    3aee:	cd b7       	in	r28, 0x3d	; 61
    3af0:	de b7       	in	r29, 0x3e	; 62
    3af2:	2c 97       	sbiw	r28, 0x0c	; 12
    3af4:	0f b6       	in	r0, 0x3f	; 63
    3af6:	f8 94       	cli
    3af8:	de bf       	out	0x3e, r29	; 62
    3afa:	0f be       	out	0x3f, r0	; 63
    3afc:	cd bf       	out	0x3d, r28	; 61
    3afe:	9e 83       	std	Y+6, r25	; 0x06
    3b00:	8d 83       	std	Y+5, r24	; 0x05
    3b02:	78 87       	std	Y+8, r23	; 0x08
    3b04:	6f 83       	std	Y+7, r22	; 0x07
    3b06:	5a 87       	std	Y+10, r21	; 0x0a
    3b08:	49 87       	std	Y+9, r20	; 0x09
    3b0a:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    3b0c:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    3b0e:	0f b6       	in	r0, 0x3f	; 63
    3b10:	f8 94       	cli
    3b12:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3b14:	ed 81       	ldd	r30, Y+5	; 0x05
    3b16:	fe 81       	ldd	r31, Y+6	; 0x06
    3b18:	92 8d       	ldd	r25, Z+26	; 0x1a
    3b1a:	ed 81       	ldd	r30, Y+5	; 0x05
    3b1c:	fe 81       	ldd	r31, Y+6	; 0x06
    3b1e:	83 8d       	ldd	r24, Z+27	; 0x1b
    3b20:	98 17       	cp	r25, r24
    3b22:	d8 f4       	brcc	.+54     	; 0x3b5a <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3b24:	8d 81       	ldd	r24, Y+5	; 0x05
    3b26:	9e 81       	ldd	r25, Y+6	; 0x06
    3b28:	2f 81       	ldd	r18, Y+7	; 0x07
    3b2a:	38 85       	ldd	r19, Y+8	; 0x08
    3b2c:	b9 01       	movw	r22, r18
    3b2e:	4b 85       	ldd	r20, Y+11	; 0x0b
    3b30:	0e 94 b0 1f 	call	0x3f60	; 0x3f60 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3b34:	ed 81       	ldd	r30, Y+5	; 0x05
    3b36:	fe 81       	ldd	r31, Y+6	; 0x06
    3b38:	81 89       	ldd	r24, Z+17	; 0x11
    3b3a:	88 23       	and	r24, r24
    3b3c:	49 f0       	breq	.+18     	; 0x3b50 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    3b3e:	8d 81       	ldd	r24, Y+5	; 0x05
    3b40:	9e 81       	ldd	r25, Y+6	; 0x06
    3b42:	41 96       	adiw	r24, 0x11	; 17
    3b44:	0e 94 37 27 	call	0x4e6e	; 0x4e6e <xTaskRemoveFromEventList>
    3b48:	81 30       	cpi	r24, 0x01	; 1
    3b4a:	11 f4       	brne	.+4      	; 0x3b50 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    3b4c:	0e 94 9a 1b 	call	0x3734	; 0x3734 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    3b50:	0f 90       	pop	r0
    3b52:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    3b54:	81 e0       	ldi	r24, 0x01	; 1
    3b56:	8c 87       	std	Y+12, r24	; 0x0c
    3b58:	5c c0       	rjmp	.+184    	; 0x3c12 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    3b5a:	89 85       	ldd	r24, Y+9	; 0x09
    3b5c:	9a 85       	ldd	r25, Y+10	; 0x0a
    3b5e:	00 97       	sbiw	r24, 0x00	; 0
    3b60:	21 f4       	brne	.+8      	; 0x3b6a <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3b62:	0f 90       	pop	r0
    3b64:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    3b66:	1c 86       	std	Y+12, r1	; 0x0c
    3b68:	54 c0       	rjmp	.+168    	; 0x3c12 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    3b6a:	89 81       	ldd	r24, Y+1	; 0x01
    3b6c:	88 23       	and	r24, r24
    3b6e:	31 f4       	brne	.+12     	; 0x3b7c <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3b70:	ce 01       	movw	r24, r28
    3b72:	02 96       	adiw	r24, 0x02	; 2
    3b74:	0e 94 9f 27 	call	0x4f3e	; 0x4f3e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3b78:	81 e0       	ldi	r24, 0x01	; 1
    3b7a:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    3b7c:	0f 90       	pop	r0
    3b7e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3b80:	0e 94 e8 24 	call	0x49d0	; 0x49d0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3b84:	0f b6       	in	r0, 0x3f	; 63
    3b86:	f8 94       	cli
    3b88:	0f 92       	push	r0
    3b8a:	ed 81       	ldd	r30, Y+5	; 0x05
    3b8c:	fe 81       	ldd	r31, Y+6	; 0x06
    3b8e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3b90:	8f 3f       	cpi	r24, 0xFF	; 255
    3b92:	19 f4       	brne	.+6      	; 0x3b9a <xQueueGenericSend+0xb0>
    3b94:	ed 81       	ldd	r30, Y+5	; 0x05
    3b96:	fe 81       	ldd	r31, Y+6	; 0x06
    3b98:	15 8e       	std	Z+29, r1	; 0x1d
    3b9a:	ed 81       	ldd	r30, Y+5	; 0x05
    3b9c:	fe 81       	ldd	r31, Y+6	; 0x06
    3b9e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3ba0:	8f 3f       	cpi	r24, 0xFF	; 255
    3ba2:	19 f4       	brne	.+6      	; 0x3baa <xQueueGenericSend+0xc0>
    3ba4:	ed 81       	ldd	r30, Y+5	; 0x05
    3ba6:	fe 81       	ldd	r31, Y+6	; 0x06
    3ba8:	16 8e       	std	Z+30, r1	; 0x1e
    3baa:	0f 90       	pop	r0
    3bac:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3bae:	ce 01       	movw	r24, r28
    3bb0:	02 96       	adiw	r24, 0x02	; 2
    3bb2:	9e 01       	movw	r18, r28
    3bb4:	27 5f       	subi	r18, 0xF7	; 247
    3bb6:	3f 4f       	sbci	r19, 0xFF	; 255
    3bb8:	b9 01       	movw	r22, r18
    3bba:	0e 94 b8 27 	call	0x4f70	; 0x4f70 <xTaskCheckForTimeOut>
    3bbe:	88 23       	and	r24, r24
    3bc0:	09 f5       	brne	.+66     	; 0x3c04 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    3bc2:	8d 81       	ldd	r24, Y+5	; 0x05
    3bc4:	9e 81       	ldd	r25, Y+6	; 0x06
    3bc6:	0e 94 14 21 	call	0x4228	; 0x4228 <prvIsQueueFull>
    3bca:	88 23       	and	r24, r24
    3bcc:	a1 f0       	breq	.+40     	; 0x3bf6 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    3bce:	8d 81       	ldd	r24, Y+5	; 0x05
    3bd0:	9e 81       	ldd	r25, Y+6	; 0x06
    3bd2:	08 96       	adiw	r24, 0x08	; 8
    3bd4:	29 85       	ldd	r18, Y+9	; 0x09
    3bd6:	3a 85       	ldd	r19, Y+10	; 0x0a
    3bd8:	b9 01       	movw	r22, r18
    3bda:	0e 94 ee 26 	call	0x4ddc	; 0x4ddc <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    3bde:	8d 81       	ldd	r24, Y+5	; 0x05
    3be0:	9e 81       	ldd	r25, Y+6	; 0x06
    3be2:	0e 94 8d 20 	call	0x411a	; 0x411a <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    3be6:	0e 94 f4 24 	call	0x49e8	; 0x49e8 <xTaskResumeAll>
    3bea:	88 23       	and	r24, r24
    3bec:	09 f0       	breq	.+2      	; 0x3bf0 <xQueueGenericSend+0x106>
    3bee:	8f cf       	rjmp	.-226    	; 0x3b0e <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    3bf0:	0e 94 9a 1b 	call	0x3734	; 0x3734 <vPortYield>
    3bf4:	8c cf       	rjmp	.-232    	; 0x3b0e <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3bf6:	8d 81       	ldd	r24, Y+5	; 0x05
    3bf8:	9e 81       	ldd	r25, Y+6	; 0x06
    3bfa:	0e 94 8d 20 	call	0x411a	; 0x411a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3bfe:	0e 94 f4 24 	call	0x49e8	; 0x49e8 <xTaskResumeAll>
    3c02:	85 cf       	rjmp	.-246    	; 0x3b0e <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    3c04:	8d 81       	ldd	r24, Y+5	; 0x05
    3c06:	9e 81       	ldd	r25, Y+6	; 0x06
    3c08:	0e 94 8d 20 	call	0x411a	; 0x411a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3c0c:	0e 94 f4 24 	call	0x49e8	; 0x49e8 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    3c10:	1c 86       	std	Y+12, r1	; 0x0c
    3c12:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    3c14:	2c 96       	adiw	r28, 0x0c	; 12
    3c16:	0f b6       	in	r0, 0x3f	; 63
    3c18:	f8 94       	cli
    3c1a:	de bf       	out	0x3e, r29	; 62
    3c1c:	0f be       	out	0x3f, r0	; 63
    3c1e:	cd bf       	out	0x3d, r28	; 61
    3c20:	cf 91       	pop	r28
    3c22:	df 91       	pop	r29
    3c24:	08 95       	ret

00003c26 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    3c26:	df 93       	push	r29
    3c28:	cf 93       	push	r28
    3c2a:	cd b7       	in	r28, 0x3d	; 61
    3c2c:	de b7       	in	r29, 0x3e	; 62
    3c2e:	29 97       	sbiw	r28, 0x09	; 9
    3c30:	0f b6       	in	r0, 0x3f	; 63
    3c32:	f8 94       	cli
    3c34:	de bf       	out	0x3e, r29	; 62
    3c36:	0f be       	out	0x3f, r0	; 63
    3c38:	cd bf       	out	0x3d, r28	; 61
    3c3a:	9c 83       	std	Y+4, r25	; 0x04
    3c3c:	8b 83       	std	Y+3, r24	; 0x03
    3c3e:	7e 83       	std	Y+6, r23	; 0x06
    3c40:	6d 83       	std	Y+5, r22	; 0x05
    3c42:	58 87       	std	Y+8, r21	; 0x08
    3c44:	4f 83       	std	Y+7, r20	; 0x07
    3c46:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3c48:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3c4a:	eb 81       	ldd	r30, Y+3	; 0x03
    3c4c:	fc 81       	ldd	r31, Y+4	; 0x04
    3c4e:	92 8d       	ldd	r25, Z+26	; 0x1a
    3c50:	eb 81       	ldd	r30, Y+3	; 0x03
    3c52:	fc 81       	ldd	r31, Y+4	; 0x04
    3c54:	83 8d       	ldd	r24, Z+27	; 0x1b
    3c56:	98 17       	cp	r25, r24
    3c58:	40 f5       	brcc	.+80     	; 0x3caa <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3c5a:	8b 81       	ldd	r24, Y+3	; 0x03
    3c5c:	9c 81       	ldd	r25, Y+4	; 0x04
    3c5e:	2d 81       	ldd	r18, Y+5	; 0x05
    3c60:	3e 81       	ldd	r19, Y+6	; 0x06
    3c62:	b9 01       	movw	r22, r18
    3c64:	49 85       	ldd	r20, Y+9	; 0x09
    3c66:	0e 94 b0 1f 	call	0x3f60	; 0x3f60 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    3c6a:	eb 81       	ldd	r30, Y+3	; 0x03
    3c6c:	fc 81       	ldd	r31, Y+4	; 0x04
    3c6e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3c70:	8f 3f       	cpi	r24, 0xFF	; 255
    3c72:	89 f4       	brne	.+34     	; 0x3c96 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3c74:	eb 81       	ldd	r30, Y+3	; 0x03
    3c76:	fc 81       	ldd	r31, Y+4	; 0x04
    3c78:	81 89       	ldd	r24, Z+17	; 0x11
    3c7a:	88 23       	and	r24, r24
    3c7c:	99 f0       	breq	.+38     	; 0x3ca4 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3c7e:	8b 81       	ldd	r24, Y+3	; 0x03
    3c80:	9c 81       	ldd	r25, Y+4	; 0x04
    3c82:	41 96       	adiw	r24, 0x11	; 17
    3c84:	0e 94 37 27 	call	0x4e6e	; 0x4e6e <xTaskRemoveFromEventList>
    3c88:	88 23       	and	r24, r24
    3c8a:	61 f0       	breq	.+24     	; 0x3ca4 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    3c8c:	ef 81       	ldd	r30, Y+7	; 0x07
    3c8e:	f8 85       	ldd	r31, Y+8	; 0x08
    3c90:	81 e0       	ldi	r24, 0x01	; 1
    3c92:	80 83       	st	Z, r24
    3c94:	07 c0       	rjmp	.+14     	; 0x3ca4 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    3c96:	eb 81       	ldd	r30, Y+3	; 0x03
    3c98:	fc 81       	ldd	r31, Y+4	; 0x04
    3c9a:	86 8d       	ldd	r24, Z+30	; 0x1e
    3c9c:	8f 5f       	subi	r24, 0xFF	; 255
    3c9e:	eb 81       	ldd	r30, Y+3	; 0x03
    3ca0:	fc 81       	ldd	r31, Y+4	; 0x04
    3ca2:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    3ca4:	81 e0       	ldi	r24, 0x01	; 1
    3ca6:	8a 83       	std	Y+2, r24	; 0x02
    3ca8:	01 c0       	rjmp	.+2      	; 0x3cac <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    3caa:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3cac:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3cae:	29 96       	adiw	r28, 0x09	; 9
    3cb0:	0f b6       	in	r0, 0x3f	; 63
    3cb2:	f8 94       	cli
    3cb4:	de bf       	out	0x3e, r29	; 62
    3cb6:	0f be       	out	0x3f, r0	; 63
    3cb8:	cd bf       	out	0x3d, r28	; 61
    3cba:	cf 91       	pop	r28
    3cbc:	df 91       	pop	r29
    3cbe:	08 95       	ret

00003cc0 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    3cc0:	df 93       	push	r29
    3cc2:	cf 93       	push	r28
    3cc4:	cd b7       	in	r28, 0x3d	; 61
    3cc6:	de b7       	in	r29, 0x3e	; 62
    3cc8:	2e 97       	sbiw	r28, 0x0e	; 14
    3cca:	0f b6       	in	r0, 0x3f	; 63
    3ccc:	f8 94       	cli
    3cce:	de bf       	out	0x3e, r29	; 62
    3cd0:	0f be       	out	0x3f, r0	; 63
    3cd2:	cd bf       	out	0x3d, r28	; 61
    3cd4:	98 87       	std	Y+8, r25	; 0x08
    3cd6:	8f 83       	std	Y+7, r24	; 0x07
    3cd8:	7a 87       	std	Y+10, r23	; 0x0a
    3cda:	69 87       	std	Y+9, r22	; 0x09
    3cdc:	5c 87       	std	Y+12, r21	; 0x0c
    3cde:	4b 87       	std	Y+11, r20	; 0x0b
    3ce0:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    3ce2:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    3ce4:	0f b6       	in	r0, 0x3f	; 63
    3ce6:	f8 94       	cli
    3ce8:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    3cea:	ef 81       	ldd	r30, Y+7	; 0x07
    3cec:	f8 85       	ldd	r31, Y+8	; 0x08
    3cee:	82 8d       	ldd	r24, Z+26	; 0x1a
    3cf0:	88 23       	and	r24, r24
    3cf2:	09 f4       	brne	.+2      	; 0x3cf6 <xQueueGenericReceive+0x36>
    3cf4:	3f c0       	rjmp	.+126    	; 0x3d74 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    3cf6:	ef 81       	ldd	r30, Y+7	; 0x07
    3cf8:	f8 85       	ldd	r31, Y+8	; 0x08
    3cfa:	86 81       	ldd	r24, Z+6	; 0x06
    3cfc:	97 81       	ldd	r25, Z+7	; 0x07
    3cfe:	9a 83       	std	Y+2, r25	; 0x02
    3d00:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    3d02:	8f 81       	ldd	r24, Y+7	; 0x07
    3d04:	98 85       	ldd	r25, Y+8	; 0x08
    3d06:	29 85       	ldd	r18, Y+9	; 0x09
    3d08:	3a 85       	ldd	r19, Y+10	; 0x0a
    3d0a:	b9 01       	movw	r22, r18
    3d0c:	0e 94 45 20 	call	0x408a	; 0x408a <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    3d10:	8d 85       	ldd	r24, Y+13	; 0x0d
    3d12:	88 23       	and	r24, r24
    3d14:	b1 f4       	brne	.+44     	; 0x3d42 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    3d16:	ef 81       	ldd	r30, Y+7	; 0x07
    3d18:	f8 85       	ldd	r31, Y+8	; 0x08
    3d1a:	82 8d       	ldd	r24, Z+26	; 0x1a
    3d1c:	81 50       	subi	r24, 0x01	; 1
    3d1e:	ef 81       	ldd	r30, Y+7	; 0x07
    3d20:	f8 85       	ldd	r31, Y+8	; 0x08
    3d22:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3d24:	ef 81       	ldd	r30, Y+7	; 0x07
    3d26:	f8 85       	ldd	r31, Y+8	; 0x08
    3d28:	80 85       	ldd	r24, Z+8	; 0x08
    3d2a:	88 23       	and	r24, r24
    3d2c:	f1 f0       	breq	.+60     	; 0x3d6a <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    3d2e:	8f 81       	ldd	r24, Y+7	; 0x07
    3d30:	98 85       	ldd	r25, Y+8	; 0x08
    3d32:	08 96       	adiw	r24, 0x08	; 8
    3d34:	0e 94 37 27 	call	0x4e6e	; 0x4e6e <xTaskRemoveFromEventList>
    3d38:	81 30       	cpi	r24, 0x01	; 1
    3d3a:	b9 f4       	brne	.+46     	; 0x3d6a <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    3d3c:	0e 94 9a 1b 	call	0x3734	; 0x3734 <vPortYield>
    3d40:	14 c0       	rjmp	.+40     	; 0x3d6a <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    3d42:	ef 81       	ldd	r30, Y+7	; 0x07
    3d44:	f8 85       	ldd	r31, Y+8	; 0x08
    3d46:	89 81       	ldd	r24, Y+1	; 0x01
    3d48:	9a 81       	ldd	r25, Y+2	; 0x02
    3d4a:	97 83       	std	Z+7, r25	; 0x07
    3d4c:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3d4e:	ef 81       	ldd	r30, Y+7	; 0x07
    3d50:	f8 85       	ldd	r31, Y+8	; 0x08
    3d52:	81 89       	ldd	r24, Z+17	; 0x11
    3d54:	88 23       	and	r24, r24
    3d56:	49 f0       	breq	.+18     	; 0x3d6a <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3d58:	8f 81       	ldd	r24, Y+7	; 0x07
    3d5a:	98 85       	ldd	r25, Y+8	; 0x08
    3d5c:	41 96       	adiw	r24, 0x11	; 17
    3d5e:	0e 94 37 27 	call	0x4e6e	; 0x4e6e <xTaskRemoveFromEventList>
    3d62:	88 23       	and	r24, r24
    3d64:	11 f0       	breq	.+4      	; 0x3d6a <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    3d66:	0e 94 9a 1b 	call	0x3734	; 0x3734 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    3d6a:	0f 90       	pop	r0
    3d6c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3d6e:	81 e0       	ldi	r24, 0x01	; 1
    3d70:	8e 87       	std	Y+14, r24	; 0x0e
    3d72:	5c c0       	rjmp	.+184    	; 0x3e2c <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    3d74:	8b 85       	ldd	r24, Y+11	; 0x0b
    3d76:	9c 85       	ldd	r25, Y+12	; 0x0c
    3d78:	00 97       	sbiw	r24, 0x00	; 0
    3d7a:	21 f4       	brne	.+8      	; 0x3d84 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3d7c:	0f 90       	pop	r0
    3d7e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3d80:	1e 86       	std	Y+14, r1	; 0x0e
    3d82:	54 c0       	rjmp	.+168    	; 0x3e2c <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    3d84:	8b 81       	ldd	r24, Y+3	; 0x03
    3d86:	88 23       	and	r24, r24
    3d88:	31 f4       	brne	.+12     	; 0x3d96 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3d8a:	ce 01       	movw	r24, r28
    3d8c:	04 96       	adiw	r24, 0x04	; 4
    3d8e:	0e 94 9f 27 	call	0x4f3e	; 0x4f3e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3d92:	81 e0       	ldi	r24, 0x01	; 1
    3d94:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    3d96:	0f 90       	pop	r0
    3d98:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3d9a:	0e 94 e8 24 	call	0x49d0	; 0x49d0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3d9e:	0f b6       	in	r0, 0x3f	; 63
    3da0:	f8 94       	cli
    3da2:	0f 92       	push	r0
    3da4:	ef 81       	ldd	r30, Y+7	; 0x07
    3da6:	f8 85       	ldd	r31, Y+8	; 0x08
    3da8:	85 8d       	ldd	r24, Z+29	; 0x1d
    3daa:	8f 3f       	cpi	r24, 0xFF	; 255
    3dac:	19 f4       	brne	.+6      	; 0x3db4 <xQueueGenericReceive+0xf4>
    3dae:	ef 81       	ldd	r30, Y+7	; 0x07
    3db0:	f8 85       	ldd	r31, Y+8	; 0x08
    3db2:	15 8e       	std	Z+29, r1	; 0x1d
    3db4:	ef 81       	ldd	r30, Y+7	; 0x07
    3db6:	f8 85       	ldd	r31, Y+8	; 0x08
    3db8:	86 8d       	ldd	r24, Z+30	; 0x1e
    3dba:	8f 3f       	cpi	r24, 0xFF	; 255
    3dbc:	19 f4       	brne	.+6      	; 0x3dc4 <xQueueGenericReceive+0x104>
    3dbe:	ef 81       	ldd	r30, Y+7	; 0x07
    3dc0:	f8 85       	ldd	r31, Y+8	; 0x08
    3dc2:	16 8e       	std	Z+30, r1	; 0x1e
    3dc4:	0f 90       	pop	r0
    3dc6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3dc8:	ce 01       	movw	r24, r28
    3dca:	04 96       	adiw	r24, 0x04	; 4
    3dcc:	9e 01       	movw	r18, r28
    3dce:	25 5f       	subi	r18, 0xF5	; 245
    3dd0:	3f 4f       	sbci	r19, 0xFF	; 255
    3dd2:	b9 01       	movw	r22, r18
    3dd4:	0e 94 b8 27 	call	0x4f70	; 0x4f70 <xTaskCheckForTimeOut>
    3dd8:	88 23       	and	r24, r24
    3dda:	09 f5       	brne	.+66     	; 0x3e1e <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3ddc:	8f 81       	ldd	r24, Y+7	; 0x07
    3dde:	98 85       	ldd	r25, Y+8	; 0x08
    3de0:	0e 94 e1 20 	call	0x41c2	; 0x41c2 <prvIsQueueEmpty>
    3de4:	88 23       	and	r24, r24
    3de6:	a1 f0       	breq	.+40     	; 0x3e10 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3de8:	8f 81       	ldd	r24, Y+7	; 0x07
    3dea:	98 85       	ldd	r25, Y+8	; 0x08
    3dec:	41 96       	adiw	r24, 0x11	; 17
    3dee:	2b 85       	ldd	r18, Y+11	; 0x0b
    3df0:	3c 85       	ldd	r19, Y+12	; 0x0c
    3df2:	b9 01       	movw	r22, r18
    3df4:	0e 94 ee 26 	call	0x4ddc	; 0x4ddc <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3df8:	8f 81       	ldd	r24, Y+7	; 0x07
    3dfa:	98 85       	ldd	r25, Y+8	; 0x08
    3dfc:	0e 94 8d 20 	call	0x411a	; 0x411a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    3e00:	0e 94 f4 24 	call	0x49e8	; 0x49e8 <xTaskResumeAll>
    3e04:	88 23       	and	r24, r24
    3e06:	09 f0       	breq	.+2      	; 0x3e0a <xQueueGenericReceive+0x14a>
    3e08:	6d cf       	rjmp	.-294    	; 0x3ce4 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    3e0a:	0e 94 9a 1b 	call	0x3734	; 0x3734 <vPortYield>
    3e0e:	6a cf       	rjmp	.-300    	; 0x3ce4 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3e10:	8f 81       	ldd	r24, Y+7	; 0x07
    3e12:	98 85       	ldd	r25, Y+8	; 0x08
    3e14:	0e 94 8d 20 	call	0x411a	; 0x411a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3e18:	0e 94 f4 24 	call	0x49e8	; 0x49e8 <xTaskResumeAll>
    3e1c:	63 cf       	rjmp	.-314    	; 0x3ce4 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    3e1e:	8f 81       	ldd	r24, Y+7	; 0x07
    3e20:	98 85       	ldd	r25, Y+8	; 0x08
    3e22:	0e 94 8d 20 	call	0x411a	; 0x411a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3e26:	0e 94 f4 24 	call	0x49e8	; 0x49e8 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    3e2a:	1e 86       	std	Y+14, r1	; 0x0e
    3e2c:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    3e2e:	2e 96       	adiw	r28, 0x0e	; 14
    3e30:	0f b6       	in	r0, 0x3f	; 63
    3e32:	f8 94       	cli
    3e34:	de bf       	out	0x3e, r29	; 62
    3e36:	0f be       	out	0x3f, r0	; 63
    3e38:	cd bf       	out	0x3d, r28	; 61
    3e3a:	cf 91       	pop	r28
    3e3c:	df 91       	pop	r29
    3e3e:	08 95       	ret

00003e40 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    3e40:	df 93       	push	r29
    3e42:	cf 93       	push	r28
    3e44:	cd b7       	in	r28, 0x3d	; 61
    3e46:	de b7       	in	r29, 0x3e	; 62
    3e48:	28 97       	sbiw	r28, 0x08	; 8
    3e4a:	0f b6       	in	r0, 0x3f	; 63
    3e4c:	f8 94       	cli
    3e4e:	de bf       	out	0x3e, r29	; 62
    3e50:	0f be       	out	0x3f, r0	; 63
    3e52:	cd bf       	out	0x3d, r28	; 61
    3e54:	9c 83       	std	Y+4, r25	; 0x04
    3e56:	8b 83       	std	Y+3, r24	; 0x03
    3e58:	7e 83       	std	Y+6, r23	; 0x06
    3e5a:	6d 83       	std	Y+5, r22	; 0x05
    3e5c:	58 87       	std	Y+8, r21	; 0x08
    3e5e:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3e60:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    3e62:	eb 81       	ldd	r30, Y+3	; 0x03
    3e64:	fc 81       	ldd	r31, Y+4	; 0x04
    3e66:	82 8d       	ldd	r24, Z+26	; 0x1a
    3e68:	88 23       	and	r24, r24
    3e6a:	71 f1       	breq	.+92     	; 0x3ec8 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    3e6c:	8b 81       	ldd	r24, Y+3	; 0x03
    3e6e:	9c 81       	ldd	r25, Y+4	; 0x04
    3e70:	2d 81       	ldd	r18, Y+5	; 0x05
    3e72:	3e 81       	ldd	r19, Y+6	; 0x06
    3e74:	b9 01       	movw	r22, r18
    3e76:	0e 94 45 20 	call	0x408a	; 0x408a <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    3e7a:	eb 81       	ldd	r30, Y+3	; 0x03
    3e7c:	fc 81       	ldd	r31, Y+4	; 0x04
    3e7e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3e80:	81 50       	subi	r24, 0x01	; 1
    3e82:	eb 81       	ldd	r30, Y+3	; 0x03
    3e84:	fc 81       	ldd	r31, Y+4	; 0x04
    3e86:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    3e88:	eb 81       	ldd	r30, Y+3	; 0x03
    3e8a:	fc 81       	ldd	r31, Y+4	; 0x04
    3e8c:	85 8d       	ldd	r24, Z+29	; 0x1d
    3e8e:	8f 3f       	cpi	r24, 0xFF	; 255
    3e90:	89 f4       	brne	.+34     	; 0x3eb4 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3e92:	eb 81       	ldd	r30, Y+3	; 0x03
    3e94:	fc 81       	ldd	r31, Y+4	; 0x04
    3e96:	80 85       	ldd	r24, Z+8	; 0x08
    3e98:	88 23       	and	r24, r24
    3e9a:	99 f0       	breq	.+38     	; 0x3ec2 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3e9c:	8b 81       	ldd	r24, Y+3	; 0x03
    3e9e:	9c 81       	ldd	r25, Y+4	; 0x04
    3ea0:	08 96       	adiw	r24, 0x08	; 8
    3ea2:	0e 94 37 27 	call	0x4e6e	; 0x4e6e <xTaskRemoveFromEventList>
    3ea6:	88 23       	and	r24, r24
    3ea8:	61 f0       	breq	.+24     	; 0x3ec2 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    3eaa:	ef 81       	ldd	r30, Y+7	; 0x07
    3eac:	f8 85       	ldd	r31, Y+8	; 0x08
    3eae:	81 e0       	ldi	r24, 0x01	; 1
    3eb0:	80 83       	st	Z, r24
    3eb2:	07 c0       	rjmp	.+14     	; 0x3ec2 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    3eb4:	eb 81       	ldd	r30, Y+3	; 0x03
    3eb6:	fc 81       	ldd	r31, Y+4	; 0x04
    3eb8:	85 8d       	ldd	r24, Z+29	; 0x1d
    3eba:	8f 5f       	subi	r24, 0xFF	; 255
    3ebc:	eb 81       	ldd	r30, Y+3	; 0x03
    3ebe:	fc 81       	ldd	r31, Y+4	; 0x04
    3ec0:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    3ec2:	81 e0       	ldi	r24, 0x01	; 1
    3ec4:	8a 83       	std	Y+2, r24	; 0x02
    3ec6:	01 c0       	rjmp	.+2      	; 0x3eca <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    3ec8:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3eca:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3ecc:	28 96       	adiw	r28, 0x08	; 8
    3ece:	0f b6       	in	r0, 0x3f	; 63
    3ed0:	f8 94       	cli
    3ed2:	de bf       	out	0x3e, r29	; 62
    3ed4:	0f be       	out	0x3f, r0	; 63
    3ed6:	cd bf       	out	0x3d, r28	; 61
    3ed8:	cf 91       	pop	r28
    3eda:	df 91       	pop	r29
    3edc:	08 95       	ret

00003ede <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    3ede:	df 93       	push	r29
    3ee0:	cf 93       	push	r28
    3ee2:	00 d0       	rcall	.+0      	; 0x3ee4 <uxQueueMessagesWaiting+0x6>
    3ee4:	0f 92       	push	r0
    3ee6:	cd b7       	in	r28, 0x3d	; 61
    3ee8:	de b7       	in	r29, 0x3e	; 62
    3eea:	9b 83       	std	Y+3, r25	; 0x03
    3eec:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    3eee:	0f b6       	in	r0, 0x3f	; 63
    3ef0:	f8 94       	cli
    3ef2:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    3ef4:	ea 81       	ldd	r30, Y+2	; 0x02
    3ef6:	fb 81       	ldd	r31, Y+3	; 0x03
    3ef8:	82 8d       	ldd	r24, Z+26	; 0x1a
    3efa:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    3efc:	0f 90       	pop	r0
    3efe:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3f00:	89 81       	ldd	r24, Y+1	; 0x01
}
    3f02:	0f 90       	pop	r0
    3f04:	0f 90       	pop	r0
    3f06:	0f 90       	pop	r0
    3f08:	cf 91       	pop	r28
    3f0a:	df 91       	pop	r29
    3f0c:	08 95       	ret

00003f0e <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    3f0e:	df 93       	push	r29
    3f10:	cf 93       	push	r28
    3f12:	00 d0       	rcall	.+0      	; 0x3f14 <uxQueueMessagesWaitingFromISR+0x6>
    3f14:	0f 92       	push	r0
    3f16:	cd b7       	in	r28, 0x3d	; 61
    3f18:	de b7       	in	r29, 0x3e	; 62
    3f1a:	9b 83       	std	Y+3, r25	; 0x03
    3f1c:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    3f1e:	ea 81       	ldd	r30, Y+2	; 0x02
    3f20:	fb 81       	ldd	r31, Y+3	; 0x03
    3f22:	82 8d       	ldd	r24, Z+26	; 0x1a
    3f24:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    3f26:	89 81       	ldd	r24, Y+1	; 0x01
}
    3f28:	0f 90       	pop	r0
    3f2a:	0f 90       	pop	r0
    3f2c:	0f 90       	pop	r0
    3f2e:	cf 91       	pop	r28
    3f30:	df 91       	pop	r29
    3f32:	08 95       	ret

00003f34 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    3f34:	df 93       	push	r29
    3f36:	cf 93       	push	r28
    3f38:	00 d0       	rcall	.+0      	; 0x3f3a <vQueueDelete+0x6>
    3f3a:	cd b7       	in	r28, 0x3d	; 61
    3f3c:	de b7       	in	r29, 0x3e	; 62
    3f3e:	9a 83       	std	Y+2, r25	; 0x02
    3f40:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    3f42:	e9 81       	ldd	r30, Y+1	; 0x01
    3f44:	fa 81       	ldd	r31, Y+2	; 0x02
    3f46:	80 81       	ld	r24, Z
    3f48:	91 81       	ldd	r25, Z+1	; 0x01
    3f4a:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <vPortFree>
	vPortFree( pxQueue );
    3f4e:	89 81       	ldd	r24, Y+1	; 0x01
    3f50:	9a 81       	ldd	r25, Y+2	; 0x02
    3f52:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <vPortFree>
}
    3f56:	0f 90       	pop	r0
    3f58:	0f 90       	pop	r0
    3f5a:	cf 91       	pop	r28
    3f5c:	df 91       	pop	r29
    3f5e:	08 95       	ret

00003f60 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    3f60:	df 93       	push	r29
    3f62:	cf 93       	push	r28
    3f64:	00 d0       	rcall	.+0      	; 0x3f66 <prvCopyDataToQueue+0x6>
    3f66:	00 d0       	rcall	.+0      	; 0x3f68 <prvCopyDataToQueue+0x8>
    3f68:	0f 92       	push	r0
    3f6a:	cd b7       	in	r28, 0x3d	; 61
    3f6c:	de b7       	in	r29, 0x3e	; 62
    3f6e:	9a 83       	std	Y+2, r25	; 0x02
    3f70:	89 83       	std	Y+1, r24	; 0x01
    3f72:	7c 83       	std	Y+4, r23	; 0x04
    3f74:	6b 83       	std	Y+3, r22	; 0x03
    3f76:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    3f78:	e9 81       	ldd	r30, Y+1	; 0x01
    3f7a:	fa 81       	ldd	r31, Y+2	; 0x02
    3f7c:	84 8d       	ldd	r24, Z+28	; 0x1c
    3f7e:	88 23       	and	r24, r24
    3f80:	09 f4       	brne	.+2      	; 0x3f84 <prvCopyDataToQueue+0x24>
    3f82:	74 c0       	rjmp	.+232    	; 0x406c <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    3f84:	8d 81       	ldd	r24, Y+5	; 0x05
    3f86:	88 23       	and	r24, r24
    3f88:	99 f5       	brne	.+102    	; 0x3ff0 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    3f8a:	e9 81       	ldd	r30, Y+1	; 0x01
    3f8c:	fa 81       	ldd	r31, Y+2	; 0x02
    3f8e:	64 81       	ldd	r22, Z+4	; 0x04
    3f90:	75 81       	ldd	r23, Z+5	; 0x05
    3f92:	e9 81       	ldd	r30, Y+1	; 0x01
    3f94:	fa 81       	ldd	r31, Y+2	; 0x02
    3f96:	84 8d       	ldd	r24, Z+28	; 0x1c
    3f98:	48 2f       	mov	r20, r24
    3f9a:	50 e0       	ldi	r21, 0x00	; 0
    3f9c:	2b 81       	ldd	r18, Y+3	; 0x03
    3f9e:	3c 81       	ldd	r19, Y+4	; 0x04
    3fa0:	cb 01       	movw	r24, r22
    3fa2:	b9 01       	movw	r22, r18
    3fa4:	0e 94 9b 2a 	call	0x5536	; 0x5536 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    3fa8:	e9 81       	ldd	r30, Y+1	; 0x01
    3faa:	fa 81       	ldd	r31, Y+2	; 0x02
    3fac:	24 81       	ldd	r18, Z+4	; 0x04
    3fae:	35 81       	ldd	r19, Z+5	; 0x05
    3fb0:	e9 81       	ldd	r30, Y+1	; 0x01
    3fb2:	fa 81       	ldd	r31, Y+2	; 0x02
    3fb4:	84 8d       	ldd	r24, Z+28	; 0x1c
    3fb6:	88 2f       	mov	r24, r24
    3fb8:	90 e0       	ldi	r25, 0x00	; 0
    3fba:	82 0f       	add	r24, r18
    3fbc:	93 1f       	adc	r25, r19
    3fbe:	e9 81       	ldd	r30, Y+1	; 0x01
    3fc0:	fa 81       	ldd	r31, Y+2	; 0x02
    3fc2:	95 83       	std	Z+5, r25	; 0x05
    3fc4:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    3fc6:	e9 81       	ldd	r30, Y+1	; 0x01
    3fc8:	fa 81       	ldd	r31, Y+2	; 0x02
    3fca:	24 81       	ldd	r18, Z+4	; 0x04
    3fcc:	35 81       	ldd	r19, Z+5	; 0x05
    3fce:	e9 81       	ldd	r30, Y+1	; 0x01
    3fd0:	fa 81       	ldd	r31, Y+2	; 0x02
    3fd2:	82 81       	ldd	r24, Z+2	; 0x02
    3fd4:	93 81       	ldd	r25, Z+3	; 0x03
    3fd6:	28 17       	cp	r18, r24
    3fd8:	39 07       	cpc	r19, r25
    3fda:	08 f4       	brcc	.+2      	; 0x3fde <prvCopyDataToQueue+0x7e>
    3fdc:	47 c0       	rjmp	.+142    	; 0x406c <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    3fde:	e9 81       	ldd	r30, Y+1	; 0x01
    3fe0:	fa 81       	ldd	r31, Y+2	; 0x02
    3fe2:	80 81       	ld	r24, Z
    3fe4:	91 81       	ldd	r25, Z+1	; 0x01
    3fe6:	e9 81       	ldd	r30, Y+1	; 0x01
    3fe8:	fa 81       	ldd	r31, Y+2	; 0x02
    3fea:	95 83       	std	Z+5, r25	; 0x05
    3fec:	84 83       	std	Z+4, r24	; 0x04
    3fee:	3e c0       	rjmp	.+124    	; 0x406c <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    3ff0:	e9 81       	ldd	r30, Y+1	; 0x01
    3ff2:	fa 81       	ldd	r31, Y+2	; 0x02
    3ff4:	66 81       	ldd	r22, Z+6	; 0x06
    3ff6:	77 81       	ldd	r23, Z+7	; 0x07
    3ff8:	e9 81       	ldd	r30, Y+1	; 0x01
    3ffa:	fa 81       	ldd	r31, Y+2	; 0x02
    3ffc:	84 8d       	ldd	r24, Z+28	; 0x1c
    3ffe:	48 2f       	mov	r20, r24
    4000:	50 e0       	ldi	r21, 0x00	; 0
    4002:	2b 81       	ldd	r18, Y+3	; 0x03
    4004:	3c 81       	ldd	r19, Y+4	; 0x04
    4006:	cb 01       	movw	r24, r22
    4008:	b9 01       	movw	r22, r18
    400a:	0e 94 9b 2a 	call	0x5536	; 0x5536 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    400e:	e9 81       	ldd	r30, Y+1	; 0x01
    4010:	fa 81       	ldd	r31, Y+2	; 0x02
    4012:	26 81       	ldd	r18, Z+6	; 0x06
    4014:	37 81       	ldd	r19, Z+7	; 0x07
    4016:	e9 81       	ldd	r30, Y+1	; 0x01
    4018:	fa 81       	ldd	r31, Y+2	; 0x02
    401a:	84 8d       	ldd	r24, Z+28	; 0x1c
    401c:	88 2f       	mov	r24, r24
    401e:	90 e0       	ldi	r25, 0x00	; 0
    4020:	90 95       	com	r25
    4022:	81 95       	neg	r24
    4024:	9f 4f       	sbci	r25, 0xFF	; 255
    4026:	82 0f       	add	r24, r18
    4028:	93 1f       	adc	r25, r19
    402a:	e9 81       	ldd	r30, Y+1	; 0x01
    402c:	fa 81       	ldd	r31, Y+2	; 0x02
    402e:	97 83       	std	Z+7, r25	; 0x07
    4030:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    4032:	e9 81       	ldd	r30, Y+1	; 0x01
    4034:	fa 81       	ldd	r31, Y+2	; 0x02
    4036:	26 81       	ldd	r18, Z+6	; 0x06
    4038:	37 81       	ldd	r19, Z+7	; 0x07
    403a:	e9 81       	ldd	r30, Y+1	; 0x01
    403c:	fa 81       	ldd	r31, Y+2	; 0x02
    403e:	80 81       	ld	r24, Z
    4040:	91 81       	ldd	r25, Z+1	; 0x01
    4042:	28 17       	cp	r18, r24
    4044:	39 07       	cpc	r19, r25
    4046:	90 f4       	brcc	.+36     	; 0x406c <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    4048:	e9 81       	ldd	r30, Y+1	; 0x01
    404a:	fa 81       	ldd	r31, Y+2	; 0x02
    404c:	22 81       	ldd	r18, Z+2	; 0x02
    404e:	33 81       	ldd	r19, Z+3	; 0x03
    4050:	e9 81       	ldd	r30, Y+1	; 0x01
    4052:	fa 81       	ldd	r31, Y+2	; 0x02
    4054:	84 8d       	ldd	r24, Z+28	; 0x1c
    4056:	88 2f       	mov	r24, r24
    4058:	90 e0       	ldi	r25, 0x00	; 0
    405a:	90 95       	com	r25
    405c:	81 95       	neg	r24
    405e:	9f 4f       	sbci	r25, 0xFF	; 255
    4060:	82 0f       	add	r24, r18
    4062:	93 1f       	adc	r25, r19
    4064:	e9 81       	ldd	r30, Y+1	; 0x01
    4066:	fa 81       	ldd	r31, Y+2	; 0x02
    4068:	97 83       	std	Z+7, r25	; 0x07
    406a:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    406c:	e9 81       	ldd	r30, Y+1	; 0x01
    406e:	fa 81       	ldd	r31, Y+2	; 0x02
    4070:	82 8d       	ldd	r24, Z+26	; 0x1a
    4072:	8f 5f       	subi	r24, 0xFF	; 255
    4074:	e9 81       	ldd	r30, Y+1	; 0x01
    4076:	fa 81       	ldd	r31, Y+2	; 0x02
    4078:	82 8f       	std	Z+26, r24	; 0x1a
}
    407a:	0f 90       	pop	r0
    407c:	0f 90       	pop	r0
    407e:	0f 90       	pop	r0
    4080:	0f 90       	pop	r0
    4082:	0f 90       	pop	r0
    4084:	cf 91       	pop	r28
    4086:	df 91       	pop	r29
    4088:	08 95       	ret

0000408a <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    408a:	df 93       	push	r29
    408c:	cf 93       	push	r28
    408e:	00 d0       	rcall	.+0      	; 0x4090 <prvCopyDataFromQueue+0x6>
    4090:	00 d0       	rcall	.+0      	; 0x4092 <prvCopyDataFromQueue+0x8>
    4092:	cd b7       	in	r28, 0x3d	; 61
    4094:	de b7       	in	r29, 0x3e	; 62
    4096:	9a 83       	std	Y+2, r25	; 0x02
    4098:	89 83       	std	Y+1, r24	; 0x01
    409a:	7c 83       	std	Y+4, r23	; 0x04
    409c:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    409e:	e9 81       	ldd	r30, Y+1	; 0x01
    40a0:	fa 81       	ldd	r31, Y+2	; 0x02
    40a2:	80 81       	ld	r24, Z
    40a4:	91 81       	ldd	r25, Z+1	; 0x01
    40a6:	00 97       	sbiw	r24, 0x00	; 0
    40a8:	89 f1       	breq	.+98     	; 0x410c <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    40aa:	e9 81       	ldd	r30, Y+1	; 0x01
    40ac:	fa 81       	ldd	r31, Y+2	; 0x02
    40ae:	26 81       	ldd	r18, Z+6	; 0x06
    40b0:	37 81       	ldd	r19, Z+7	; 0x07
    40b2:	e9 81       	ldd	r30, Y+1	; 0x01
    40b4:	fa 81       	ldd	r31, Y+2	; 0x02
    40b6:	84 8d       	ldd	r24, Z+28	; 0x1c
    40b8:	88 2f       	mov	r24, r24
    40ba:	90 e0       	ldi	r25, 0x00	; 0
    40bc:	82 0f       	add	r24, r18
    40be:	93 1f       	adc	r25, r19
    40c0:	e9 81       	ldd	r30, Y+1	; 0x01
    40c2:	fa 81       	ldd	r31, Y+2	; 0x02
    40c4:	97 83       	std	Z+7, r25	; 0x07
    40c6:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    40c8:	e9 81       	ldd	r30, Y+1	; 0x01
    40ca:	fa 81       	ldd	r31, Y+2	; 0x02
    40cc:	26 81       	ldd	r18, Z+6	; 0x06
    40ce:	37 81       	ldd	r19, Z+7	; 0x07
    40d0:	e9 81       	ldd	r30, Y+1	; 0x01
    40d2:	fa 81       	ldd	r31, Y+2	; 0x02
    40d4:	82 81       	ldd	r24, Z+2	; 0x02
    40d6:	93 81       	ldd	r25, Z+3	; 0x03
    40d8:	28 17       	cp	r18, r24
    40da:	39 07       	cpc	r19, r25
    40dc:	40 f0       	brcs	.+16     	; 0x40ee <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    40de:	e9 81       	ldd	r30, Y+1	; 0x01
    40e0:	fa 81       	ldd	r31, Y+2	; 0x02
    40e2:	80 81       	ld	r24, Z
    40e4:	91 81       	ldd	r25, Z+1	; 0x01
    40e6:	e9 81       	ldd	r30, Y+1	; 0x01
    40e8:	fa 81       	ldd	r31, Y+2	; 0x02
    40ea:	97 83       	std	Z+7, r25	; 0x07
    40ec:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    40ee:	e9 81       	ldd	r30, Y+1	; 0x01
    40f0:	fa 81       	ldd	r31, Y+2	; 0x02
    40f2:	46 81       	ldd	r20, Z+6	; 0x06
    40f4:	57 81       	ldd	r21, Z+7	; 0x07
    40f6:	e9 81       	ldd	r30, Y+1	; 0x01
    40f8:	fa 81       	ldd	r31, Y+2	; 0x02
    40fa:	84 8d       	ldd	r24, Z+28	; 0x1c
    40fc:	28 2f       	mov	r18, r24
    40fe:	30 e0       	ldi	r19, 0x00	; 0
    4100:	8b 81       	ldd	r24, Y+3	; 0x03
    4102:	9c 81       	ldd	r25, Y+4	; 0x04
    4104:	ba 01       	movw	r22, r20
    4106:	a9 01       	movw	r20, r18
    4108:	0e 94 9b 2a 	call	0x5536	; 0x5536 <memcpy>
	}
}
    410c:	0f 90       	pop	r0
    410e:	0f 90       	pop	r0
    4110:	0f 90       	pop	r0
    4112:	0f 90       	pop	r0
    4114:	cf 91       	pop	r28
    4116:	df 91       	pop	r29
    4118:	08 95       	ret

0000411a <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    411a:	df 93       	push	r29
    411c:	cf 93       	push	r28
    411e:	00 d0       	rcall	.+0      	; 0x4120 <prvUnlockQueue+0x6>
    4120:	cd b7       	in	r28, 0x3d	; 61
    4122:	de b7       	in	r29, 0x3e	; 62
    4124:	9a 83       	std	Y+2, r25	; 0x02
    4126:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    4128:	0f b6       	in	r0, 0x3f	; 63
    412a:	f8 94       	cli
    412c:	0f 92       	push	r0
    412e:	15 c0       	rjmp	.+42     	; 0x415a <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4130:	e9 81       	ldd	r30, Y+1	; 0x01
    4132:	fa 81       	ldd	r31, Y+2	; 0x02
    4134:	81 89       	ldd	r24, Z+17	; 0x11
    4136:	88 23       	and	r24, r24
    4138:	a9 f0       	breq	.+42     	; 0x4164 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    413a:	89 81       	ldd	r24, Y+1	; 0x01
    413c:	9a 81       	ldd	r25, Y+2	; 0x02
    413e:	41 96       	adiw	r24, 0x11	; 17
    4140:	0e 94 37 27 	call	0x4e6e	; 0x4e6e <xTaskRemoveFromEventList>
    4144:	88 23       	and	r24, r24
    4146:	11 f0       	breq	.+4      	; 0x414c <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    4148:	0e 94 1f 28 	call	0x503e	; 0x503e <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    414c:	e9 81       	ldd	r30, Y+1	; 0x01
    414e:	fa 81       	ldd	r31, Y+2	; 0x02
    4150:	86 8d       	ldd	r24, Z+30	; 0x1e
    4152:	81 50       	subi	r24, 0x01	; 1
    4154:	e9 81       	ldd	r30, Y+1	; 0x01
    4156:	fa 81       	ldd	r31, Y+2	; 0x02
    4158:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    415a:	e9 81       	ldd	r30, Y+1	; 0x01
    415c:	fa 81       	ldd	r31, Y+2	; 0x02
    415e:	86 8d       	ldd	r24, Z+30	; 0x1e
    4160:	18 16       	cp	r1, r24
    4162:	34 f3       	brlt	.-52     	; 0x4130 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    4164:	e9 81       	ldd	r30, Y+1	; 0x01
    4166:	fa 81       	ldd	r31, Y+2	; 0x02
    4168:	8f ef       	ldi	r24, 0xFF	; 255
    416a:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    416c:	0f 90       	pop	r0
    416e:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    4170:	0f b6       	in	r0, 0x3f	; 63
    4172:	f8 94       	cli
    4174:	0f 92       	push	r0
    4176:	15 c0       	rjmp	.+42     	; 0x41a2 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4178:	e9 81       	ldd	r30, Y+1	; 0x01
    417a:	fa 81       	ldd	r31, Y+2	; 0x02
    417c:	80 85       	ldd	r24, Z+8	; 0x08
    417e:	88 23       	and	r24, r24
    4180:	a9 f0       	breq	.+42     	; 0x41ac <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4182:	89 81       	ldd	r24, Y+1	; 0x01
    4184:	9a 81       	ldd	r25, Y+2	; 0x02
    4186:	08 96       	adiw	r24, 0x08	; 8
    4188:	0e 94 37 27 	call	0x4e6e	; 0x4e6e <xTaskRemoveFromEventList>
    418c:	88 23       	and	r24, r24
    418e:	11 f0       	breq	.+4      	; 0x4194 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    4190:	0e 94 1f 28 	call	0x503e	; 0x503e <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    4194:	e9 81       	ldd	r30, Y+1	; 0x01
    4196:	fa 81       	ldd	r31, Y+2	; 0x02
    4198:	85 8d       	ldd	r24, Z+29	; 0x1d
    419a:	81 50       	subi	r24, 0x01	; 1
    419c:	e9 81       	ldd	r30, Y+1	; 0x01
    419e:	fa 81       	ldd	r31, Y+2	; 0x02
    41a0:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    41a2:	e9 81       	ldd	r30, Y+1	; 0x01
    41a4:	fa 81       	ldd	r31, Y+2	; 0x02
    41a6:	85 8d       	ldd	r24, Z+29	; 0x1d
    41a8:	18 16       	cp	r1, r24
    41aa:	34 f3       	brlt	.-52     	; 0x4178 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    41ac:	e9 81       	ldd	r30, Y+1	; 0x01
    41ae:	fa 81       	ldd	r31, Y+2	; 0x02
    41b0:	8f ef       	ldi	r24, 0xFF	; 255
    41b2:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    41b4:	0f 90       	pop	r0
    41b6:	0f be       	out	0x3f, r0	; 63
}
    41b8:	0f 90       	pop	r0
    41ba:	0f 90       	pop	r0
    41bc:	cf 91       	pop	r28
    41be:	df 91       	pop	r29
    41c0:	08 95       	ret

000041c2 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    41c2:	df 93       	push	r29
    41c4:	cf 93       	push	r28
    41c6:	00 d0       	rcall	.+0      	; 0x41c8 <prvIsQueueEmpty+0x6>
    41c8:	0f 92       	push	r0
    41ca:	cd b7       	in	r28, 0x3d	; 61
    41cc:	de b7       	in	r29, 0x3e	; 62
    41ce:	9b 83       	std	Y+3, r25	; 0x03
    41d0:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    41d2:	0f b6       	in	r0, 0x3f	; 63
    41d4:	f8 94       	cli
    41d6:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    41d8:	ea 81       	ldd	r30, Y+2	; 0x02
    41da:	fb 81       	ldd	r31, Y+3	; 0x03
    41dc:	82 8d       	ldd	r24, Z+26	; 0x1a
    41de:	19 82       	std	Y+1, r1	; 0x01
    41e0:	88 23       	and	r24, r24
    41e2:	11 f4       	brne	.+4      	; 0x41e8 <prvIsQueueEmpty+0x26>
    41e4:	81 e0       	ldi	r24, 0x01	; 1
    41e6:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    41e8:	0f 90       	pop	r0
    41ea:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    41ec:	89 81       	ldd	r24, Y+1	; 0x01
}
    41ee:	0f 90       	pop	r0
    41f0:	0f 90       	pop	r0
    41f2:	0f 90       	pop	r0
    41f4:	cf 91       	pop	r28
    41f6:	df 91       	pop	r29
    41f8:	08 95       	ret

000041fa <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    41fa:	df 93       	push	r29
    41fc:	cf 93       	push	r28
    41fe:	00 d0       	rcall	.+0      	; 0x4200 <xQueueIsQueueEmptyFromISR+0x6>
    4200:	0f 92       	push	r0
    4202:	cd b7       	in	r28, 0x3d	; 61
    4204:	de b7       	in	r29, 0x3e	; 62
    4206:	9b 83       	std	Y+3, r25	; 0x03
    4208:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    420a:	ea 81       	ldd	r30, Y+2	; 0x02
    420c:	fb 81       	ldd	r31, Y+3	; 0x03
    420e:	82 8d       	ldd	r24, Z+26	; 0x1a
    4210:	19 82       	std	Y+1, r1	; 0x01
    4212:	88 23       	and	r24, r24
    4214:	11 f4       	brne	.+4      	; 0x421a <xQueueIsQueueEmptyFromISR+0x20>
    4216:	81 e0       	ldi	r24, 0x01	; 1
    4218:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    421a:	89 81       	ldd	r24, Y+1	; 0x01
}
    421c:	0f 90       	pop	r0
    421e:	0f 90       	pop	r0
    4220:	0f 90       	pop	r0
    4222:	cf 91       	pop	r28
    4224:	df 91       	pop	r29
    4226:	08 95       	ret

00004228 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    4228:	df 93       	push	r29
    422a:	cf 93       	push	r28
    422c:	00 d0       	rcall	.+0      	; 0x422e <prvIsQueueFull+0x6>
    422e:	0f 92       	push	r0
    4230:	cd b7       	in	r28, 0x3d	; 61
    4232:	de b7       	in	r29, 0x3e	; 62
    4234:	9b 83       	std	Y+3, r25	; 0x03
    4236:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    4238:	0f b6       	in	r0, 0x3f	; 63
    423a:	f8 94       	cli
    423c:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    423e:	ea 81       	ldd	r30, Y+2	; 0x02
    4240:	fb 81       	ldd	r31, Y+3	; 0x03
    4242:	92 8d       	ldd	r25, Z+26	; 0x1a
    4244:	ea 81       	ldd	r30, Y+2	; 0x02
    4246:	fb 81       	ldd	r31, Y+3	; 0x03
    4248:	83 8d       	ldd	r24, Z+27	; 0x1b
    424a:	19 82       	std	Y+1, r1	; 0x01
    424c:	98 17       	cp	r25, r24
    424e:	11 f4       	brne	.+4      	; 0x4254 <prvIsQueueFull+0x2c>
    4250:	81 e0       	ldi	r24, 0x01	; 1
    4252:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    4254:	0f 90       	pop	r0
    4256:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    4258:	89 81       	ldd	r24, Y+1	; 0x01
}
    425a:	0f 90       	pop	r0
    425c:	0f 90       	pop	r0
    425e:	0f 90       	pop	r0
    4260:	cf 91       	pop	r28
    4262:	df 91       	pop	r29
    4264:	08 95       	ret

00004266 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    4266:	df 93       	push	r29
    4268:	cf 93       	push	r28
    426a:	00 d0       	rcall	.+0      	; 0x426c <xQueueIsQueueFullFromISR+0x6>
    426c:	0f 92       	push	r0
    426e:	cd b7       	in	r28, 0x3d	; 61
    4270:	de b7       	in	r29, 0x3e	; 62
    4272:	9b 83       	std	Y+3, r25	; 0x03
    4274:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    4276:	ea 81       	ldd	r30, Y+2	; 0x02
    4278:	fb 81       	ldd	r31, Y+3	; 0x03
    427a:	92 8d       	ldd	r25, Z+26	; 0x1a
    427c:	ea 81       	ldd	r30, Y+2	; 0x02
    427e:	fb 81       	ldd	r31, Y+3	; 0x03
    4280:	83 8d       	ldd	r24, Z+27	; 0x1b
    4282:	19 82       	std	Y+1, r1	; 0x01
    4284:	98 17       	cp	r25, r24
    4286:	11 f4       	brne	.+4      	; 0x428c <xQueueIsQueueFullFromISR+0x26>
    4288:	81 e0       	ldi	r24, 0x01	; 1
    428a:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    428c:	89 81       	ldd	r24, Y+1	; 0x01
}
    428e:	0f 90       	pop	r0
    4290:	0f 90       	pop	r0
    4292:	0f 90       	pop	r0
    4294:	cf 91       	pop	r28
    4296:	df 91       	pop	r29
    4298:	08 95       	ret

0000429a <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    429a:	af 92       	push	r10
    429c:	bf 92       	push	r11
    429e:	cf 92       	push	r12
    42a0:	df 92       	push	r13
    42a2:	ef 92       	push	r14
    42a4:	ff 92       	push	r15
    42a6:	0f 93       	push	r16
    42a8:	1f 93       	push	r17
    42aa:	df 93       	push	r29
    42ac:	cf 93       	push	r28
    42ae:	cd b7       	in	r28, 0x3d	; 61
    42b0:	de b7       	in	r29, 0x3e	; 62
    42b2:	64 97       	sbiw	r28, 0x14	; 20
    42b4:	0f b6       	in	r0, 0x3f	; 63
    42b6:	f8 94       	cli
    42b8:	de bf       	out	0x3e, r29	; 62
    42ba:	0f be       	out	0x3f, r0	; 63
    42bc:	cd bf       	out	0x3d, r28	; 61
    42be:	9f 83       	std	Y+7, r25	; 0x07
    42c0:	8e 83       	std	Y+6, r24	; 0x06
    42c2:	79 87       	std	Y+9, r23	; 0x09
    42c4:	68 87       	std	Y+8, r22	; 0x08
    42c6:	5b 87       	std	Y+11, r21	; 0x0b
    42c8:	4a 87       	std	Y+10, r20	; 0x0a
    42ca:	3d 87       	std	Y+13, r19	; 0x0d
    42cc:	2c 87       	std	Y+12, r18	; 0x0c
    42ce:	0e 87       	std	Y+14, r16	; 0x0e
    42d0:	f8 8a       	std	Y+16, r15	; 0x10
    42d2:	ef 86       	std	Y+15, r14	; 0x0f
    42d4:	da 8a       	std	Y+18, r13	; 0x12
    42d6:	c9 8a       	std	Y+17, r12	; 0x11
    42d8:	bc 8a       	std	Y+20, r11	; 0x14
    42da:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    42dc:	8a 85       	ldd	r24, Y+10	; 0x0a
    42de:	9b 85       	ldd	r25, Y+11	; 0x0b
    42e0:	29 89       	ldd	r18, Y+17	; 0x11
    42e2:	3a 89       	ldd	r19, Y+18	; 0x12
    42e4:	b9 01       	movw	r22, r18
    42e6:	0e 94 52 29 	call	0x52a4	; 0x52a4 <prvAllocateTCBAndStack>
    42ea:	9c 83       	std	Y+4, r25	; 0x04
    42ec:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    42ee:	8b 81       	ldd	r24, Y+3	; 0x03
    42f0:	9c 81       	ldd	r25, Y+4	; 0x04
    42f2:	00 97       	sbiw	r24, 0x00	; 0
    42f4:	09 f4       	brne	.+2      	; 0x42f8 <xTaskGenericCreate+0x5e>
    42f6:	99 c0       	rjmp	.+306    	; 0x442a <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    42f8:	eb 81       	ldd	r30, Y+3	; 0x03
    42fa:	fc 81       	ldd	r31, Y+4	; 0x04
    42fc:	27 89       	ldd	r18, Z+23	; 0x17
    42fe:	30 8d       	ldd	r19, Z+24	; 0x18
    4300:	8a 85       	ldd	r24, Y+10	; 0x0a
    4302:	9b 85       	ldd	r25, Y+11	; 0x0b
    4304:	01 97       	sbiw	r24, 0x01	; 1
    4306:	82 0f       	add	r24, r18
    4308:	93 1f       	adc	r25, r19
    430a:	9a 83       	std	Y+2, r25	; 0x02
    430c:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    430e:	8b 81       	ldd	r24, Y+3	; 0x03
    4310:	9c 81       	ldd	r25, Y+4	; 0x04
    4312:	28 85       	ldd	r18, Y+8	; 0x08
    4314:	39 85       	ldd	r19, Y+9	; 0x09
    4316:	eb 89       	ldd	r30, Y+19	; 0x13
    4318:	fc 89       	ldd	r31, Y+20	; 0x14
    431a:	aa 85       	ldd	r26, Y+10	; 0x0a
    431c:	bb 85       	ldd	r27, Y+11	; 0x0b
    431e:	b9 01       	movw	r22, r18
    4320:	4e 85       	ldd	r20, Y+14	; 0x0e
    4322:	9f 01       	movw	r18, r30
    4324:	8d 01       	movw	r16, r26
    4326:	0e 94 33 28 	call	0x5066	; 0x5066 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    432a:	89 81       	ldd	r24, Y+1	; 0x01
    432c:	9a 81       	ldd	r25, Y+2	; 0x02
    432e:	2e 81       	ldd	r18, Y+6	; 0x06
    4330:	3f 81       	ldd	r19, Y+7	; 0x07
    4332:	4c 85       	ldd	r20, Y+12	; 0x0c
    4334:	5d 85       	ldd	r21, Y+13	; 0x0d
    4336:	b9 01       	movw	r22, r18
    4338:	0e 94 db 19 	call	0x33b6	; 0x33b6 <pxPortInitialiseStack>
    433c:	eb 81       	ldd	r30, Y+3	; 0x03
    433e:	fc 81       	ldd	r31, Y+4	; 0x04
    4340:	91 83       	std	Z+1, r25	; 0x01
    4342:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    4344:	8f 85       	ldd	r24, Y+15	; 0x0f
    4346:	98 89       	ldd	r25, Y+16	; 0x10
    4348:	00 97       	sbiw	r24, 0x00	; 0
    434a:	31 f0       	breq	.+12     	; 0x4358 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    434c:	ef 85       	ldd	r30, Y+15	; 0x0f
    434e:	f8 89       	ldd	r31, Y+16	; 0x10
    4350:	8b 81       	ldd	r24, Y+3	; 0x03
    4352:	9c 81       	ldd	r25, Y+4	; 0x04
    4354:	91 83       	std	Z+1, r25	; 0x01
    4356:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    4358:	0f b6       	in	r0, 0x3f	; 63
    435a:	f8 94       	cli
    435c:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    435e:	80 91 ef 04 	lds	r24, 0x04EF
    4362:	8f 5f       	subi	r24, 0xFF	; 255
    4364:	80 93 ef 04 	sts	0x04EF, r24
			if( pxCurrentTCB == NULL )
    4368:	80 91 ec 04 	lds	r24, 0x04EC
    436c:	90 91 ed 04 	lds	r25, 0x04ED
    4370:	00 97       	sbiw	r24, 0x00	; 0
    4372:	69 f4       	brne	.+26     	; 0x438e <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    4374:	8b 81       	ldd	r24, Y+3	; 0x03
    4376:	9c 81       	ldd	r25, Y+4	; 0x04
    4378:	90 93 ed 04 	sts	0x04ED, r25
    437c:	80 93 ec 04 	sts	0x04EC, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    4380:	80 91 ef 04 	lds	r24, 0x04EF
    4384:	81 30       	cpi	r24, 0x01	; 1
    4386:	a9 f4       	brne	.+42     	; 0x43b2 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    4388:	0e 94 8a 28 	call	0x5114	; 0x5114 <prvInitialiseTaskLists>
    438c:	12 c0       	rjmp	.+36     	; 0x43b2 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    438e:	80 91 f4 04 	lds	r24, 0x04F4
    4392:	88 23       	and	r24, r24
    4394:	71 f4       	brne	.+28     	; 0x43b2 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    4396:	e0 91 ec 04 	lds	r30, 0x04EC
    439a:	f0 91 ed 04 	lds	r31, 0x04ED
    439e:	96 89       	ldd	r25, Z+22	; 0x16
    43a0:	8e 85       	ldd	r24, Y+14	; 0x0e
    43a2:	89 17       	cp	r24, r25
    43a4:	30 f0       	brcs	.+12     	; 0x43b2 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    43a6:	8b 81       	ldd	r24, Y+3	; 0x03
    43a8:	9c 81       	ldd	r25, Y+4	; 0x04
    43aa:	90 93 ed 04 	sts	0x04ED, r25
    43ae:	80 93 ec 04 	sts	0x04EC, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    43b2:	eb 81       	ldd	r30, Y+3	; 0x03
    43b4:	fc 81       	ldd	r31, Y+4	; 0x04
    43b6:	96 89       	ldd	r25, Z+22	; 0x16
    43b8:	80 91 f2 04 	lds	r24, 0x04F2
    43bc:	89 17       	cp	r24, r25
    43be:	28 f4       	brcc	.+10     	; 0x43ca <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    43c0:	eb 81       	ldd	r30, Y+3	; 0x03
    43c2:	fc 81       	ldd	r31, Y+4	; 0x04
    43c4:	86 89       	ldd	r24, Z+22	; 0x16
    43c6:	80 93 f2 04 	sts	0x04F2, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    43ca:	80 91 f9 04 	lds	r24, 0x04F9
    43ce:	8f 5f       	subi	r24, 0xFF	; 255
    43d0:	80 93 f9 04 	sts	0x04F9, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    43d4:	eb 81       	ldd	r30, Y+3	; 0x03
    43d6:	fc 81       	ldd	r31, Y+4	; 0x04
    43d8:	96 89       	ldd	r25, Z+22	; 0x16
    43da:	80 91 f3 04 	lds	r24, 0x04F3
    43de:	89 17       	cp	r24, r25
    43e0:	28 f4       	brcc	.+10     	; 0x43ec <xTaskGenericCreate+0x152>
    43e2:	eb 81       	ldd	r30, Y+3	; 0x03
    43e4:	fc 81       	ldd	r31, Y+4	; 0x04
    43e6:	86 89       	ldd	r24, Z+22	; 0x16
    43e8:	80 93 f3 04 	sts	0x04F3, r24
    43ec:	eb 81       	ldd	r30, Y+3	; 0x03
    43ee:	fc 81       	ldd	r31, Y+4	; 0x04
    43f0:	86 89       	ldd	r24, Z+22	; 0x16
    43f2:	28 2f       	mov	r18, r24
    43f4:	30 e0       	ldi	r19, 0x00	; 0
    43f6:	c9 01       	movw	r24, r18
    43f8:	88 0f       	add	r24, r24
    43fa:	99 1f       	adc	r25, r25
    43fc:	88 0f       	add	r24, r24
    43fe:	99 1f       	adc	r25, r25
    4400:	88 0f       	add	r24, r24
    4402:	99 1f       	adc	r25, r25
    4404:	82 0f       	add	r24, r18
    4406:	93 1f       	adc	r25, r19
    4408:	ac 01       	movw	r20, r24
    440a:	46 50       	subi	r20, 0x06	; 6
    440c:	5b 4f       	sbci	r21, 0xFB	; 251
    440e:	8b 81       	ldd	r24, Y+3	; 0x03
    4410:	9c 81       	ldd	r25, Y+4	; 0x04
    4412:	9c 01       	movw	r18, r24
    4414:	2e 5f       	subi	r18, 0xFE	; 254
    4416:	3f 4f       	sbci	r19, 0xFF	; 255
    4418:	ca 01       	movw	r24, r20
    441a:	b9 01       	movw	r22, r18
    441c:	0e 94 da 18 	call	0x31b4	; 0x31b4 <vListInsertEnd>

			xReturn = pdPASS;
    4420:	81 e0       	ldi	r24, 0x01	; 1
    4422:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    4424:	0f 90       	pop	r0
    4426:	0f be       	out	0x3f, r0	; 63
    4428:	02 c0       	rjmp	.+4      	; 0x442e <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    442a:	8f ef       	ldi	r24, 0xFF	; 255
    442c:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    442e:	8d 81       	ldd	r24, Y+5	; 0x05
    4430:	81 30       	cpi	r24, 0x01	; 1
    4432:	71 f4       	brne	.+28     	; 0x4450 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    4434:	80 91 f4 04 	lds	r24, 0x04F4
    4438:	88 23       	and	r24, r24
    443a:	51 f0       	breq	.+20     	; 0x4450 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    443c:	e0 91 ec 04 	lds	r30, 0x04EC
    4440:	f0 91 ed 04 	lds	r31, 0x04ED
    4444:	96 89       	ldd	r25, Z+22	; 0x16
    4446:	8e 85       	ldd	r24, Y+14	; 0x0e
    4448:	98 17       	cp	r25, r24
    444a:	10 f4       	brcc	.+4      	; 0x4450 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    444c:	0e 94 9a 1b 	call	0x3734	; 0x3734 <vPortYield>
			}
		}
	}

	return xReturn;
    4450:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4452:	64 96       	adiw	r28, 0x14	; 20
    4454:	0f b6       	in	r0, 0x3f	; 63
    4456:	f8 94       	cli
    4458:	de bf       	out	0x3e, r29	; 62
    445a:	0f be       	out	0x3f, r0	; 63
    445c:	cd bf       	out	0x3d, r28	; 61
    445e:	cf 91       	pop	r28
    4460:	df 91       	pop	r29
    4462:	1f 91       	pop	r17
    4464:	0f 91       	pop	r16
    4466:	ff 90       	pop	r15
    4468:	ef 90       	pop	r14
    446a:	df 90       	pop	r13
    446c:	cf 90       	pop	r12
    446e:	bf 90       	pop	r11
    4470:	af 90       	pop	r10
    4472:	08 95       	ret

00004474 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    4474:	df 93       	push	r29
    4476:	cf 93       	push	r28
    4478:	00 d0       	rcall	.+0      	; 0x447a <vTaskDelete+0x6>
    447a:	00 d0       	rcall	.+0      	; 0x447c <vTaskDelete+0x8>
    447c:	00 d0       	rcall	.+0      	; 0x447e <vTaskDelete+0xa>
    447e:	cd b7       	in	r28, 0x3d	; 61
    4480:	de b7       	in	r29, 0x3e	; 62
    4482:	9c 83       	std	Y+4, r25	; 0x04
    4484:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    4486:	0f b6       	in	r0, 0x3f	; 63
    4488:	f8 94       	cli
    448a:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    448c:	20 91 ec 04 	lds	r18, 0x04EC
    4490:	30 91 ed 04 	lds	r19, 0x04ED
    4494:	8b 81       	ldd	r24, Y+3	; 0x03
    4496:	9c 81       	ldd	r25, Y+4	; 0x04
    4498:	82 17       	cp	r24, r18
    449a:	93 07       	cpc	r25, r19
    449c:	11 f4       	brne	.+4      	; 0x44a2 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    449e:	1c 82       	std	Y+4, r1	; 0x04
    44a0:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    44a2:	8b 81       	ldd	r24, Y+3	; 0x03
    44a4:	9c 81       	ldd	r25, Y+4	; 0x04
    44a6:	00 97       	sbiw	r24, 0x00	; 0
    44a8:	39 f4       	brne	.+14     	; 0x44b8 <vTaskDelete+0x44>
    44aa:	80 91 ec 04 	lds	r24, 0x04EC
    44ae:	90 91 ed 04 	lds	r25, 0x04ED
    44b2:	9e 83       	std	Y+6, r25	; 0x06
    44b4:	8d 83       	std	Y+5, r24	; 0x05
    44b6:	04 c0       	rjmp	.+8      	; 0x44c0 <vTaskDelete+0x4c>
    44b8:	8b 81       	ldd	r24, Y+3	; 0x03
    44ba:	9c 81       	ldd	r25, Y+4	; 0x04
    44bc:	9e 83       	std	Y+6, r25	; 0x06
    44be:	8d 83       	std	Y+5, r24	; 0x05
    44c0:	8d 81       	ldd	r24, Y+5	; 0x05
    44c2:	9e 81       	ldd	r25, Y+6	; 0x06
    44c4:	9a 83       	std	Y+2, r25	; 0x02
    44c6:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    44c8:	89 81       	ldd	r24, Y+1	; 0x01
    44ca:	9a 81       	ldd	r25, Y+2	; 0x02
    44cc:	02 96       	adiw	r24, 0x02	; 2
    44ce:	0e 94 92 19 	call	0x3324	; 0x3324 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    44d2:	e9 81       	ldd	r30, Y+1	; 0x01
    44d4:	fa 81       	ldd	r31, Y+2	; 0x02
    44d6:	84 89       	ldd	r24, Z+20	; 0x14
    44d8:	95 89       	ldd	r25, Z+21	; 0x15
    44da:	00 97       	sbiw	r24, 0x00	; 0
    44dc:	29 f0       	breq	.+10     	; 0x44e8 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    44de:	89 81       	ldd	r24, Y+1	; 0x01
    44e0:	9a 81       	ldd	r25, Y+2	; 0x02
    44e2:	0c 96       	adiw	r24, 0x0c	; 12
    44e4:	0e 94 92 19 	call	0x3324	; 0x3324 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    44e8:	89 81       	ldd	r24, Y+1	; 0x01
    44ea:	9a 81       	ldd	r25, Y+2	; 0x02
    44ec:	9c 01       	movw	r18, r24
    44ee:	2e 5f       	subi	r18, 0xFE	; 254
    44f0:	3f 4f       	sbci	r19, 0xFF	; 255
    44f2:	8d e3       	ldi	r24, 0x3D	; 61
    44f4:	95 e0       	ldi	r25, 0x05	; 5
    44f6:	b9 01       	movw	r22, r18
    44f8:	0e 94 da 18 	call	0x31b4	; 0x31b4 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    44fc:	80 91 ee 04 	lds	r24, 0x04EE
    4500:	8f 5f       	subi	r24, 0xFF	; 255
    4502:	80 93 ee 04 	sts	0x04EE, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    4506:	80 91 f9 04 	lds	r24, 0x04F9
    450a:	8f 5f       	subi	r24, 0xFF	; 255
    450c:	80 93 f9 04 	sts	0x04F9, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    4510:	0f 90       	pop	r0
    4512:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    4514:	80 91 f4 04 	lds	r24, 0x04F4
    4518:	88 23       	and	r24, r24
    451a:	31 f0       	breq	.+12     	; 0x4528 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    451c:	8b 81       	ldd	r24, Y+3	; 0x03
    451e:	9c 81       	ldd	r25, Y+4	; 0x04
    4520:	00 97       	sbiw	r24, 0x00	; 0
    4522:	11 f4       	brne	.+4      	; 0x4528 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    4524:	0e 94 9a 1b 	call	0x3734	; 0x3734 <vPortYield>
			}
		}
	}
    4528:	26 96       	adiw	r28, 0x06	; 6
    452a:	0f b6       	in	r0, 0x3f	; 63
    452c:	f8 94       	cli
    452e:	de bf       	out	0x3e, r29	; 62
    4530:	0f be       	out	0x3f, r0	; 63
    4532:	cd bf       	out	0x3d, r28	; 61
    4534:	cf 91       	pop	r28
    4536:	df 91       	pop	r29
    4538:	08 95       	ret

0000453a <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    453a:	df 93       	push	r29
    453c:	cf 93       	push	r28
    453e:	cd b7       	in	r28, 0x3d	; 61
    4540:	de b7       	in	r29, 0x3e	; 62
    4542:	28 97       	sbiw	r28, 0x08	; 8
    4544:	0f b6       	in	r0, 0x3f	; 63
    4546:	f8 94       	cli
    4548:	de bf       	out	0x3e, r29	; 62
    454a:	0f be       	out	0x3f, r0	; 63
    454c:	cd bf       	out	0x3d, r28	; 61
    454e:	9e 83       	std	Y+6, r25	; 0x06
    4550:	8d 83       	std	Y+5, r24	; 0x05
    4552:	78 87       	std	Y+8, r23	; 0x08
    4554:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    4556:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    4558:	0e 94 e8 24 	call	0x49d0	; 0x49d0 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    455c:	ed 81       	ldd	r30, Y+5	; 0x05
    455e:	fe 81       	ldd	r31, Y+6	; 0x06
    4560:	20 81       	ld	r18, Z
    4562:	31 81       	ldd	r19, Z+1	; 0x01
    4564:	8f 81       	ldd	r24, Y+7	; 0x07
    4566:	98 85       	ldd	r25, Y+8	; 0x08
    4568:	82 0f       	add	r24, r18
    456a:	93 1f       	adc	r25, r19
    456c:	9c 83       	std	Y+4, r25	; 0x04
    456e:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    4570:	ed 81       	ldd	r30, Y+5	; 0x05
    4572:	fe 81       	ldd	r31, Y+6	; 0x06
    4574:	20 81       	ld	r18, Z
    4576:	31 81       	ldd	r19, Z+1	; 0x01
    4578:	80 91 f0 04 	lds	r24, 0x04F0
    457c:	90 91 f1 04 	lds	r25, 0x04F1
    4580:	82 17       	cp	r24, r18
    4582:	93 07       	cpc	r25, r19
    4584:	a8 f4       	brcc	.+42     	; 0x45b0 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    4586:	ed 81       	ldd	r30, Y+5	; 0x05
    4588:	fe 81       	ldd	r31, Y+6	; 0x06
    458a:	20 81       	ld	r18, Z
    458c:	31 81       	ldd	r19, Z+1	; 0x01
    458e:	8b 81       	ldd	r24, Y+3	; 0x03
    4590:	9c 81       	ldd	r25, Y+4	; 0x04
    4592:	82 17       	cp	r24, r18
    4594:	93 07       	cpc	r25, r19
    4596:	00 f5       	brcc	.+64     	; 0x45d8 <vTaskDelayUntil+0x9e>
    4598:	20 91 f0 04 	lds	r18, 0x04F0
    459c:	30 91 f1 04 	lds	r19, 0x04F1
    45a0:	8b 81       	ldd	r24, Y+3	; 0x03
    45a2:	9c 81       	ldd	r25, Y+4	; 0x04
    45a4:	28 17       	cp	r18, r24
    45a6:	39 07       	cpc	r19, r25
    45a8:	b8 f4       	brcc	.+46     	; 0x45d8 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    45aa:	81 e0       	ldi	r24, 0x01	; 1
    45ac:	89 83       	std	Y+1, r24	; 0x01
    45ae:	14 c0       	rjmp	.+40     	; 0x45d8 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    45b0:	ed 81       	ldd	r30, Y+5	; 0x05
    45b2:	fe 81       	ldd	r31, Y+6	; 0x06
    45b4:	20 81       	ld	r18, Z
    45b6:	31 81       	ldd	r19, Z+1	; 0x01
    45b8:	8b 81       	ldd	r24, Y+3	; 0x03
    45ba:	9c 81       	ldd	r25, Y+4	; 0x04
    45bc:	82 17       	cp	r24, r18
    45be:	93 07       	cpc	r25, r19
    45c0:	48 f0       	brcs	.+18     	; 0x45d4 <vTaskDelayUntil+0x9a>
    45c2:	20 91 f0 04 	lds	r18, 0x04F0
    45c6:	30 91 f1 04 	lds	r19, 0x04F1
    45ca:	8b 81       	ldd	r24, Y+3	; 0x03
    45cc:	9c 81       	ldd	r25, Y+4	; 0x04
    45ce:	28 17       	cp	r18, r24
    45d0:	39 07       	cpc	r19, r25
    45d2:	10 f4       	brcc	.+4      	; 0x45d8 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    45d4:	81 e0       	ldi	r24, 0x01	; 1
    45d6:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    45d8:	ed 81       	ldd	r30, Y+5	; 0x05
    45da:	fe 81       	ldd	r31, Y+6	; 0x06
    45dc:	8b 81       	ldd	r24, Y+3	; 0x03
    45de:	9c 81       	ldd	r25, Y+4	; 0x04
    45e0:	91 83       	std	Z+1, r25	; 0x01
    45e2:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    45e4:	89 81       	ldd	r24, Y+1	; 0x01
    45e6:	88 23       	and	r24, r24
    45e8:	59 f0       	breq	.+22     	; 0x4600 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    45ea:	80 91 ec 04 	lds	r24, 0x04EC
    45ee:	90 91 ed 04 	lds	r25, 0x04ED
    45f2:	02 96       	adiw	r24, 0x02	; 2
    45f4:	0e 94 92 19 	call	0x3324	; 0x3324 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    45f8:	8b 81       	ldd	r24, Y+3	; 0x03
    45fa:	9c 81       	ldd	r25, Y+4	; 0x04
    45fc:	0e 94 09 29 	call	0x5212	; 0x5212 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    4600:	0e 94 f4 24 	call	0x49e8	; 0x49e8 <xTaskResumeAll>
    4604:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    4606:	8a 81       	ldd	r24, Y+2	; 0x02
    4608:	88 23       	and	r24, r24
    460a:	11 f4       	brne	.+4      	; 0x4610 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    460c:	0e 94 9a 1b 	call	0x3734	; 0x3734 <vPortYield>
		}
	}
    4610:	28 96       	adiw	r28, 0x08	; 8
    4612:	0f b6       	in	r0, 0x3f	; 63
    4614:	f8 94       	cli
    4616:	de bf       	out	0x3e, r29	; 62
    4618:	0f be       	out	0x3f, r0	; 63
    461a:	cd bf       	out	0x3d, r28	; 61
    461c:	cf 91       	pop	r28
    461e:	df 91       	pop	r29
    4620:	08 95       	ret

00004622 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    4622:	df 93       	push	r29
    4624:	cf 93       	push	r28
    4626:	00 d0       	rcall	.+0      	; 0x4628 <vTaskDelay+0x6>
    4628:	00 d0       	rcall	.+0      	; 0x462a <vTaskDelay+0x8>
    462a:	0f 92       	push	r0
    462c:	cd b7       	in	r28, 0x3d	; 61
    462e:	de b7       	in	r29, 0x3e	; 62
    4630:	9d 83       	std	Y+5, r25	; 0x05
    4632:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    4634:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    4636:	8c 81       	ldd	r24, Y+4	; 0x04
    4638:	9d 81       	ldd	r25, Y+5	; 0x05
    463a:	00 97       	sbiw	r24, 0x00	; 0
    463c:	d1 f0       	breq	.+52     	; 0x4672 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    463e:	0e 94 e8 24 	call	0x49d0	; 0x49d0 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    4642:	20 91 f0 04 	lds	r18, 0x04F0
    4646:	30 91 f1 04 	lds	r19, 0x04F1
    464a:	8c 81       	ldd	r24, Y+4	; 0x04
    464c:	9d 81       	ldd	r25, Y+5	; 0x05
    464e:	82 0f       	add	r24, r18
    4650:	93 1f       	adc	r25, r19
    4652:	9b 83       	std	Y+3, r25	; 0x03
    4654:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4656:	80 91 ec 04 	lds	r24, 0x04EC
    465a:	90 91 ed 04 	lds	r25, 0x04ED
    465e:	02 96       	adiw	r24, 0x02	; 2
    4660:	0e 94 92 19 	call	0x3324	; 0x3324 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    4664:	8a 81       	ldd	r24, Y+2	; 0x02
    4666:	9b 81       	ldd	r25, Y+3	; 0x03
    4668:	0e 94 09 29 	call	0x5212	; 0x5212 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    466c:	0e 94 f4 24 	call	0x49e8	; 0x49e8 <xTaskResumeAll>
    4670:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    4672:	89 81       	ldd	r24, Y+1	; 0x01
    4674:	88 23       	and	r24, r24
    4676:	11 f4       	brne	.+4      	; 0x467c <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    4678:	0e 94 9a 1b 	call	0x3734	; 0x3734 <vPortYield>
		}
	}
    467c:	0f 90       	pop	r0
    467e:	0f 90       	pop	r0
    4680:	0f 90       	pop	r0
    4682:	0f 90       	pop	r0
    4684:	0f 90       	pop	r0
    4686:	cf 91       	pop	r28
    4688:	df 91       	pop	r29
    468a:	08 95       	ret

0000468c <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
    468c:	df 93       	push	r29
    468e:	cf 93       	push	r28
    4690:	00 d0       	rcall	.+0      	; 0x4692 <vTaskSuspend+0x6>
    4692:	00 d0       	rcall	.+0      	; 0x4694 <vTaskSuspend+0x8>
    4694:	00 d0       	rcall	.+0      	; 0x4696 <vTaskSuspend+0xa>
    4696:	cd b7       	in	r28, 0x3d	; 61
    4698:	de b7       	in	r29, 0x3e	; 62
    469a:	9c 83       	std	Y+4, r25	; 0x04
    469c:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    469e:	0f b6       	in	r0, 0x3f	; 63
    46a0:	f8 94       	cli
    46a2:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
    46a4:	20 91 ec 04 	lds	r18, 0x04EC
    46a8:	30 91 ed 04 	lds	r19, 0x04ED
    46ac:	8b 81       	ldd	r24, Y+3	; 0x03
    46ae:	9c 81       	ldd	r25, Y+4	; 0x04
    46b0:	82 17       	cp	r24, r18
    46b2:	93 07       	cpc	r25, r19
    46b4:	11 f4       	brne	.+4      	; 0x46ba <vTaskSuspend+0x2e>
			{
				pxTaskToSuspend = NULL;
    46b6:	1c 82       	std	Y+4, r1	; 0x04
    46b8:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    46ba:	8b 81       	ldd	r24, Y+3	; 0x03
    46bc:	9c 81       	ldd	r25, Y+4	; 0x04
    46be:	00 97       	sbiw	r24, 0x00	; 0
    46c0:	39 f4       	brne	.+14     	; 0x46d0 <vTaskSuspend+0x44>
    46c2:	80 91 ec 04 	lds	r24, 0x04EC
    46c6:	90 91 ed 04 	lds	r25, 0x04ED
    46ca:	9e 83       	std	Y+6, r25	; 0x06
    46cc:	8d 83       	std	Y+5, r24	; 0x05
    46ce:	04 c0       	rjmp	.+8      	; 0x46d8 <vTaskSuspend+0x4c>
    46d0:	8b 81       	ldd	r24, Y+3	; 0x03
    46d2:	9c 81       	ldd	r25, Y+4	; 0x04
    46d4:	9e 83       	std	Y+6, r25	; 0x06
    46d6:	8d 83       	std	Y+5, r24	; 0x05
    46d8:	8d 81       	ldd	r24, Y+5	; 0x05
    46da:	9e 81       	ldd	r25, Y+6	; 0x06
    46dc:	9a 83       	std	Y+2, r25	; 0x02
    46de:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    46e0:	89 81       	ldd	r24, Y+1	; 0x01
    46e2:	9a 81       	ldd	r25, Y+2	; 0x02
    46e4:	02 96       	adiw	r24, 0x02	; 2
    46e6:	0e 94 92 19 	call	0x3324	; 0x3324 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    46ea:	e9 81       	ldd	r30, Y+1	; 0x01
    46ec:	fa 81       	ldd	r31, Y+2	; 0x02
    46ee:	84 89       	ldd	r24, Z+20	; 0x14
    46f0:	95 89       	ldd	r25, Z+21	; 0x15
    46f2:	00 97       	sbiw	r24, 0x00	; 0
    46f4:	29 f0       	breq	.+10     	; 0x4700 <vTaskSuspend+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    46f6:	89 81       	ldd	r24, Y+1	; 0x01
    46f8:	9a 81       	ldd	r25, Y+2	; 0x02
    46fa:	0c 96       	adiw	r24, 0x0c	; 12
    46fc:	0e 94 92 19 	call	0x3324	; 0x3324 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    4700:	89 81       	ldd	r24, Y+1	; 0x01
    4702:	9a 81       	ldd	r25, Y+2	; 0x02
    4704:	9c 01       	movw	r18, r24
    4706:	2e 5f       	subi	r18, 0xFE	; 254
    4708:	3f 4f       	sbci	r19, 0xFF	; 255
    470a:	86 e4       	ldi	r24, 0x46	; 70
    470c:	95 e0       	ldi	r25, 0x05	; 5
    470e:	b9 01       	movw	r22, r18
    4710:	0e 94 da 18 	call	0x31b4	; 0x31b4 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    4714:	0f 90       	pop	r0
    4716:	0f be       	out	0x3f, r0	; 63

		if( ( void * ) pxTaskToSuspend == NULL )
    4718:	8b 81       	ldd	r24, Y+3	; 0x03
    471a:	9c 81       	ldd	r25, Y+4	; 0x04
    471c:	00 97       	sbiw	r24, 0x00	; 0
    471e:	a1 f4       	brne	.+40     	; 0x4748 <vTaskSuspend+0xbc>
		{
			if( xSchedulerRunning != pdFALSE )
    4720:	80 91 f4 04 	lds	r24, 0x04F4
    4724:	88 23       	and	r24, r24
    4726:	19 f0       	breq	.+6      	; 0x472e <vTaskSuspend+0xa2>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
    4728:	0e 94 9a 1b 	call	0x3734	; 0x3734 <vPortYield>
    472c:	0d c0       	rjmp	.+26     	; 0x4748 <vTaskSuspend+0xbc>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    472e:	90 91 46 05 	lds	r25, 0x0546
    4732:	80 91 ef 04 	lds	r24, 0x04EF
    4736:	98 17       	cp	r25, r24
    4738:	29 f4       	brne	.+10     	; 0x4744 <vTaskSuspend+0xb8>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    473a:	10 92 ed 04 	sts	0x04ED, r1
    473e:	10 92 ec 04 	sts	0x04EC, r1
    4742:	02 c0       	rjmp	.+4      	; 0x4748 <vTaskSuspend+0xbc>
				}
				else
				{
					vTaskSwitchContext();
    4744:	0e 94 88 26 	call	0x4d10	; 0x4d10 <vTaskSwitchContext>
				}
			}
		}
	}
    4748:	26 96       	adiw	r28, 0x06	; 6
    474a:	0f b6       	in	r0, 0x3f	; 63
    474c:	f8 94       	cli
    474e:	de bf       	out	0x3e, r29	; 62
    4750:	0f be       	out	0x3f, r0	; 63
    4752:	cd bf       	out	0x3d, r28	; 61
    4754:	cf 91       	pop	r28
    4756:	df 91       	pop	r29
    4758:	08 95       	ret

0000475a <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
    475a:	df 93       	push	r29
    475c:	cf 93       	push	r28
    475e:	00 d0       	rcall	.+0      	; 0x4760 <xTaskIsTaskSuspended+0x6>
    4760:	00 d0       	rcall	.+0      	; 0x4762 <xTaskIsTaskSuspended+0x8>
    4762:	0f 92       	push	r0
    4764:	cd b7       	in	r28, 0x3d	; 61
    4766:	de b7       	in	r29, 0x3e	; 62
    4768:	9d 83       	std	Y+5, r25	; 0x05
    476a:	8c 83       	std	Y+4, r24	; 0x04
	portBASE_TYPE xReturn = pdFALSE;
    476c:	1b 82       	std	Y+3, r1	; 0x03
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
    476e:	8c 81       	ldd	r24, Y+4	; 0x04
    4770:	9d 81       	ldd	r25, Y+5	; 0x05
    4772:	9a 83       	std	Y+2, r25	; 0x02
    4774:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    4776:	e9 81       	ldd	r30, Y+1	; 0x01
    4778:	fa 81       	ldd	r31, Y+2	; 0x02
    477a:	82 85       	ldd	r24, Z+10	; 0x0a
    477c:	93 85       	ldd	r25, Z+11	; 0x0b
    477e:	25 e0       	ldi	r18, 0x05	; 5
    4780:	86 34       	cpi	r24, 0x46	; 70
    4782:	92 07       	cpc	r25, r18
    4784:	81 f4       	brne	.+32     	; 0x47a6 <xTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    4786:	e9 81       	ldd	r30, Y+1	; 0x01
    4788:	fa 81       	ldd	r31, Y+2	; 0x02
    478a:	84 89       	ldd	r24, Z+20	; 0x14
    478c:	95 89       	ldd	r25, Z+21	; 0x15
    478e:	25 e0       	ldi	r18, 0x05	; 5
    4790:	84 33       	cpi	r24, 0x34	; 52
    4792:	92 07       	cpc	r25, r18
    4794:	41 f0       	breq	.+16     	; 0x47a6 <xTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
    4796:	e9 81       	ldd	r30, Y+1	; 0x01
    4798:	fa 81       	ldd	r31, Y+2	; 0x02
    479a:	84 89       	ldd	r24, Z+20	; 0x14
    479c:	95 89       	ldd	r25, Z+21	; 0x15
    479e:	00 97       	sbiw	r24, 0x00	; 0
    47a0:	11 f4       	brne	.+4      	; 0x47a6 <xTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    47a2:	81 e0       	ldi	r24, 0x01	; 1
    47a4:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}

		return xReturn;
    47a6:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    47a8:	0f 90       	pop	r0
    47aa:	0f 90       	pop	r0
    47ac:	0f 90       	pop	r0
    47ae:	0f 90       	pop	r0
    47b0:	0f 90       	pop	r0
    47b2:	cf 91       	pop	r28
    47b4:	df 91       	pop	r29
    47b6:	08 95       	ret

000047b8 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
    47b8:	df 93       	push	r29
    47ba:	cf 93       	push	r28
    47bc:	00 d0       	rcall	.+0      	; 0x47be <vTaskResume+0x6>
    47be:	00 d0       	rcall	.+0      	; 0x47c0 <vTaskResume+0x8>
    47c0:	cd b7       	in	r28, 0x3d	; 61
    47c2:	de b7       	in	r29, 0x3e	; 62
    47c4:	9c 83       	std	Y+4, r25	; 0x04
    47c6:	8b 83       	std	Y+3, r24	; 0x03
		/* It does not make sense to resume the calling task. */
		configASSERT( pxTaskToResume );

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
    47c8:	8b 81       	ldd	r24, Y+3	; 0x03
    47ca:	9c 81       	ldd	r25, Y+4	; 0x04
    47cc:	9a 83       	std	Y+2, r25	; 0x02
    47ce:	89 83       	std	Y+1, r24	; 0x01

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    47d0:	89 81       	ldd	r24, Y+1	; 0x01
    47d2:	9a 81       	ldd	r25, Y+2	; 0x02
    47d4:	00 97       	sbiw	r24, 0x00	; 0
    47d6:	09 f4       	brne	.+2      	; 0x47da <vTaskResume+0x22>
    47d8:	4c c0       	rjmp	.+152    	; 0x4872 <vTaskResume+0xba>
    47da:	20 91 ec 04 	lds	r18, 0x04EC
    47de:	30 91 ed 04 	lds	r19, 0x04ED
    47e2:	89 81       	ldd	r24, Y+1	; 0x01
    47e4:	9a 81       	ldd	r25, Y+2	; 0x02
    47e6:	82 17       	cp	r24, r18
    47e8:	93 07       	cpc	r25, r19
    47ea:	09 f4       	brne	.+2      	; 0x47ee <vTaskResume+0x36>
    47ec:	42 c0       	rjmp	.+132    	; 0x4872 <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    47ee:	0f b6       	in	r0, 0x3f	; 63
    47f0:	f8 94       	cli
    47f2:	0f 92       	push	r0
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    47f4:	89 81       	ldd	r24, Y+1	; 0x01
    47f6:	9a 81       	ldd	r25, Y+2	; 0x02
    47f8:	0e 94 ad 23 	call	0x475a	; 0x475a <xTaskIsTaskSuspended>
    47fc:	81 30       	cpi	r24, 0x01	; 1
    47fe:	b9 f5       	brne	.+110    	; 0x486e <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
    4800:	89 81       	ldd	r24, Y+1	; 0x01
    4802:	9a 81       	ldd	r25, Y+2	; 0x02
    4804:	02 96       	adiw	r24, 0x02	; 2
    4806:	0e 94 92 19 	call	0x3324	; 0x3324 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    480a:	e9 81       	ldd	r30, Y+1	; 0x01
    480c:	fa 81       	ldd	r31, Y+2	; 0x02
    480e:	96 89       	ldd	r25, Z+22	; 0x16
    4810:	80 91 f3 04 	lds	r24, 0x04F3
    4814:	89 17       	cp	r24, r25
    4816:	28 f4       	brcc	.+10     	; 0x4822 <vTaskResume+0x6a>
    4818:	e9 81       	ldd	r30, Y+1	; 0x01
    481a:	fa 81       	ldd	r31, Y+2	; 0x02
    481c:	86 89       	ldd	r24, Z+22	; 0x16
    481e:	80 93 f3 04 	sts	0x04F3, r24
    4822:	e9 81       	ldd	r30, Y+1	; 0x01
    4824:	fa 81       	ldd	r31, Y+2	; 0x02
    4826:	86 89       	ldd	r24, Z+22	; 0x16
    4828:	28 2f       	mov	r18, r24
    482a:	30 e0       	ldi	r19, 0x00	; 0
    482c:	c9 01       	movw	r24, r18
    482e:	88 0f       	add	r24, r24
    4830:	99 1f       	adc	r25, r25
    4832:	88 0f       	add	r24, r24
    4834:	99 1f       	adc	r25, r25
    4836:	88 0f       	add	r24, r24
    4838:	99 1f       	adc	r25, r25
    483a:	82 0f       	add	r24, r18
    483c:	93 1f       	adc	r25, r19
    483e:	ac 01       	movw	r20, r24
    4840:	46 50       	subi	r20, 0x06	; 6
    4842:	5b 4f       	sbci	r21, 0xFB	; 251
    4844:	89 81       	ldd	r24, Y+1	; 0x01
    4846:	9a 81       	ldd	r25, Y+2	; 0x02
    4848:	9c 01       	movw	r18, r24
    484a:	2e 5f       	subi	r18, 0xFE	; 254
    484c:	3f 4f       	sbci	r19, 0xFF	; 255
    484e:	ca 01       	movw	r24, r20
    4850:	b9 01       	movw	r22, r18
    4852:	0e 94 da 18 	call	0x31b4	; 0x31b4 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4856:	e9 81       	ldd	r30, Y+1	; 0x01
    4858:	fa 81       	ldd	r31, Y+2	; 0x02
    485a:	96 89       	ldd	r25, Z+22	; 0x16
    485c:	e0 91 ec 04 	lds	r30, 0x04EC
    4860:	f0 91 ed 04 	lds	r31, 0x04ED
    4864:	86 89       	ldd	r24, Z+22	; 0x16
    4866:	98 17       	cp	r25, r24
    4868:	10 f0       	brcs	.+4      	; 0x486e <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
    486a:	0e 94 9a 1b 	call	0x3734	; 0x3734 <vPortYield>
					}
				}
			}
			taskEXIT_CRITICAL();
    486e:	0f 90       	pop	r0
    4870:	0f be       	out	0x3f, r0	; 63
		}
	}
    4872:	0f 90       	pop	r0
    4874:	0f 90       	pop	r0
    4876:	0f 90       	pop	r0
    4878:	0f 90       	pop	r0
    487a:	cf 91       	pop	r28
    487c:	df 91       	pop	r29
    487e:	08 95       	ret

00004880 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
    4880:	df 93       	push	r29
    4882:	cf 93       	push	r28
    4884:	00 d0       	rcall	.+0      	; 0x4886 <xTaskResumeFromISR+0x6>
    4886:	00 d0       	rcall	.+0      	; 0x4888 <xTaskResumeFromISR+0x8>
    4888:	0f 92       	push	r0
    488a:	cd b7       	in	r28, 0x3d	; 61
    488c:	de b7       	in	r29, 0x3e	; 62
    488e:	9d 83       	std	Y+5, r25	; 0x05
    4890:	8c 83       	std	Y+4, r24	; 0x04
	portBASE_TYPE xYieldRequired = pdFALSE;
    4892:	1b 82       	std	Y+3, r1	; 0x03
	tskTCB *pxTCB;

		configASSERT( pxTaskToResume );

		pxTCB = ( tskTCB * ) pxTaskToResume;
    4894:	8c 81       	ldd	r24, Y+4	; 0x04
    4896:	9d 81       	ldd	r25, Y+5	; 0x05
    4898:	9a 83       	std	Y+2, r25	; 0x02
    489a:	89 83       	std	Y+1, r24	; 0x01

		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    489c:	89 81       	ldd	r24, Y+1	; 0x01
    489e:	9a 81       	ldd	r25, Y+2	; 0x02
    48a0:	0e 94 ad 23 	call	0x475a	; 0x475a <xTaskIsTaskSuspended>
    48a4:	81 30       	cpi	r24, 0x01	; 1
    48a6:	09 f0       	breq	.+2      	; 0x48aa <xTaskResumeFromISR+0x2a>
    48a8:	47 c0       	rjmp	.+142    	; 0x4938 <xTaskResumeFromISR+0xb8>
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    48aa:	80 91 f5 04 	lds	r24, 0x04F5
    48ae:	88 23       	and	r24, r24
    48b0:	c9 f5       	brne	.+114    	; 0x4924 <xTaskResumeFromISR+0xa4>
			{
				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    48b2:	e9 81       	ldd	r30, Y+1	; 0x01
    48b4:	fa 81       	ldd	r31, Y+2	; 0x02
    48b6:	96 89       	ldd	r25, Z+22	; 0x16
    48b8:	e0 91 ec 04 	lds	r30, 0x04EC
    48bc:	f0 91 ed 04 	lds	r31, 0x04ED
    48c0:	86 89       	ldd	r24, Z+22	; 0x16
    48c2:	1b 82       	std	Y+3, r1	; 0x03
    48c4:	98 17       	cp	r25, r24
    48c6:	10 f0       	brcs	.+4      	; 0x48cc <xTaskResumeFromISR+0x4c>
    48c8:	81 e0       	ldi	r24, 0x01	; 1
    48ca:	8b 83       	std	Y+3, r24	; 0x03
				vListRemove(  &( pxTCB->xGenericListItem ) );
    48cc:	89 81       	ldd	r24, Y+1	; 0x01
    48ce:	9a 81       	ldd	r25, Y+2	; 0x02
    48d0:	02 96       	adiw	r24, 0x02	; 2
    48d2:	0e 94 92 19 	call	0x3324	; 0x3324 <vListRemove>
				prvAddTaskToReadyQueue( pxTCB );
    48d6:	e9 81       	ldd	r30, Y+1	; 0x01
    48d8:	fa 81       	ldd	r31, Y+2	; 0x02
    48da:	96 89       	ldd	r25, Z+22	; 0x16
    48dc:	80 91 f3 04 	lds	r24, 0x04F3
    48e0:	89 17       	cp	r24, r25
    48e2:	28 f4       	brcc	.+10     	; 0x48ee <xTaskResumeFromISR+0x6e>
    48e4:	e9 81       	ldd	r30, Y+1	; 0x01
    48e6:	fa 81       	ldd	r31, Y+2	; 0x02
    48e8:	86 89       	ldd	r24, Z+22	; 0x16
    48ea:	80 93 f3 04 	sts	0x04F3, r24
    48ee:	e9 81       	ldd	r30, Y+1	; 0x01
    48f0:	fa 81       	ldd	r31, Y+2	; 0x02
    48f2:	86 89       	ldd	r24, Z+22	; 0x16
    48f4:	28 2f       	mov	r18, r24
    48f6:	30 e0       	ldi	r19, 0x00	; 0
    48f8:	c9 01       	movw	r24, r18
    48fa:	88 0f       	add	r24, r24
    48fc:	99 1f       	adc	r25, r25
    48fe:	88 0f       	add	r24, r24
    4900:	99 1f       	adc	r25, r25
    4902:	88 0f       	add	r24, r24
    4904:	99 1f       	adc	r25, r25
    4906:	82 0f       	add	r24, r18
    4908:	93 1f       	adc	r25, r19
    490a:	ac 01       	movw	r20, r24
    490c:	46 50       	subi	r20, 0x06	; 6
    490e:	5b 4f       	sbci	r21, 0xFB	; 251
    4910:	89 81       	ldd	r24, Y+1	; 0x01
    4912:	9a 81       	ldd	r25, Y+2	; 0x02
    4914:	9c 01       	movw	r18, r24
    4916:	2e 5f       	subi	r18, 0xFE	; 254
    4918:	3f 4f       	sbci	r19, 0xFF	; 255
    491a:	ca 01       	movw	r24, r20
    491c:	b9 01       	movw	r22, r18
    491e:	0e 94 da 18 	call	0x31b4	; 0x31b4 <vListInsertEnd>
    4922:	0a c0       	rjmp	.+20     	; 0x4938 <xTaskResumeFromISR+0xb8>
			else
			{
				/* We cannot access the delayed or ready lists, so will hold this
				task pending until the scheduler is resumed, at which point a
				yield will be performed if necessary. */
				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4924:	89 81       	ldd	r24, Y+1	; 0x01
    4926:	9a 81       	ldd	r25, Y+2	; 0x02
    4928:	9c 01       	movw	r18, r24
    492a:	24 5f       	subi	r18, 0xF4	; 244
    492c:	3f 4f       	sbci	r19, 0xFF	; 255
    492e:	84 e3       	ldi	r24, 0x34	; 52
    4930:	95 e0       	ldi	r25, 0x05	; 5
    4932:	b9 01       	movw	r22, r18
    4934:	0e 94 da 18 	call	0x31b4	; 0x31b4 <vListInsertEnd>
			}
		}

		return xYieldRequired;
    4938:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    493a:	0f 90       	pop	r0
    493c:	0f 90       	pop	r0
    493e:	0f 90       	pop	r0
    4940:	0f 90       	pop	r0
    4942:	0f 90       	pop	r0
    4944:	cf 91       	pop	r28
    4946:	df 91       	pop	r29
    4948:	08 95       	ret

0000494a <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    494a:	af 92       	push	r10
    494c:	bf 92       	push	r11
    494e:	cf 92       	push	r12
    4950:	df 92       	push	r13
    4952:	ef 92       	push	r14
    4954:	ff 92       	push	r15
    4956:	0f 93       	push	r16
    4958:	df 93       	push	r29
    495a:	cf 93       	push	r28
    495c:	0f 92       	push	r0
    495e:	cd b7       	in	r28, 0x3d	; 61
    4960:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    4962:	20 e6       	ldi	r18, 0x60	; 96
    4964:	30 e0       	ldi	r19, 0x00	; 0
    4966:	89 e2       	ldi	r24, 0x29	; 41
    4968:	98 e2       	ldi	r25, 0x28	; 40
    496a:	b9 01       	movw	r22, r18
    496c:	4a ef       	ldi	r20, 0xFA	; 250
    496e:	50 e0       	ldi	r21, 0x00	; 0
    4970:	20 e0       	ldi	r18, 0x00	; 0
    4972:	30 e0       	ldi	r19, 0x00	; 0
    4974:	00 e0       	ldi	r16, 0x00	; 0
    4976:	ee 24       	eor	r14, r14
    4978:	ff 24       	eor	r15, r15
    497a:	cc 24       	eor	r12, r12
    497c:	dd 24       	eor	r13, r13
    497e:	aa 24       	eor	r10, r10
    4980:	bb 24       	eor	r11, r11
    4982:	0e 94 4d 21 	call	0x429a	; 0x429a <xTaskGenericCreate>
    4986:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    4988:	89 81       	ldd	r24, Y+1	; 0x01
    498a:	81 30       	cpi	r24, 0x01	; 1
    498c:	51 f4       	brne	.+20     	; 0x49a2 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    498e:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    4990:	81 e0       	ldi	r24, 0x01	; 1
    4992:	80 93 f4 04 	sts	0x04F4, r24
		xTickCount = ( portTickType ) 0U;
    4996:	10 92 f1 04 	sts	0x04F1, r1
    499a:	10 92 f0 04 	sts	0x04F0, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    499e:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    49a2:	0f 90       	pop	r0
    49a4:	cf 91       	pop	r28
    49a6:	df 91       	pop	r29
    49a8:	0f 91       	pop	r16
    49aa:	ff 90       	pop	r15
    49ac:	ef 90       	pop	r14
    49ae:	df 90       	pop	r13
    49b0:	cf 90       	pop	r12
    49b2:	bf 90       	pop	r11
    49b4:	af 90       	pop	r10
    49b6:	08 95       	ret

000049b8 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    49b8:	df 93       	push	r29
    49ba:	cf 93       	push	r28
    49bc:	cd b7       	in	r28, 0x3d	; 61
    49be:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    49c0:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    49c2:	10 92 f4 04 	sts	0x04F4, r1
	vPortEndScheduler();
    49c6:	0e 94 93 1b 	call	0x3726	; 0x3726 <vPortEndScheduler>
}
    49ca:	cf 91       	pop	r28
    49cc:	df 91       	pop	r29
    49ce:	08 95       	ret

000049d0 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    49d0:	df 93       	push	r29
    49d2:	cf 93       	push	r28
    49d4:	cd b7       	in	r28, 0x3d	; 61
    49d6:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    49d8:	80 91 f5 04 	lds	r24, 0x04F5
    49dc:	8f 5f       	subi	r24, 0xFF	; 255
    49de:	80 93 f5 04 	sts	0x04F5, r24
}
    49e2:	cf 91       	pop	r28
    49e4:	df 91       	pop	r29
    49e6:	08 95       	ret

000049e8 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    49e8:	df 93       	push	r29
    49ea:	cf 93       	push	r28
    49ec:	00 d0       	rcall	.+0      	; 0x49ee <xTaskResumeAll+0x6>
    49ee:	00 d0       	rcall	.+0      	; 0x49f0 <xTaskResumeAll+0x8>
    49f0:	cd b7       	in	r28, 0x3d	; 61
    49f2:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    49f4:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    49f6:	0f b6       	in	r0, 0x3f	; 63
    49f8:	f8 94       	cli
    49fa:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    49fc:	80 91 f5 04 	lds	r24, 0x04F5
    4a00:	81 50       	subi	r24, 0x01	; 1
    4a02:	80 93 f5 04 	sts	0x04F5, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    4a06:	80 91 f5 04 	lds	r24, 0x04F5
    4a0a:	88 23       	and	r24, r24
    4a0c:	09 f0       	breq	.+2      	; 0x4a10 <xTaskResumeAll+0x28>
    4a0e:	6c c0       	rjmp	.+216    	; 0x4ae8 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    4a10:	80 91 ef 04 	lds	r24, 0x04EF
    4a14:	88 23       	and	r24, r24
    4a16:	09 f4       	brne	.+2      	; 0x4a1a <xTaskResumeAll+0x32>
    4a18:	67 c0       	rjmp	.+206    	; 0x4ae8 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    4a1a:	19 82       	std	Y+1, r1	; 0x01
    4a1c:	41 c0       	rjmp	.+130    	; 0x4aa0 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    4a1e:	e0 91 39 05 	lds	r30, 0x0539
    4a22:	f0 91 3a 05 	lds	r31, 0x053A
    4a26:	86 81       	ldd	r24, Z+6	; 0x06
    4a28:	97 81       	ldd	r25, Z+7	; 0x07
    4a2a:	9c 83       	std	Y+4, r25	; 0x04
    4a2c:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    4a2e:	8b 81       	ldd	r24, Y+3	; 0x03
    4a30:	9c 81       	ldd	r25, Y+4	; 0x04
    4a32:	0c 96       	adiw	r24, 0x0c	; 12
    4a34:	0e 94 92 19 	call	0x3324	; 0x3324 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    4a38:	8b 81       	ldd	r24, Y+3	; 0x03
    4a3a:	9c 81       	ldd	r25, Y+4	; 0x04
    4a3c:	02 96       	adiw	r24, 0x02	; 2
    4a3e:	0e 94 92 19 	call	0x3324	; 0x3324 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    4a42:	eb 81       	ldd	r30, Y+3	; 0x03
    4a44:	fc 81       	ldd	r31, Y+4	; 0x04
    4a46:	96 89       	ldd	r25, Z+22	; 0x16
    4a48:	80 91 f3 04 	lds	r24, 0x04F3
    4a4c:	89 17       	cp	r24, r25
    4a4e:	28 f4       	brcc	.+10     	; 0x4a5a <xTaskResumeAll+0x72>
    4a50:	eb 81       	ldd	r30, Y+3	; 0x03
    4a52:	fc 81       	ldd	r31, Y+4	; 0x04
    4a54:	86 89       	ldd	r24, Z+22	; 0x16
    4a56:	80 93 f3 04 	sts	0x04F3, r24
    4a5a:	eb 81       	ldd	r30, Y+3	; 0x03
    4a5c:	fc 81       	ldd	r31, Y+4	; 0x04
    4a5e:	86 89       	ldd	r24, Z+22	; 0x16
    4a60:	28 2f       	mov	r18, r24
    4a62:	30 e0       	ldi	r19, 0x00	; 0
    4a64:	c9 01       	movw	r24, r18
    4a66:	88 0f       	add	r24, r24
    4a68:	99 1f       	adc	r25, r25
    4a6a:	88 0f       	add	r24, r24
    4a6c:	99 1f       	adc	r25, r25
    4a6e:	88 0f       	add	r24, r24
    4a70:	99 1f       	adc	r25, r25
    4a72:	82 0f       	add	r24, r18
    4a74:	93 1f       	adc	r25, r19
    4a76:	86 50       	subi	r24, 0x06	; 6
    4a78:	9b 4f       	sbci	r25, 0xFB	; 251
    4a7a:	2b 81       	ldd	r18, Y+3	; 0x03
    4a7c:	3c 81       	ldd	r19, Y+4	; 0x04
    4a7e:	2e 5f       	subi	r18, 0xFE	; 254
    4a80:	3f 4f       	sbci	r19, 0xFF	; 255
    4a82:	b9 01       	movw	r22, r18
    4a84:	0e 94 da 18 	call	0x31b4	; 0x31b4 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4a88:	eb 81       	ldd	r30, Y+3	; 0x03
    4a8a:	fc 81       	ldd	r31, Y+4	; 0x04
    4a8c:	96 89       	ldd	r25, Z+22	; 0x16
    4a8e:	e0 91 ec 04 	lds	r30, 0x04EC
    4a92:	f0 91 ed 04 	lds	r31, 0x04ED
    4a96:	86 89       	ldd	r24, Z+22	; 0x16
    4a98:	98 17       	cp	r25, r24
    4a9a:	10 f0       	brcs	.+4      	; 0x4aa0 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    4a9c:	81 e0       	ldi	r24, 0x01	; 1
    4a9e:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    4aa0:	80 91 34 05 	lds	r24, 0x0534
    4aa4:	88 23       	and	r24, r24
    4aa6:	09 f0       	breq	.+2      	; 0x4aaa <xTaskResumeAll+0xc2>
    4aa8:	ba cf       	rjmp	.-140    	; 0x4a1e <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    4aaa:	80 91 f6 04 	lds	r24, 0x04F6
    4aae:	88 23       	and	r24, r24
    4ab0:	71 f0       	breq	.+28     	; 0x4ace <xTaskResumeAll+0xe6>
    4ab2:	07 c0       	rjmp	.+14     	; 0x4ac2 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    4ab4:	0e 94 b3 25 	call	0x4b66	; 0x4b66 <vTaskIncrementTick>
						--uxMissedTicks;
    4ab8:	80 91 f6 04 	lds	r24, 0x04F6
    4abc:	81 50       	subi	r24, 0x01	; 1
    4abe:	80 93 f6 04 	sts	0x04F6, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    4ac2:	80 91 f6 04 	lds	r24, 0x04F6
    4ac6:	88 23       	and	r24, r24
    4ac8:	a9 f7       	brne	.-22     	; 0x4ab4 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    4aca:	81 e0       	ldi	r24, 0x01	; 1
    4acc:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    4ace:	89 81       	ldd	r24, Y+1	; 0x01
    4ad0:	81 30       	cpi	r24, 0x01	; 1
    4ad2:	21 f0       	breq	.+8      	; 0x4adc <xTaskResumeAll+0xf4>
    4ad4:	80 91 f7 04 	lds	r24, 0x04F7
    4ad8:	81 30       	cpi	r24, 0x01	; 1
    4ada:	31 f4       	brne	.+12     	; 0x4ae8 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    4adc:	81 e0       	ldi	r24, 0x01	; 1
    4ade:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    4ae0:	10 92 f7 04 	sts	0x04F7, r1
					portYIELD_WITHIN_API();
    4ae4:	0e 94 9a 1b 	call	0x3734	; 0x3734 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    4ae8:	0f 90       	pop	r0
    4aea:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    4aec:	8a 81       	ldd	r24, Y+2	; 0x02
}
    4aee:	0f 90       	pop	r0
    4af0:	0f 90       	pop	r0
    4af2:	0f 90       	pop	r0
    4af4:	0f 90       	pop	r0
    4af6:	cf 91       	pop	r28
    4af8:	df 91       	pop	r29
    4afa:	08 95       	ret

00004afc <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    4afc:	df 93       	push	r29
    4afe:	cf 93       	push	r28
    4b00:	00 d0       	rcall	.+0      	; 0x4b02 <xTaskGetTickCount+0x6>
    4b02:	cd b7       	in	r28, 0x3d	; 61
    4b04:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    4b06:	0f b6       	in	r0, 0x3f	; 63
    4b08:	f8 94       	cli
    4b0a:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    4b0c:	80 91 f0 04 	lds	r24, 0x04F0
    4b10:	90 91 f1 04 	lds	r25, 0x04F1
    4b14:	9a 83       	std	Y+2, r25	; 0x02
    4b16:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    4b18:	0f 90       	pop	r0
    4b1a:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    4b1c:	89 81       	ldd	r24, Y+1	; 0x01
    4b1e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4b20:	0f 90       	pop	r0
    4b22:	0f 90       	pop	r0
    4b24:	cf 91       	pop	r28
    4b26:	df 91       	pop	r29
    4b28:	08 95       	ret

00004b2a <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    4b2a:	df 93       	push	r29
    4b2c:	cf 93       	push	r28
    4b2e:	00 d0       	rcall	.+0      	; 0x4b30 <xTaskGetTickCountFromISR+0x6>
    4b30:	0f 92       	push	r0
    4b32:	cd b7       	in	r28, 0x3d	; 61
    4b34:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4b36:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    4b38:	80 91 f0 04 	lds	r24, 0x04F0
    4b3c:	90 91 f1 04 	lds	r25, 0x04F1
    4b40:	9b 83       	std	Y+3, r25	; 0x03
    4b42:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4b44:	8a 81       	ldd	r24, Y+2	; 0x02
    4b46:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4b48:	0f 90       	pop	r0
    4b4a:	0f 90       	pop	r0
    4b4c:	0f 90       	pop	r0
    4b4e:	cf 91       	pop	r28
    4b50:	df 91       	pop	r29
    4b52:	08 95       	ret

00004b54 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    4b54:	df 93       	push	r29
    4b56:	cf 93       	push	r28
    4b58:	cd b7       	in	r28, 0x3d	; 61
    4b5a:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    4b5c:	80 91 ef 04 	lds	r24, 0x04EF
}
    4b60:	cf 91       	pop	r28
    4b62:	df 91       	pop	r29
    4b64:	08 95       	ret

00004b66 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    4b66:	df 93       	push	r29
    4b68:	cf 93       	push	r28
    4b6a:	00 d0       	rcall	.+0      	; 0x4b6c <vTaskIncrementTick+0x6>
    4b6c:	00 d0       	rcall	.+0      	; 0x4b6e <vTaskIncrementTick+0x8>
    4b6e:	00 d0       	rcall	.+0      	; 0x4b70 <vTaskIncrementTick+0xa>
    4b70:	cd b7       	in	r28, 0x3d	; 61
    4b72:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    4b74:	80 91 f5 04 	lds	r24, 0x04F5
    4b78:	88 23       	and	r24, r24
    4b7a:	09 f0       	breq	.+2      	; 0x4b7e <vTaskIncrementTick+0x18>
    4b7c:	bb c0       	rjmp	.+374    	; 0x4cf4 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    4b7e:	80 91 f0 04 	lds	r24, 0x04F0
    4b82:	90 91 f1 04 	lds	r25, 0x04F1
    4b86:	01 96       	adiw	r24, 0x01	; 1
    4b88:	90 93 f1 04 	sts	0x04F1, r25
    4b8c:	80 93 f0 04 	sts	0x04F0, r24
		if( xTickCount == ( portTickType ) 0U )
    4b90:	80 91 f0 04 	lds	r24, 0x04F0
    4b94:	90 91 f1 04 	lds	r25, 0x04F1
    4b98:	00 97       	sbiw	r24, 0x00	; 0
    4b9a:	d1 f5       	brne	.+116    	; 0x4c10 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    4b9c:	80 91 30 05 	lds	r24, 0x0530
    4ba0:	90 91 31 05 	lds	r25, 0x0531
    4ba4:	9c 83       	std	Y+4, r25	; 0x04
    4ba6:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    4ba8:	80 91 32 05 	lds	r24, 0x0532
    4bac:	90 91 33 05 	lds	r25, 0x0533
    4bb0:	90 93 31 05 	sts	0x0531, r25
    4bb4:	80 93 30 05 	sts	0x0530, r24
			pxOverflowDelayedTaskList = pxTemp;
    4bb8:	8b 81       	ldd	r24, Y+3	; 0x03
    4bba:	9c 81       	ldd	r25, Y+4	; 0x04
    4bbc:	90 93 33 05 	sts	0x0533, r25
    4bc0:	80 93 32 05 	sts	0x0532, r24
			xNumOfOverflows++;
    4bc4:	80 91 f8 04 	lds	r24, 0x04F8
    4bc8:	8f 5f       	subi	r24, 0xFF	; 255
    4bca:	80 93 f8 04 	sts	0x04F8, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4bce:	e0 91 30 05 	lds	r30, 0x0530
    4bd2:	f0 91 31 05 	lds	r31, 0x0531
    4bd6:	80 81       	ld	r24, Z
    4bd8:	88 23       	and	r24, r24
    4bda:	39 f4       	brne	.+14     	; 0x4bea <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    4bdc:	8f ef       	ldi	r24, 0xFF	; 255
    4bde:	9f ef       	ldi	r25, 0xFF	; 255
    4be0:	90 93 80 00 	sts	0x0080, r25
    4be4:	80 93 7f 00 	sts	0x007F, r24
    4be8:	13 c0       	rjmp	.+38     	; 0x4c10 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    4bea:	e0 91 30 05 	lds	r30, 0x0530
    4bee:	f0 91 31 05 	lds	r31, 0x0531
    4bf2:	05 80       	ldd	r0, Z+5	; 0x05
    4bf4:	f6 81       	ldd	r31, Z+6	; 0x06
    4bf6:	e0 2d       	mov	r30, r0
    4bf8:	86 81       	ldd	r24, Z+6	; 0x06
    4bfa:	97 81       	ldd	r25, Z+7	; 0x07
    4bfc:	9e 83       	std	Y+6, r25	; 0x06
    4bfe:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    4c00:	ed 81       	ldd	r30, Y+5	; 0x05
    4c02:	fe 81       	ldd	r31, Y+6	; 0x06
    4c04:	82 81       	ldd	r24, Z+2	; 0x02
    4c06:	93 81       	ldd	r25, Z+3	; 0x03
    4c08:	90 93 80 00 	sts	0x0080, r25
    4c0c:	80 93 7f 00 	sts	0x007F, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    4c10:	20 91 f0 04 	lds	r18, 0x04F0
    4c14:	30 91 f1 04 	lds	r19, 0x04F1
    4c18:	80 91 7f 00 	lds	r24, 0x007F
    4c1c:	90 91 80 00 	lds	r25, 0x0080
    4c20:	28 17       	cp	r18, r24
    4c22:	39 07       	cpc	r19, r25
    4c24:	08 f4       	brcc	.+2      	; 0x4c28 <vTaskIncrementTick+0xc2>
    4c26:	6b c0       	rjmp	.+214    	; 0x4cfe <vTaskIncrementTick+0x198>
    4c28:	e0 91 30 05 	lds	r30, 0x0530
    4c2c:	f0 91 31 05 	lds	r31, 0x0531
    4c30:	80 81       	ld	r24, Z
    4c32:	88 23       	and	r24, r24
    4c34:	39 f4       	brne	.+14     	; 0x4c44 <vTaskIncrementTick+0xde>
    4c36:	8f ef       	ldi	r24, 0xFF	; 255
    4c38:	9f ef       	ldi	r25, 0xFF	; 255
    4c3a:	90 93 80 00 	sts	0x0080, r25
    4c3e:	80 93 7f 00 	sts	0x007F, r24
    4c42:	5d c0       	rjmp	.+186    	; 0x4cfe <vTaskIncrementTick+0x198>
    4c44:	e0 91 30 05 	lds	r30, 0x0530
    4c48:	f0 91 31 05 	lds	r31, 0x0531
    4c4c:	05 80       	ldd	r0, Z+5	; 0x05
    4c4e:	f6 81       	ldd	r31, Z+6	; 0x06
    4c50:	e0 2d       	mov	r30, r0
    4c52:	86 81       	ldd	r24, Z+6	; 0x06
    4c54:	97 81       	ldd	r25, Z+7	; 0x07
    4c56:	9e 83       	std	Y+6, r25	; 0x06
    4c58:	8d 83       	std	Y+5, r24	; 0x05
    4c5a:	ed 81       	ldd	r30, Y+5	; 0x05
    4c5c:	fe 81       	ldd	r31, Y+6	; 0x06
    4c5e:	82 81       	ldd	r24, Z+2	; 0x02
    4c60:	93 81       	ldd	r25, Z+3	; 0x03
    4c62:	9a 83       	std	Y+2, r25	; 0x02
    4c64:	89 83       	std	Y+1, r24	; 0x01
    4c66:	20 91 f0 04 	lds	r18, 0x04F0
    4c6a:	30 91 f1 04 	lds	r19, 0x04F1
    4c6e:	89 81       	ldd	r24, Y+1	; 0x01
    4c70:	9a 81       	ldd	r25, Y+2	; 0x02
    4c72:	28 17       	cp	r18, r24
    4c74:	39 07       	cpc	r19, r25
    4c76:	38 f4       	brcc	.+14     	; 0x4c86 <vTaskIncrementTick+0x120>
    4c78:	89 81       	ldd	r24, Y+1	; 0x01
    4c7a:	9a 81       	ldd	r25, Y+2	; 0x02
    4c7c:	90 93 80 00 	sts	0x0080, r25
    4c80:	80 93 7f 00 	sts	0x007F, r24
    4c84:	3c c0       	rjmp	.+120    	; 0x4cfe <vTaskIncrementTick+0x198>
    4c86:	8d 81       	ldd	r24, Y+5	; 0x05
    4c88:	9e 81       	ldd	r25, Y+6	; 0x06
    4c8a:	02 96       	adiw	r24, 0x02	; 2
    4c8c:	0e 94 92 19 	call	0x3324	; 0x3324 <vListRemove>
    4c90:	ed 81       	ldd	r30, Y+5	; 0x05
    4c92:	fe 81       	ldd	r31, Y+6	; 0x06
    4c94:	84 89       	ldd	r24, Z+20	; 0x14
    4c96:	95 89       	ldd	r25, Z+21	; 0x15
    4c98:	00 97       	sbiw	r24, 0x00	; 0
    4c9a:	29 f0       	breq	.+10     	; 0x4ca6 <vTaskIncrementTick+0x140>
    4c9c:	8d 81       	ldd	r24, Y+5	; 0x05
    4c9e:	9e 81       	ldd	r25, Y+6	; 0x06
    4ca0:	0c 96       	adiw	r24, 0x0c	; 12
    4ca2:	0e 94 92 19 	call	0x3324	; 0x3324 <vListRemove>
    4ca6:	ed 81       	ldd	r30, Y+5	; 0x05
    4ca8:	fe 81       	ldd	r31, Y+6	; 0x06
    4caa:	96 89       	ldd	r25, Z+22	; 0x16
    4cac:	80 91 f3 04 	lds	r24, 0x04F3
    4cb0:	89 17       	cp	r24, r25
    4cb2:	28 f4       	brcc	.+10     	; 0x4cbe <vTaskIncrementTick+0x158>
    4cb4:	ed 81       	ldd	r30, Y+5	; 0x05
    4cb6:	fe 81       	ldd	r31, Y+6	; 0x06
    4cb8:	86 89       	ldd	r24, Z+22	; 0x16
    4cba:	80 93 f3 04 	sts	0x04F3, r24
    4cbe:	ed 81       	ldd	r30, Y+5	; 0x05
    4cc0:	fe 81       	ldd	r31, Y+6	; 0x06
    4cc2:	86 89       	ldd	r24, Z+22	; 0x16
    4cc4:	28 2f       	mov	r18, r24
    4cc6:	30 e0       	ldi	r19, 0x00	; 0
    4cc8:	c9 01       	movw	r24, r18
    4cca:	88 0f       	add	r24, r24
    4ccc:	99 1f       	adc	r25, r25
    4cce:	88 0f       	add	r24, r24
    4cd0:	99 1f       	adc	r25, r25
    4cd2:	88 0f       	add	r24, r24
    4cd4:	99 1f       	adc	r25, r25
    4cd6:	82 0f       	add	r24, r18
    4cd8:	93 1f       	adc	r25, r19
    4cda:	ac 01       	movw	r20, r24
    4cdc:	46 50       	subi	r20, 0x06	; 6
    4cde:	5b 4f       	sbci	r21, 0xFB	; 251
    4ce0:	8d 81       	ldd	r24, Y+5	; 0x05
    4ce2:	9e 81       	ldd	r25, Y+6	; 0x06
    4ce4:	9c 01       	movw	r18, r24
    4ce6:	2e 5f       	subi	r18, 0xFE	; 254
    4ce8:	3f 4f       	sbci	r19, 0xFF	; 255
    4cea:	ca 01       	movw	r24, r20
    4cec:	b9 01       	movw	r22, r18
    4cee:	0e 94 da 18 	call	0x31b4	; 0x31b4 <vListInsertEnd>
    4cf2:	9a cf       	rjmp	.-204    	; 0x4c28 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    4cf4:	80 91 f6 04 	lds	r24, 0x04F6
    4cf8:	8f 5f       	subi	r24, 0xFF	; 255
    4cfa:	80 93 f6 04 	sts	0x04F6, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    4cfe:	26 96       	adiw	r28, 0x06	; 6
    4d00:	0f b6       	in	r0, 0x3f	; 63
    4d02:	f8 94       	cli
    4d04:	de bf       	out	0x3e, r29	; 62
    4d06:	0f be       	out	0x3f, r0	; 63
    4d08:	cd bf       	out	0x3d, r28	; 61
    4d0a:	cf 91       	pop	r28
    4d0c:	df 91       	pop	r29
    4d0e:	08 95       	ret

00004d10 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    4d10:	df 93       	push	r29
    4d12:	cf 93       	push	r28
    4d14:	00 d0       	rcall	.+0      	; 0x4d16 <vTaskSwitchContext+0x6>
    4d16:	cd b7       	in	r28, 0x3d	; 61
    4d18:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    4d1a:	80 91 f5 04 	lds	r24, 0x04F5
    4d1e:	88 23       	and	r24, r24
    4d20:	49 f0       	breq	.+18     	; 0x4d34 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    4d22:	81 e0       	ldi	r24, 0x01	; 1
    4d24:	80 93 f7 04 	sts	0x04F7, r24
    4d28:	54 c0       	rjmp	.+168    	; 0x4dd2 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    4d2a:	80 91 f3 04 	lds	r24, 0x04F3
    4d2e:	81 50       	subi	r24, 0x01	; 1
    4d30:	80 93 f3 04 	sts	0x04F3, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    4d34:	80 91 f3 04 	lds	r24, 0x04F3
    4d38:	28 2f       	mov	r18, r24
    4d3a:	30 e0       	ldi	r19, 0x00	; 0
    4d3c:	c9 01       	movw	r24, r18
    4d3e:	88 0f       	add	r24, r24
    4d40:	99 1f       	adc	r25, r25
    4d42:	88 0f       	add	r24, r24
    4d44:	99 1f       	adc	r25, r25
    4d46:	88 0f       	add	r24, r24
    4d48:	99 1f       	adc	r25, r25
    4d4a:	82 0f       	add	r24, r18
    4d4c:	93 1f       	adc	r25, r19
    4d4e:	fc 01       	movw	r30, r24
    4d50:	e6 50       	subi	r30, 0x06	; 6
    4d52:	fb 4f       	sbci	r31, 0xFB	; 251
    4d54:	80 81       	ld	r24, Z
    4d56:	88 23       	and	r24, r24
    4d58:	41 f3       	breq	.-48     	; 0x4d2a <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    4d5a:	80 91 f3 04 	lds	r24, 0x04F3
    4d5e:	28 2f       	mov	r18, r24
    4d60:	30 e0       	ldi	r19, 0x00	; 0
    4d62:	c9 01       	movw	r24, r18
    4d64:	88 0f       	add	r24, r24
    4d66:	99 1f       	adc	r25, r25
    4d68:	88 0f       	add	r24, r24
    4d6a:	99 1f       	adc	r25, r25
    4d6c:	88 0f       	add	r24, r24
    4d6e:	99 1f       	adc	r25, r25
    4d70:	82 0f       	add	r24, r18
    4d72:	93 1f       	adc	r25, r19
    4d74:	86 50       	subi	r24, 0x06	; 6
    4d76:	9b 4f       	sbci	r25, 0xFB	; 251
    4d78:	9a 83       	std	Y+2, r25	; 0x02
    4d7a:	89 83       	std	Y+1, r24	; 0x01
    4d7c:	e9 81       	ldd	r30, Y+1	; 0x01
    4d7e:	fa 81       	ldd	r31, Y+2	; 0x02
    4d80:	01 80       	ldd	r0, Z+1	; 0x01
    4d82:	f2 81       	ldd	r31, Z+2	; 0x02
    4d84:	e0 2d       	mov	r30, r0
    4d86:	82 81       	ldd	r24, Z+2	; 0x02
    4d88:	93 81       	ldd	r25, Z+3	; 0x03
    4d8a:	e9 81       	ldd	r30, Y+1	; 0x01
    4d8c:	fa 81       	ldd	r31, Y+2	; 0x02
    4d8e:	92 83       	std	Z+2, r25	; 0x02
    4d90:	81 83       	std	Z+1, r24	; 0x01
    4d92:	e9 81       	ldd	r30, Y+1	; 0x01
    4d94:	fa 81       	ldd	r31, Y+2	; 0x02
    4d96:	21 81       	ldd	r18, Z+1	; 0x01
    4d98:	32 81       	ldd	r19, Z+2	; 0x02
    4d9a:	89 81       	ldd	r24, Y+1	; 0x01
    4d9c:	9a 81       	ldd	r25, Y+2	; 0x02
    4d9e:	03 96       	adiw	r24, 0x03	; 3
    4da0:	28 17       	cp	r18, r24
    4da2:	39 07       	cpc	r19, r25
    4da4:	59 f4       	brne	.+22     	; 0x4dbc <vTaskSwitchContext+0xac>
    4da6:	e9 81       	ldd	r30, Y+1	; 0x01
    4da8:	fa 81       	ldd	r31, Y+2	; 0x02
    4daa:	01 80       	ldd	r0, Z+1	; 0x01
    4dac:	f2 81       	ldd	r31, Z+2	; 0x02
    4dae:	e0 2d       	mov	r30, r0
    4db0:	82 81       	ldd	r24, Z+2	; 0x02
    4db2:	93 81       	ldd	r25, Z+3	; 0x03
    4db4:	e9 81       	ldd	r30, Y+1	; 0x01
    4db6:	fa 81       	ldd	r31, Y+2	; 0x02
    4db8:	92 83       	std	Z+2, r25	; 0x02
    4dba:	81 83       	std	Z+1, r24	; 0x01
    4dbc:	e9 81       	ldd	r30, Y+1	; 0x01
    4dbe:	fa 81       	ldd	r31, Y+2	; 0x02
    4dc0:	01 80       	ldd	r0, Z+1	; 0x01
    4dc2:	f2 81       	ldd	r31, Z+2	; 0x02
    4dc4:	e0 2d       	mov	r30, r0
    4dc6:	86 81       	ldd	r24, Z+6	; 0x06
    4dc8:	97 81       	ldd	r25, Z+7	; 0x07
    4dca:	90 93 ed 04 	sts	0x04ED, r25
    4dce:	80 93 ec 04 	sts	0x04EC, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    4dd2:	0f 90       	pop	r0
    4dd4:	0f 90       	pop	r0
    4dd6:	cf 91       	pop	r28
    4dd8:	df 91       	pop	r29
    4dda:	08 95       	ret

00004ddc <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    4ddc:	df 93       	push	r29
    4dde:	cf 93       	push	r28
    4de0:	00 d0       	rcall	.+0      	; 0x4de2 <vTaskPlaceOnEventList+0x6>
    4de2:	00 d0       	rcall	.+0      	; 0x4de4 <vTaskPlaceOnEventList+0x8>
    4de4:	00 d0       	rcall	.+0      	; 0x4de6 <vTaskPlaceOnEventList+0xa>
    4de6:	cd b7       	in	r28, 0x3d	; 61
    4de8:	de b7       	in	r29, 0x3e	; 62
    4dea:	9c 83       	std	Y+4, r25	; 0x04
    4dec:	8b 83       	std	Y+3, r24	; 0x03
    4dee:	7e 83       	std	Y+6, r23	; 0x06
    4df0:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    4df2:	4b 81       	ldd	r20, Y+3	; 0x03
    4df4:	5c 81       	ldd	r21, Y+4	; 0x04
    4df6:	80 91 ec 04 	lds	r24, 0x04EC
    4dfa:	90 91 ed 04 	lds	r25, 0x04ED
    4dfe:	9c 01       	movw	r18, r24
    4e00:	24 5f       	subi	r18, 0xF4	; 244
    4e02:	3f 4f       	sbci	r19, 0xFF	; 255
    4e04:	ca 01       	movw	r24, r20
    4e06:	b9 01       	movw	r22, r18
    4e08:	0e 94 26 19 	call	0x324c	; 0x324c <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4e0c:	80 91 ec 04 	lds	r24, 0x04EC
    4e10:	90 91 ed 04 	lds	r25, 0x04ED
    4e14:	02 96       	adiw	r24, 0x02	; 2
    4e16:	0e 94 92 19 	call	0x3324	; 0x3324 <vListRemove>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    4e1a:	8d 81       	ldd	r24, Y+5	; 0x05
    4e1c:	9e 81       	ldd	r25, Y+6	; 0x06
    4e1e:	2f ef       	ldi	r18, 0xFF	; 255
    4e20:	8f 3f       	cpi	r24, 0xFF	; 255
    4e22:	92 07       	cpc	r25, r18
    4e24:	69 f4       	brne	.+26     	; 0x4e40 <vTaskPlaceOnEventList+0x64>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4e26:	80 91 ec 04 	lds	r24, 0x04EC
    4e2a:	90 91 ed 04 	lds	r25, 0x04ED
    4e2e:	9c 01       	movw	r18, r24
    4e30:	2e 5f       	subi	r18, 0xFE	; 254
    4e32:	3f 4f       	sbci	r19, 0xFF	; 255
    4e34:	86 e4       	ldi	r24, 0x46	; 70
    4e36:	95 e0       	ldi	r25, 0x05	; 5
    4e38:	b9 01       	movw	r22, r18
    4e3a:	0e 94 da 18 	call	0x31b4	; 0x31b4 <vListInsertEnd>
    4e3e:	0e c0       	rjmp	.+28     	; 0x4e5c <vTaskPlaceOnEventList+0x80>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    4e40:	20 91 f0 04 	lds	r18, 0x04F0
    4e44:	30 91 f1 04 	lds	r19, 0x04F1
    4e48:	8d 81       	ldd	r24, Y+5	; 0x05
    4e4a:	9e 81       	ldd	r25, Y+6	; 0x06
    4e4c:	82 0f       	add	r24, r18
    4e4e:	93 1f       	adc	r25, r19
    4e50:	9a 83       	std	Y+2, r25	; 0x02
    4e52:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    4e54:	89 81       	ldd	r24, Y+1	; 0x01
    4e56:	9a 81       	ldd	r25, Y+2	; 0x02
    4e58:	0e 94 09 29 	call	0x5212	; 0x5212 <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
    4e5c:	26 96       	adiw	r28, 0x06	; 6
    4e5e:	0f b6       	in	r0, 0x3f	; 63
    4e60:	f8 94       	cli
    4e62:	de bf       	out	0x3e, r29	; 62
    4e64:	0f be       	out	0x3f, r0	; 63
    4e66:	cd bf       	out	0x3d, r28	; 61
    4e68:	cf 91       	pop	r28
    4e6a:	df 91       	pop	r29
    4e6c:	08 95       	ret

00004e6e <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    4e6e:	df 93       	push	r29
    4e70:	cf 93       	push	r28
    4e72:	00 d0       	rcall	.+0      	; 0x4e74 <xTaskRemoveFromEventList+0x6>
    4e74:	00 d0       	rcall	.+0      	; 0x4e76 <xTaskRemoveFromEventList+0x8>
    4e76:	0f 92       	push	r0
    4e78:	cd b7       	in	r28, 0x3d	; 61
    4e7a:	de b7       	in	r29, 0x3e	; 62
    4e7c:	9d 83       	std	Y+5, r25	; 0x05
    4e7e:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    4e80:	ec 81       	ldd	r30, Y+4	; 0x04
    4e82:	fd 81       	ldd	r31, Y+5	; 0x05
    4e84:	05 80       	ldd	r0, Z+5	; 0x05
    4e86:	f6 81       	ldd	r31, Z+6	; 0x06
    4e88:	e0 2d       	mov	r30, r0
    4e8a:	86 81       	ldd	r24, Z+6	; 0x06
    4e8c:	97 81       	ldd	r25, Z+7	; 0x07
    4e8e:	9b 83       	std	Y+3, r25	; 0x03
    4e90:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    4e92:	8a 81       	ldd	r24, Y+2	; 0x02
    4e94:	9b 81       	ldd	r25, Y+3	; 0x03
    4e96:	0c 96       	adiw	r24, 0x0c	; 12
    4e98:	0e 94 92 19 	call	0x3324	; 0x3324 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    4e9c:	80 91 f5 04 	lds	r24, 0x04F5
    4ea0:	88 23       	and	r24, r24
    4ea2:	61 f5       	brne	.+88     	; 0x4efc <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    4ea4:	8a 81       	ldd	r24, Y+2	; 0x02
    4ea6:	9b 81       	ldd	r25, Y+3	; 0x03
    4ea8:	02 96       	adiw	r24, 0x02	; 2
    4eaa:	0e 94 92 19 	call	0x3324	; 0x3324 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    4eae:	ea 81       	ldd	r30, Y+2	; 0x02
    4eb0:	fb 81       	ldd	r31, Y+3	; 0x03
    4eb2:	96 89       	ldd	r25, Z+22	; 0x16
    4eb4:	80 91 f3 04 	lds	r24, 0x04F3
    4eb8:	89 17       	cp	r24, r25
    4eba:	28 f4       	brcc	.+10     	; 0x4ec6 <xTaskRemoveFromEventList+0x58>
    4ebc:	ea 81       	ldd	r30, Y+2	; 0x02
    4ebe:	fb 81       	ldd	r31, Y+3	; 0x03
    4ec0:	86 89       	ldd	r24, Z+22	; 0x16
    4ec2:	80 93 f3 04 	sts	0x04F3, r24
    4ec6:	ea 81       	ldd	r30, Y+2	; 0x02
    4ec8:	fb 81       	ldd	r31, Y+3	; 0x03
    4eca:	86 89       	ldd	r24, Z+22	; 0x16
    4ecc:	28 2f       	mov	r18, r24
    4ece:	30 e0       	ldi	r19, 0x00	; 0
    4ed0:	c9 01       	movw	r24, r18
    4ed2:	88 0f       	add	r24, r24
    4ed4:	99 1f       	adc	r25, r25
    4ed6:	88 0f       	add	r24, r24
    4ed8:	99 1f       	adc	r25, r25
    4eda:	88 0f       	add	r24, r24
    4edc:	99 1f       	adc	r25, r25
    4ede:	82 0f       	add	r24, r18
    4ee0:	93 1f       	adc	r25, r19
    4ee2:	ac 01       	movw	r20, r24
    4ee4:	46 50       	subi	r20, 0x06	; 6
    4ee6:	5b 4f       	sbci	r21, 0xFB	; 251
    4ee8:	8a 81       	ldd	r24, Y+2	; 0x02
    4eea:	9b 81       	ldd	r25, Y+3	; 0x03
    4eec:	9c 01       	movw	r18, r24
    4eee:	2e 5f       	subi	r18, 0xFE	; 254
    4ef0:	3f 4f       	sbci	r19, 0xFF	; 255
    4ef2:	ca 01       	movw	r24, r20
    4ef4:	b9 01       	movw	r22, r18
    4ef6:	0e 94 da 18 	call	0x31b4	; 0x31b4 <vListInsertEnd>
    4efa:	0a c0       	rjmp	.+20     	; 0x4f10 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4efc:	8a 81       	ldd	r24, Y+2	; 0x02
    4efe:	9b 81       	ldd	r25, Y+3	; 0x03
    4f00:	9c 01       	movw	r18, r24
    4f02:	24 5f       	subi	r18, 0xF4	; 244
    4f04:	3f 4f       	sbci	r19, 0xFF	; 255
    4f06:	84 e3       	ldi	r24, 0x34	; 52
    4f08:	95 e0       	ldi	r25, 0x05	; 5
    4f0a:	b9 01       	movw	r22, r18
    4f0c:	0e 94 da 18 	call	0x31b4	; 0x31b4 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4f10:	ea 81       	ldd	r30, Y+2	; 0x02
    4f12:	fb 81       	ldd	r31, Y+3	; 0x03
    4f14:	96 89       	ldd	r25, Z+22	; 0x16
    4f16:	e0 91 ec 04 	lds	r30, 0x04EC
    4f1a:	f0 91 ed 04 	lds	r31, 0x04ED
    4f1e:	86 89       	ldd	r24, Z+22	; 0x16
    4f20:	98 17       	cp	r25, r24
    4f22:	18 f0       	brcs	.+6      	; 0x4f2a <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    4f24:	81 e0       	ldi	r24, 0x01	; 1
    4f26:	89 83       	std	Y+1, r24	; 0x01
    4f28:	01 c0       	rjmp	.+2      	; 0x4f2c <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    4f2a:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4f2c:	89 81       	ldd	r24, Y+1	; 0x01
}
    4f2e:	0f 90       	pop	r0
    4f30:	0f 90       	pop	r0
    4f32:	0f 90       	pop	r0
    4f34:	0f 90       	pop	r0
    4f36:	0f 90       	pop	r0
    4f38:	cf 91       	pop	r28
    4f3a:	df 91       	pop	r29
    4f3c:	08 95       	ret

00004f3e <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    4f3e:	df 93       	push	r29
    4f40:	cf 93       	push	r28
    4f42:	00 d0       	rcall	.+0      	; 0x4f44 <vTaskSetTimeOutState+0x6>
    4f44:	cd b7       	in	r28, 0x3d	; 61
    4f46:	de b7       	in	r29, 0x3e	; 62
    4f48:	9a 83       	std	Y+2, r25	; 0x02
    4f4a:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    4f4c:	80 91 f8 04 	lds	r24, 0x04F8
    4f50:	e9 81       	ldd	r30, Y+1	; 0x01
    4f52:	fa 81       	ldd	r31, Y+2	; 0x02
    4f54:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    4f56:	80 91 f0 04 	lds	r24, 0x04F0
    4f5a:	90 91 f1 04 	lds	r25, 0x04F1
    4f5e:	e9 81       	ldd	r30, Y+1	; 0x01
    4f60:	fa 81       	ldd	r31, Y+2	; 0x02
    4f62:	92 83       	std	Z+2, r25	; 0x02
    4f64:	81 83       	std	Z+1, r24	; 0x01
}
    4f66:	0f 90       	pop	r0
    4f68:	0f 90       	pop	r0
    4f6a:	cf 91       	pop	r28
    4f6c:	df 91       	pop	r29
    4f6e:	08 95       	ret

00004f70 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    4f70:	df 93       	push	r29
    4f72:	cf 93       	push	r28
    4f74:	00 d0       	rcall	.+0      	; 0x4f76 <xTaskCheckForTimeOut+0x6>
    4f76:	00 d0       	rcall	.+0      	; 0x4f78 <xTaskCheckForTimeOut+0x8>
    4f78:	0f 92       	push	r0
    4f7a:	cd b7       	in	r28, 0x3d	; 61
    4f7c:	de b7       	in	r29, 0x3e	; 62
    4f7e:	9b 83       	std	Y+3, r25	; 0x03
    4f80:	8a 83       	std	Y+2, r24	; 0x02
    4f82:	7d 83       	std	Y+5, r23	; 0x05
    4f84:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    4f86:	0f b6       	in	r0, 0x3f	; 63
    4f88:	f8 94       	cli
    4f8a:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    4f8c:	ec 81       	ldd	r30, Y+4	; 0x04
    4f8e:	fd 81       	ldd	r31, Y+5	; 0x05
    4f90:	80 81       	ld	r24, Z
    4f92:	91 81       	ldd	r25, Z+1	; 0x01
    4f94:	2f ef       	ldi	r18, 0xFF	; 255
    4f96:	8f 3f       	cpi	r24, 0xFF	; 255
    4f98:	92 07       	cpc	r25, r18
    4f9a:	11 f4       	brne	.+4      	; 0x4fa0 <xTaskCheckForTimeOut+0x30>
			{
				xReturn = pdFALSE;
    4f9c:	19 82       	std	Y+1, r1	; 0x01
    4f9e:	44 c0       	rjmp	.+136    	; 0x5028 <xTaskCheckForTimeOut+0xb8>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    4fa0:	ea 81       	ldd	r30, Y+2	; 0x02
    4fa2:	fb 81       	ldd	r31, Y+3	; 0x03
    4fa4:	90 81       	ld	r25, Z
    4fa6:	80 91 f8 04 	lds	r24, 0x04F8
    4faa:	98 17       	cp	r25, r24
    4fac:	71 f0       	breq	.+28     	; 0x4fca <xTaskCheckForTimeOut+0x5a>
    4fae:	ea 81       	ldd	r30, Y+2	; 0x02
    4fb0:	fb 81       	ldd	r31, Y+3	; 0x03
    4fb2:	21 81       	ldd	r18, Z+1	; 0x01
    4fb4:	32 81       	ldd	r19, Z+2	; 0x02
    4fb6:	80 91 f0 04 	lds	r24, 0x04F0
    4fba:	90 91 f1 04 	lds	r25, 0x04F1
    4fbe:	82 17       	cp	r24, r18
    4fc0:	93 07       	cpc	r25, r19
    4fc2:	18 f0       	brcs	.+6      	; 0x4fca <xTaskCheckForTimeOut+0x5a>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    4fc4:	81 e0       	ldi	r24, 0x01	; 1
    4fc6:	89 83       	std	Y+1, r24	; 0x01
    4fc8:	2f c0       	rjmp	.+94     	; 0x5028 <xTaskCheckForTimeOut+0xb8>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    4fca:	20 91 f0 04 	lds	r18, 0x04F0
    4fce:	30 91 f1 04 	lds	r19, 0x04F1
    4fd2:	ea 81       	ldd	r30, Y+2	; 0x02
    4fd4:	fb 81       	ldd	r31, Y+3	; 0x03
    4fd6:	81 81       	ldd	r24, Z+1	; 0x01
    4fd8:	92 81       	ldd	r25, Z+2	; 0x02
    4fda:	28 1b       	sub	r18, r24
    4fdc:	39 0b       	sbc	r19, r25
    4fde:	ec 81       	ldd	r30, Y+4	; 0x04
    4fe0:	fd 81       	ldd	r31, Y+5	; 0x05
    4fe2:	80 81       	ld	r24, Z
    4fe4:	91 81       	ldd	r25, Z+1	; 0x01
    4fe6:	28 17       	cp	r18, r24
    4fe8:	39 07       	cpc	r19, r25
    4fea:	e0 f4       	brcc	.+56     	; 0x5024 <xTaskCheckForTimeOut+0xb4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    4fec:	ec 81       	ldd	r30, Y+4	; 0x04
    4fee:	fd 81       	ldd	r31, Y+5	; 0x05
    4ff0:	40 81       	ld	r20, Z
    4ff2:	51 81       	ldd	r21, Z+1	; 0x01
    4ff4:	ea 81       	ldd	r30, Y+2	; 0x02
    4ff6:	fb 81       	ldd	r31, Y+3	; 0x03
    4ff8:	21 81       	ldd	r18, Z+1	; 0x01
    4ffa:	32 81       	ldd	r19, Z+2	; 0x02
    4ffc:	80 91 f0 04 	lds	r24, 0x04F0
    5000:	90 91 f1 04 	lds	r25, 0x04F1
    5004:	b9 01       	movw	r22, r18
    5006:	68 1b       	sub	r22, r24
    5008:	79 0b       	sbc	r23, r25
    500a:	cb 01       	movw	r24, r22
    500c:	84 0f       	add	r24, r20
    500e:	95 1f       	adc	r25, r21
    5010:	ec 81       	ldd	r30, Y+4	; 0x04
    5012:	fd 81       	ldd	r31, Y+5	; 0x05
    5014:	91 83       	std	Z+1, r25	; 0x01
    5016:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    5018:	8a 81       	ldd	r24, Y+2	; 0x02
    501a:	9b 81       	ldd	r25, Y+3	; 0x03
    501c:	0e 94 9f 27 	call	0x4f3e	; 0x4f3e <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    5020:	19 82       	std	Y+1, r1	; 0x01
    5022:	02 c0       	rjmp	.+4      	; 0x5028 <xTaskCheckForTimeOut+0xb8>
		}
		else
		{
			xReturn = pdTRUE;
    5024:	81 e0       	ldi	r24, 0x01	; 1
    5026:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    5028:	0f 90       	pop	r0
    502a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    502c:	89 81       	ldd	r24, Y+1	; 0x01
}
    502e:	0f 90       	pop	r0
    5030:	0f 90       	pop	r0
    5032:	0f 90       	pop	r0
    5034:	0f 90       	pop	r0
    5036:	0f 90       	pop	r0
    5038:	cf 91       	pop	r28
    503a:	df 91       	pop	r29
    503c:	08 95       	ret

0000503e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    503e:	df 93       	push	r29
    5040:	cf 93       	push	r28
    5042:	cd b7       	in	r28, 0x3d	; 61
    5044:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    5046:	81 e0       	ldi	r24, 0x01	; 1
    5048:	80 93 f7 04 	sts	0x04F7, r24
}
    504c:	cf 91       	pop	r28
    504e:	df 91       	pop	r29
    5050:	08 95       	ret

00005052 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    5052:	df 93       	push	r29
    5054:	cf 93       	push	r28
    5056:	00 d0       	rcall	.+0      	; 0x5058 <prvIdleTask+0x6>
    5058:	cd b7       	in	r28, 0x3d	; 61
    505a:	de b7       	in	r29, 0x3e	; 62
    505c:	9a 83       	std	Y+2, r25	; 0x02
    505e:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    5060:	0e 94 cb 28 	call	0x5196	; 0x5196 <prvCheckTasksWaitingTermination>
    5064:	fd cf       	rjmp	.-6      	; 0x5060 <prvIdleTask+0xe>

00005066 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    5066:	0f 93       	push	r16
    5068:	1f 93       	push	r17
    506a:	df 93       	push	r29
    506c:	cf 93       	push	r28
    506e:	cd b7       	in	r28, 0x3d	; 61
    5070:	de b7       	in	r29, 0x3e	; 62
    5072:	29 97       	sbiw	r28, 0x09	; 9
    5074:	0f b6       	in	r0, 0x3f	; 63
    5076:	f8 94       	cli
    5078:	de bf       	out	0x3e, r29	; 62
    507a:	0f be       	out	0x3f, r0	; 63
    507c:	cd bf       	out	0x3d, r28	; 61
    507e:	9a 83       	std	Y+2, r25	; 0x02
    5080:	89 83       	std	Y+1, r24	; 0x01
    5082:	7c 83       	std	Y+4, r23	; 0x04
    5084:	6b 83       	std	Y+3, r22	; 0x03
    5086:	4d 83       	std	Y+5, r20	; 0x05
    5088:	3f 83       	std	Y+7, r19	; 0x07
    508a:	2e 83       	std	Y+6, r18	; 0x06
    508c:	19 87       	std	Y+9, r17	; 0x09
    508e:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    5090:	89 81       	ldd	r24, Y+1	; 0x01
    5092:	9a 81       	ldd	r25, Y+2	; 0x02
    5094:	49 96       	adiw	r24, 0x19	; 25
    5096:	2b 81       	ldd	r18, Y+3	; 0x03
    5098:	3c 81       	ldd	r19, Y+4	; 0x04
    509a:	b9 01       	movw	r22, r18
    509c:	48 e0       	ldi	r20, 0x08	; 8
    509e:	50 e0       	ldi	r21, 0x00	; 0
    50a0:	0e 94 ab 2a 	call	0x5556	; 0x5556 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    50a4:	e9 81       	ldd	r30, Y+1	; 0x01
    50a6:	fa 81       	ldd	r31, Y+2	; 0x02
    50a8:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    50aa:	8d 81       	ldd	r24, Y+5	; 0x05
    50ac:	84 30       	cpi	r24, 0x04	; 4
    50ae:	10 f0       	brcs	.+4      	; 0x50b4 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    50b0:	83 e0       	ldi	r24, 0x03	; 3
    50b2:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    50b4:	e9 81       	ldd	r30, Y+1	; 0x01
    50b6:	fa 81       	ldd	r31, Y+2	; 0x02
    50b8:	8d 81       	ldd	r24, Y+5	; 0x05
    50ba:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    50bc:	89 81       	ldd	r24, Y+1	; 0x01
    50be:	9a 81       	ldd	r25, Y+2	; 0x02
    50c0:	02 96       	adiw	r24, 0x02	; 2
    50c2:	0e 94 ca 18 	call	0x3194	; 0x3194 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    50c6:	89 81       	ldd	r24, Y+1	; 0x01
    50c8:	9a 81       	ldd	r25, Y+2	; 0x02
    50ca:	0c 96       	adiw	r24, 0x0c	; 12
    50cc:	0e 94 ca 18 	call	0x3194	; 0x3194 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    50d0:	e9 81       	ldd	r30, Y+1	; 0x01
    50d2:	fa 81       	ldd	r31, Y+2	; 0x02
    50d4:	89 81       	ldd	r24, Y+1	; 0x01
    50d6:	9a 81       	ldd	r25, Y+2	; 0x02
    50d8:	91 87       	std	Z+9, r25	; 0x09
    50da:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    50dc:	8d 81       	ldd	r24, Y+5	; 0x05
    50de:	28 2f       	mov	r18, r24
    50e0:	30 e0       	ldi	r19, 0x00	; 0
    50e2:	84 e0       	ldi	r24, 0x04	; 4
    50e4:	90 e0       	ldi	r25, 0x00	; 0
    50e6:	82 1b       	sub	r24, r18
    50e8:	93 0b       	sbc	r25, r19
    50ea:	e9 81       	ldd	r30, Y+1	; 0x01
    50ec:	fa 81       	ldd	r31, Y+2	; 0x02
    50ee:	95 87       	std	Z+13, r25	; 0x0d
    50f0:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    50f2:	e9 81       	ldd	r30, Y+1	; 0x01
    50f4:	fa 81       	ldd	r31, Y+2	; 0x02
    50f6:	89 81       	ldd	r24, Y+1	; 0x01
    50f8:	9a 81       	ldd	r25, Y+2	; 0x02
    50fa:	93 8b       	std	Z+19, r25	; 0x13
    50fc:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    50fe:	29 96       	adiw	r28, 0x09	; 9
    5100:	0f b6       	in	r0, 0x3f	; 63
    5102:	f8 94       	cli
    5104:	de bf       	out	0x3e, r29	; 62
    5106:	0f be       	out	0x3f, r0	; 63
    5108:	cd bf       	out	0x3d, r28	; 61
    510a:	cf 91       	pop	r28
    510c:	df 91       	pop	r29
    510e:	1f 91       	pop	r17
    5110:	0f 91       	pop	r16
    5112:	08 95       	ret

00005114 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    5114:	df 93       	push	r29
    5116:	cf 93       	push	r28
    5118:	0f 92       	push	r0
    511a:	cd b7       	in	r28, 0x3d	; 61
    511c:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    511e:	19 82       	std	Y+1, r1	; 0x01
    5120:	13 c0       	rjmp	.+38     	; 0x5148 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    5122:	89 81       	ldd	r24, Y+1	; 0x01
    5124:	28 2f       	mov	r18, r24
    5126:	30 e0       	ldi	r19, 0x00	; 0
    5128:	c9 01       	movw	r24, r18
    512a:	88 0f       	add	r24, r24
    512c:	99 1f       	adc	r25, r25
    512e:	88 0f       	add	r24, r24
    5130:	99 1f       	adc	r25, r25
    5132:	88 0f       	add	r24, r24
    5134:	99 1f       	adc	r25, r25
    5136:	82 0f       	add	r24, r18
    5138:	93 1f       	adc	r25, r19
    513a:	86 50       	subi	r24, 0x06	; 6
    513c:	9b 4f       	sbci	r25, 0xFB	; 251
    513e:	0e 94 a0 18 	call	0x3140	; 0x3140 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    5142:	89 81       	ldd	r24, Y+1	; 0x01
    5144:	8f 5f       	subi	r24, 0xFF	; 255
    5146:	89 83       	std	Y+1, r24	; 0x01
    5148:	89 81       	ldd	r24, Y+1	; 0x01
    514a:	84 30       	cpi	r24, 0x04	; 4
    514c:	50 f3       	brcs	.-44     	; 0x5122 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    514e:	8e e1       	ldi	r24, 0x1E	; 30
    5150:	95 e0       	ldi	r25, 0x05	; 5
    5152:	0e 94 a0 18 	call	0x3140	; 0x3140 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    5156:	87 e2       	ldi	r24, 0x27	; 39
    5158:	95 e0       	ldi	r25, 0x05	; 5
    515a:	0e 94 a0 18 	call	0x3140	; 0x3140 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    515e:	84 e3       	ldi	r24, 0x34	; 52
    5160:	95 e0       	ldi	r25, 0x05	; 5
    5162:	0e 94 a0 18 	call	0x3140	; 0x3140 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    5166:	8d e3       	ldi	r24, 0x3D	; 61
    5168:	95 e0       	ldi	r25, 0x05	; 5
    516a:	0e 94 a0 18 	call	0x3140	; 0x3140 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    516e:	86 e4       	ldi	r24, 0x46	; 70
    5170:	95 e0       	ldi	r25, 0x05	; 5
    5172:	0e 94 a0 18 	call	0x3140	; 0x3140 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    5176:	8e e1       	ldi	r24, 0x1E	; 30
    5178:	95 e0       	ldi	r25, 0x05	; 5
    517a:	90 93 31 05 	sts	0x0531, r25
    517e:	80 93 30 05 	sts	0x0530, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    5182:	87 e2       	ldi	r24, 0x27	; 39
    5184:	95 e0       	ldi	r25, 0x05	; 5
    5186:	90 93 33 05 	sts	0x0533, r25
    518a:	80 93 32 05 	sts	0x0532, r24
}
    518e:	0f 90       	pop	r0
    5190:	cf 91       	pop	r28
    5192:	df 91       	pop	r29
    5194:	08 95       	ret

00005196 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    5196:	df 93       	push	r29
    5198:	cf 93       	push	r28
    519a:	00 d0       	rcall	.+0      	; 0x519c <prvCheckTasksWaitingTermination+0x6>
    519c:	0f 92       	push	r0
    519e:	cd b7       	in	r28, 0x3d	; 61
    51a0:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    51a2:	80 91 ee 04 	lds	r24, 0x04EE
    51a6:	88 23       	and	r24, r24
    51a8:	71 f1       	breq	.+92     	; 0x5206 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    51aa:	0e 94 e8 24 	call	0x49d0	; 0x49d0 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    51ae:	80 91 3d 05 	lds	r24, 0x053D
    51b2:	1b 82       	std	Y+3, r1	; 0x03
    51b4:	88 23       	and	r24, r24
    51b6:	11 f4       	brne	.+4      	; 0x51bc <prvCheckTasksWaitingTermination+0x26>
    51b8:	81 e0       	ldi	r24, 0x01	; 1
    51ba:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    51bc:	0e 94 f4 24 	call	0x49e8	; 0x49e8 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    51c0:	8b 81       	ldd	r24, Y+3	; 0x03
    51c2:	88 23       	and	r24, r24
    51c4:	01 f5       	brne	.+64     	; 0x5206 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    51c6:	0f b6       	in	r0, 0x3f	; 63
    51c8:	f8 94       	cli
    51ca:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    51cc:	e0 91 42 05 	lds	r30, 0x0542
    51d0:	f0 91 43 05 	lds	r31, 0x0543
    51d4:	86 81       	ldd	r24, Z+6	; 0x06
    51d6:	97 81       	ldd	r25, Z+7	; 0x07
    51d8:	9a 83       	std	Y+2, r25	; 0x02
    51da:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    51dc:	89 81       	ldd	r24, Y+1	; 0x01
    51de:	9a 81       	ldd	r25, Y+2	; 0x02
    51e0:	02 96       	adiw	r24, 0x02	; 2
    51e2:	0e 94 92 19 	call	0x3324	; 0x3324 <vListRemove>
					--uxCurrentNumberOfTasks;
    51e6:	80 91 ef 04 	lds	r24, 0x04EF
    51ea:	81 50       	subi	r24, 0x01	; 1
    51ec:	80 93 ef 04 	sts	0x04EF, r24
					--uxTasksDeleted;
    51f0:	80 91 ee 04 	lds	r24, 0x04EE
    51f4:	81 50       	subi	r24, 0x01	; 1
    51f6:	80 93 ee 04 	sts	0x04EE, r24
				}
				taskEXIT_CRITICAL();
    51fa:	0f 90       	pop	r0
    51fc:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    51fe:	89 81       	ldd	r24, Y+1	; 0x01
    5200:	9a 81       	ldd	r25, Y+2	; 0x02
    5202:	0e 94 a2 29 	call	0x5344	; 0x5344 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    5206:	0f 90       	pop	r0
    5208:	0f 90       	pop	r0
    520a:	0f 90       	pop	r0
    520c:	cf 91       	pop	r28
    520e:	df 91       	pop	r29
    5210:	08 95       	ret

00005212 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    5212:	df 93       	push	r29
    5214:	cf 93       	push	r28
    5216:	00 d0       	rcall	.+0      	; 0x5218 <prvAddCurrentTaskToDelayedList+0x6>
    5218:	cd b7       	in	r28, 0x3d	; 61
    521a:	de b7       	in	r29, 0x3e	; 62
    521c:	9a 83       	std	Y+2, r25	; 0x02
    521e:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    5220:	e0 91 ec 04 	lds	r30, 0x04EC
    5224:	f0 91 ed 04 	lds	r31, 0x04ED
    5228:	89 81       	ldd	r24, Y+1	; 0x01
    522a:	9a 81       	ldd	r25, Y+2	; 0x02
    522c:	93 83       	std	Z+3, r25	; 0x03
    522e:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    5230:	20 91 f0 04 	lds	r18, 0x04F0
    5234:	30 91 f1 04 	lds	r19, 0x04F1
    5238:	89 81       	ldd	r24, Y+1	; 0x01
    523a:	9a 81       	ldd	r25, Y+2	; 0x02
    523c:	82 17       	cp	r24, r18
    523e:	93 07       	cpc	r25, r19
    5240:	70 f4       	brcc	.+28     	; 0x525e <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    5242:	80 91 32 05 	lds	r24, 0x0532
    5246:	90 91 33 05 	lds	r25, 0x0533
    524a:	20 91 ec 04 	lds	r18, 0x04EC
    524e:	30 91 ed 04 	lds	r19, 0x04ED
    5252:	2e 5f       	subi	r18, 0xFE	; 254
    5254:	3f 4f       	sbci	r19, 0xFF	; 255
    5256:	b9 01       	movw	r22, r18
    5258:	0e 94 26 19 	call	0x324c	; 0x324c <vListInsert>
    525c:	1e c0       	rjmp	.+60     	; 0x529a <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    525e:	40 91 30 05 	lds	r20, 0x0530
    5262:	50 91 31 05 	lds	r21, 0x0531
    5266:	80 91 ec 04 	lds	r24, 0x04EC
    526a:	90 91 ed 04 	lds	r25, 0x04ED
    526e:	9c 01       	movw	r18, r24
    5270:	2e 5f       	subi	r18, 0xFE	; 254
    5272:	3f 4f       	sbci	r19, 0xFF	; 255
    5274:	ca 01       	movw	r24, r20
    5276:	b9 01       	movw	r22, r18
    5278:	0e 94 26 19 	call	0x324c	; 0x324c <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    527c:	20 91 7f 00 	lds	r18, 0x007F
    5280:	30 91 80 00 	lds	r19, 0x0080
    5284:	89 81       	ldd	r24, Y+1	; 0x01
    5286:	9a 81       	ldd	r25, Y+2	; 0x02
    5288:	82 17       	cp	r24, r18
    528a:	93 07       	cpc	r25, r19
    528c:	30 f4       	brcc	.+12     	; 0x529a <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    528e:	89 81       	ldd	r24, Y+1	; 0x01
    5290:	9a 81       	ldd	r25, Y+2	; 0x02
    5292:	90 93 80 00 	sts	0x0080, r25
    5296:	80 93 7f 00 	sts	0x007F, r24
		}
	}
}
    529a:	0f 90       	pop	r0
    529c:	0f 90       	pop	r0
    529e:	cf 91       	pop	r28
    52a0:	df 91       	pop	r29
    52a2:	08 95       	ret

000052a4 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    52a4:	df 93       	push	r29
    52a6:	cf 93       	push	r28
    52a8:	cd b7       	in	r28, 0x3d	; 61
    52aa:	de b7       	in	r29, 0x3e	; 62
    52ac:	28 97       	sbiw	r28, 0x08	; 8
    52ae:	0f b6       	in	r0, 0x3f	; 63
    52b0:	f8 94       	cli
    52b2:	de bf       	out	0x3e, r29	; 62
    52b4:	0f be       	out	0x3f, r0	; 63
    52b6:	cd bf       	out	0x3d, r28	; 61
    52b8:	9c 83       	std	Y+4, r25	; 0x04
    52ba:	8b 83       	std	Y+3, r24	; 0x03
    52bc:	7e 83       	std	Y+6, r23	; 0x06
    52be:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    52c0:	81 e2       	ldi	r24, 0x21	; 33
    52c2:	90 e0       	ldi	r25, 0x00	; 0
    52c4:	0e 94 34 18 	call	0x3068	; 0x3068 <pvPortMalloc>
    52c8:	9a 83       	std	Y+2, r25	; 0x02
    52ca:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    52cc:	89 81       	ldd	r24, Y+1	; 0x01
    52ce:	9a 81       	ldd	r25, Y+2	; 0x02
    52d0:	00 97       	sbiw	r24, 0x00	; 0
    52d2:	69 f1       	breq	.+90     	; 0x532e <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    52d4:	8d 81       	ldd	r24, Y+5	; 0x05
    52d6:	9e 81       	ldd	r25, Y+6	; 0x06
    52d8:	00 97       	sbiw	r24, 0x00	; 0
    52da:	39 f4       	brne	.+14     	; 0x52ea <prvAllocateTCBAndStack+0x46>
    52dc:	8b 81       	ldd	r24, Y+3	; 0x03
    52de:	9c 81       	ldd	r25, Y+4	; 0x04
    52e0:	0e 94 34 18 	call	0x3068	; 0x3068 <pvPortMalloc>
    52e4:	98 87       	std	Y+8, r25	; 0x08
    52e6:	8f 83       	std	Y+7, r24	; 0x07
    52e8:	04 c0       	rjmp	.+8      	; 0x52f2 <prvAllocateTCBAndStack+0x4e>
    52ea:	8d 81       	ldd	r24, Y+5	; 0x05
    52ec:	9e 81       	ldd	r25, Y+6	; 0x06
    52ee:	98 87       	std	Y+8, r25	; 0x08
    52f0:	8f 83       	std	Y+7, r24	; 0x07
    52f2:	e9 81       	ldd	r30, Y+1	; 0x01
    52f4:	fa 81       	ldd	r31, Y+2	; 0x02
    52f6:	8f 81       	ldd	r24, Y+7	; 0x07
    52f8:	98 85       	ldd	r25, Y+8	; 0x08
    52fa:	90 8f       	std	Z+24, r25	; 0x18
    52fc:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    52fe:	e9 81       	ldd	r30, Y+1	; 0x01
    5300:	fa 81       	ldd	r31, Y+2	; 0x02
    5302:	87 89       	ldd	r24, Z+23	; 0x17
    5304:	90 8d       	ldd	r25, Z+24	; 0x18
    5306:	00 97       	sbiw	r24, 0x00	; 0
    5308:	39 f4       	brne	.+14     	; 0x5318 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    530a:	89 81       	ldd	r24, Y+1	; 0x01
    530c:	9a 81       	ldd	r25, Y+2	; 0x02
    530e:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <vPortFree>
			pxNewTCB = NULL;
    5312:	1a 82       	std	Y+2, r1	; 0x02
    5314:	19 82       	std	Y+1, r1	; 0x01
    5316:	0b c0       	rjmp	.+22     	; 0x532e <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    5318:	e9 81       	ldd	r30, Y+1	; 0x01
    531a:	fa 81       	ldd	r31, Y+2	; 0x02
    531c:	87 89       	ldd	r24, Z+23	; 0x17
    531e:	90 8d       	ldd	r25, Z+24	; 0x18
    5320:	2b 81       	ldd	r18, Y+3	; 0x03
    5322:	3c 81       	ldd	r19, Y+4	; 0x04
    5324:	65 ea       	ldi	r22, 0xA5	; 165
    5326:	70 e0       	ldi	r23, 0x00	; 0
    5328:	a9 01       	movw	r20, r18
    532a:	0e 94 a4 2a 	call	0x5548	; 0x5548 <memset>
		}
	}

	return pxNewTCB;
    532e:	89 81       	ldd	r24, Y+1	; 0x01
    5330:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5332:	28 96       	adiw	r28, 0x08	; 8
    5334:	0f b6       	in	r0, 0x3f	; 63
    5336:	f8 94       	cli
    5338:	de bf       	out	0x3e, r29	; 62
    533a:	0f be       	out	0x3f, r0	; 63
    533c:	cd bf       	out	0x3d, r28	; 61
    533e:	cf 91       	pop	r28
    5340:	df 91       	pop	r29
    5342:	08 95       	ret

00005344 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    5344:	df 93       	push	r29
    5346:	cf 93       	push	r28
    5348:	00 d0       	rcall	.+0      	; 0x534a <prvDeleteTCB+0x6>
    534a:	cd b7       	in	r28, 0x3d	; 61
    534c:	de b7       	in	r29, 0x3e	; 62
    534e:	9a 83       	std	Y+2, r25	; 0x02
    5350:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    5352:	e9 81       	ldd	r30, Y+1	; 0x01
    5354:	fa 81       	ldd	r31, Y+2	; 0x02
    5356:	87 89       	ldd	r24, Z+23	; 0x17
    5358:	90 8d       	ldd	r25, Z+24	; 0x18
    535a:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <vPortFree>
		vPortFree( pxTCB );
    535e:	89 81       	ldd	r24, Y+1	; 0x01
    5360:	9a 81       	ldd	r25, Y+2	; 0x02
    5362:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <vPortFree>
	}
    5366:	0f 90       	pop	r0
    5368:	0f 90       	pop	r0
    536a:	cf 91       	pop	r28
    536c:	df 91       	pop	r29
    536e:	08 95       	ret

00005370 <segment1fun>:

u8 arr1[20]="welcome";
u8 arr2[20]="HI";

void segment1fun()
{
    5370:	df 93       	push	r29
    5372:	cf 93       	push	r28
    5374:	cd b7       	in	r28, 0x3d	; 61
    5376:	de b7       	in	r29, 0x3e	; 62
	while(1)
	{
		static u8 counter=0;
		SSD_voidPrintNum_1(counter++);
    5378:	80 91 4f 05 	lds	r24, 0x054F
    537c:	98 2f       	mov	r25, r24
    537e:	8f 5f       	subi	r24, 0xFF	; 255
    5380:	80 93 4f 05 	sts	0x054F, r24
    5384:	89 2f       	mov	r24, r25
    5386:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <SSD_voidPrintNum_1>
		if(counter==10)
    538a:	80 91 4f 05 	lds	r24, 0x054F
    538e:	8a 30       	cpi	r24, 0x0A	; 10
    5390:	11 f4       	brne	.+4      	; 0x5396 <segment1fun+0x26>
		{
			counter=0;
    5392:	10 92 4f 05 	sts	0x054F, r1

		}
		vTaskDelay(1000);
    5396:	88 ee       	ldi	r24, 0xE8	; 232
    5398:	93 e0       	ldi	r25, 0x03	; 3
    539a:	0e 94 11 23 	call	0x4622	; 0x4622 <vTaskDelay>
    539e:	ec cf       	rjmp	.-40     	; 0x5378 <segment1fun+0x8>

000053a0 <str1>:


}

void str1()
{
    53a0:	df 93       	push	r29
    53a2:	cf 93       	push	r28
    53a4:	cd b7       	in	r28, 0x3d	; 61
    53a6:	de b7       	in	r29, 0x3e	; 62

	while(1)
	{

		static u8 count=0;
		LCD_WRITE_DATA(arr1[count++]);
    53a8:	20 91 50 05 	lds	r18, 0x0550
    53ac:	82 2f       	mov	r24, r18
    53ae:	90 e0       	ldi	r25, 0x00	; 0
    53b0:	fc 01       	movw	r30, r24
    53b2:	ef 57       	subi	r30, 0x7F	; 127
    53b4:	ff 4f       	sbci	r31, 0xFF	; 255
    53b6:	90 81       	ld	r25, Z
    53b8:	82 2f       	mov	r24, r18
    53ba:	8f 5f       	subi	r24, 0xFF	; 255
    53bc:	80 93 50 05 	sts	0x0550, r24
    53c0:	89 2f       	mov	r24, r25
    53c2:	0e 94 5e 14 	call	0x28bc	; 0x28bc <LCD_WRITE_DATA>
		if(count==10)
    53c6:	80 91 50 05 	lds	r24, 0x0550
    53ca:	8a 30       	cpi	r24, 0x0A	; 10
    53cc:	69 f7       	brne	.-38     	; 0x53a8 <str1+0x8>
		{
			count=0;
    53ce:	10 92 50 05 	sts	0x0550, r1
    53d2:	ea cf       	rjmp	.-44     	; 0x53a8 <str1+0x8>

000053d4 <LED_1>:
//
//
//}

void LED_1()
{
    53d4:	df 93       	push	r29
    53d6:	cf 93       	push	r28
    53d8:	cd b7       	in	r28, 0x3d	; 61
    53da:	de b7       	in	r29, 0x3e	; 62
   while(1)
   {
	DIO_voidToggelPin(PORTD_ID,PIN0);
    53dc:	83 e0       	ldi	r24, 0x03	; 3
    53de:	60 e0       	ldi	r22, 0x00	; 0
    53e0:	0e 94 71 0e 	call	0x1ce2	; 0x1ce2 <DIO_voidToggelPin>
	vTaskDelay(2000);
    53e4:	80 ed       	ldi	r24, 0xD0	; 208
    53e6:	97 e0       	ldi	r25, 0x07	; 7
    53e8:	0e 94 11 23 	call	0x4622	; 0x4622 <vTaskDelay>
    53ec:	f7 cf       	rjmp	.-18     	; 0x53dc <LED_1+0x8>

000053ee <LED_2>:
   }

}
void LED_2()
{
    53ee:	df 93       	push	r29
    53f0:	cf 93       	push	r28
    53f2:	cd b7       	in	r28, 0x3d	; 61
    53f4:	de b7       	in	r29, 0x3e	; 62
    while(1)
    {
	DIO_voidToggelPin(PORTD_ID,PIN1);
    53f6:	83 e0       	ldi	r24, 0x03	; 3
    53f8:	61 e0       	ldi	r22, 0x01	; 1
    53fa:	0e 94 71 0e 	call	0x1ce2	; 0x1ce2 <DIO_voidToggelPin>
	vTaskDelay(2000);
    53fe:	80 ed       	ldi	r24, 0xD0	; 208
    5400:	97 e0       	ldi	r25, 0x07	; 7
    5402:	0e 94 11 23 	call	0x4622	; 0x4622 <vTaskDelay>
    5406:	f7 cf       	rjmp	.-18     	; 0x53f6 <LED_2+0x8>

00005408 <LED_3>:
    }

}
void LED_3()
{
    5408:	df 93       	push	r29
    540a:	cf 93       	push	r28
    540c:	cd b7       	in	r28, 0x3d	; 61
    540e:	de b7       	in	r29, 0x3e	; 62
    while(1)
    {
	DIO_voidToggelPin(PORTD_ID,PIN2);
    5410:	83 e0       	ldi	r24, 0x03	; 3
    5412:	62 e0       	ldi	r22, 0x02	; 2
    5414:	0e 94 71 0e 	call	0x1ce2	; 0x1ce2 <DIO_voidToggelPin>
	vTaskDelay(3000);                 //priodicty 1000msec=1sec
    5418:	88 eb       	ldi	r24, 0xB8	; 184
    541a:	9b e0       	ldi	r25, 0x0B	; 11
    541c:	0e 94 11 23 	call	0x4622	; 0x4622 <vTaskDelay>
    5420:	f7 cf       	rjmp	.-18     	; 0x5410 <LED_3+0x8>

00005422 <main>:
//
//}
//

int main()
{
    5422:	af 92       	push	r10
    5424:	bf 92       	push	r11
    5426:	cf 92       	push	r12
    5428:	df 92       	push	r13
    542a:	ef 92       	push	r14
    542c:	ff 92       	push	r15
    542e:	0f 93       	push	r16
    5430:	df 93       	push	r29
    5432:	cf 93       	push	r28
    5434:	cd b7       	in	r28, 0x3d	; 61
    5436:	de b7       	in	r29, 0x3e	; 62

	DIO_voidSetPinDirection(PORTD_ID, PIN0, PIN_OUTPUT);
    5438:	83 e0       	ldi	r24, 0x03	; 3
    543a:	60 e0       	ldi	r22, 0x00	; 0
    543c:	41 e0       	ldi	r20, 0x01	; 1
    543e:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(PORTD_ID, PIN1, PIN_OUTPUT);
    5442:	83 e0       	ldi	r24, 0x03	; 3
    5444:	61 e0       	ldi	r22, 0x01	; 1
    5446:	41 e0       	ldi	r20, 0x01	; 1
    5448:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(PORTD_ID, PIN2, PIN_OUTPUT);
    544c:	83 e0       	ldi	r24, 0x03	; 3
    544e:	62 e0       	ldi	r22, 0x02	; 2
    5450:	41 e0       	ldi	r20, 0x01	; 1
    5452:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <DIO_voidSetPinDirection>

//	RTOS_VoCreateTask(LED_1,1000,1,0);
	xTaskCreate(LED_1,"LED_1",100,NULL,0,NULL);
    5456:	8a ee       	ldi	r24, 0xEA	; 234
    5458:	99 e2       	ldi	r25, 0x29	; 41
    545a:	25 e6       	ldi	r18, 0x65	; 101
    545c:	30 e0       	ldi	r19, 0x00	; 0
    545e:	b9 01       	movw	r22, r18
    5460:	44 e6       	ldi	r20, 0x64	; 100
    5462:	50 e0       	ldi	r21, 0x00	; 0
    5464:	20 e0       	ldi	r18, 0x00	; 0
    5466:	30 e0       	ldi	r19, 0x00	; 0
    5468:	00 e0       	ldi	r16, 0x00	; 0
    546a:	ee 24       	eor	r14, r14
    546c:	ff 24       	eor	r15, r15
    546e:	cc 24       	eor	r12, r12
    5470:	dd 24       	eor	r13, r13
    5472:	aa 24       	eor	r10, r10
    5474:	bb 24       	eor	r11, r11
    5476:	0e 94 4d 21 	call	0x429a	; 0x429a <xTaskGenericCreate>
//	RTOS_VoCreateTask(LED_2,2000,1,2);
	xTaskCreate(LED_2,"LED_2",100,NULL,1,NULL);        //first priority has the largest number
    547a:	87 ef       	ldi	r24, 0xF7	; 247
    547c:	99 e2       	ldi	r25, 0x29	; 41
    547e:	2b e6       	ldi	r18, 0x6B	; 107
    5480:	30 e0       	ldi	r19, 0x00	; 0
    5482:	b9 01       	movw	r22, r18
    5484:	44 e6       	ldi	r20, 0x64	; 100
    5486:	50 e0       	ldi	r21, 0x00	; 0
    5488:	20 e0       	ldi	r18, 0x00	; 0
    548a:	30 e0       	ldi	r19, 0x00	; 0
    548c:	01 e0       	ldi	r16, 0x01	; 1
    548e:	ee 24       	eor	r14, r14
    5490:	ff 24       	eor	r15, r15
    5492:	cc 24       	eor	r12, r12
    5494:	dd 24       	eor	r13, r13
    5496:	aa 24       	eor	r10, r10
    5498:	bb 24       	eor	r11, r11
    549a:	0e 94 4d 21 	call	0x429a	; 0x429a <xTaskGenericCreate>
//	RTOS_VoCreateTask(LED_3,3000,2,4);
	xTaskCreate(LED_3,"LED_3",100,NULL,2,NULL);
    549e:	84 e0       	ldi	r24, 0x04	; 4
    54a0:	9a e2       	ldi	r25, 0x2A	; 42
    54a2:	21 e7       	ldi	r18, 0x71	; 113
    54a4:	30 e0       	ldi	r19, 0x00	; 0
    54a6:	b9 01       	movw	r22, r18
    54a8:	44 e6       	ldi	r20, 0x64	; 100
    54aa:	50 e0       	ldi	r21, 0x00	; 0
    54ac:	20 e0       	ldi	r18, 0x00	; 0
    54ae:	30 e0       	ldi	r19, 0x00	; 0
    54b0:	02 e0       	ldi	r16, 0x02	; 2
    54b2:	ee 24       	eor	r14, r14
    54b4:	ff 24       	eor	r15, r15
    54b6:	cc 24       	eor	r12, r12
    54b8:	dd 24       	eor	r13, r13
    54ba:	aa 24       	eor	r10, r10
    54bc:	bb 24       	eor	r11, r11
    54be:	0e 94 4d 21 	call	0x429a	; 0x429a <xTaskGenericCreate>

//	RTOS_VoInit();
	vTaskStartScheduler();
    54c2:	0e 94 a5 24 	call	0x494a	; 0x494a <vTaskStartScheduler>
    54c6:	ff cf       	rjmp	.-2      	; 0x54c6 <main+0xa4>

000054c8 <__prologue_saves__>:
    54c8:	2f 92       	push	r2
    54ca:	3f 92       	push	r3
    54cc:	4f 92       	push	r4
    54ce:	5f 92       	push	r5
    54d0:	6f 92       	push	r6
    54d2:	7f 92       	push	r7
    54d4:	8f 92       	push	r8
    54d6:	9f 92       	push	r9
    54d8:	af 92       	push	r10
    54da:	bf 92       	push	r11
    54dc:	cf 92       	push	r12
    54de:	df 92       	push	r13
    54e0:	ef 92       	push	r14
    54e2:	ff 92       	push	r15
    54e4:	0f 93       	push	r16
    54e6:	1f 93       	push	r17
    54e8:	cf 93       	push	r28
    54ea:	df 93       	push	r29
    54ec:	cd b7       	in	r28, 0x3d	; 61
    54ee:	de b7       	in	r29, 0x3e	; 62
    54f0:	ca 1b       	sub	r28, r26
    54f2:	db 0b       	sbc	r29, r27
    54f4:	0f b6       	in	r0, 0x3f	; 63
    54f6:	f8 94       	cli
    54f8:	de bf       	out	0x3e, r29	; 62
    54fa:	0f be       	out	0x3f, r0	; 63
    54fc:	cd bf       	out	0x3d, r28	; 61
    54fe:	09 94       	ijmp

00005500 <__epilogue_restores__>:
    5500:	2a 88       	ldd	r2, Y+18	; 0x12
    5502:	39 88       	ldd	r3, Y+17	; 0x11
    5504:	48 88       	ldd	r4, Y+16	; 0x10
    5506:	5f 84       	ldd	r5, Y+15	; 0x0f
    5508:	6e 84       	ldd	r6, Y+14	; 0x0e
    550a:	7d 84       	ldd	r7, Y+13	; 0x0d
    550c:	8c 84       	ldd	r8, Y+12	; 0x0c
    550e:	9b 84       	ldd	r9, Y+11	; 0x0b
    5510:	aa 84       	ldd	r10, Y+10	; 0x0a
    5512:	b9 84       	ldd	r11, Y+9	; 0x09
    5514:	c8 84       	ldd	r12, Y+8	; 0x08
    5516:	df 80       	ldd	r13, Y+7	; 0x07
    5518:	ee 80       	ldd	r14, Y+6	; 0x06
    551a:	fd 80       	ldd	r15, Y+5	; 0x05
    551c:	0c 81       	ldd	r16, Y+4	; 0x04
    551e:	1b 81       	ldd	r17, Y+3	; 0x03
    5520:	aa 81       	ldd	r26, Y+2	; 0x02
    5522:	b9 81       	ldd	r27, Y+1	; 0x01
    5524:	ce 0f       	add	r28, r30
    5526:	d1 1d       	adc	r29, r1
    5528:	0f b6       	in	r0, 0x3f	; 63
    552a:	f8 94       	cli
    552c:	de bf       	out	0x3e, r29	; 62
    552e:	0f be       	out	0x3f, r0	; 63
    5530:	cd bf       	out	0x3d, r28	; 61
    5532:	ed 01       	movw	r28, r26
    5534:	08 95       	ret

00005536 <memcpy>:
    5536:	fb 01       	movw	r30, r22
    5538:	dc 01       	movw	r26, r24
    553a:	02 c0       	rjmp	.+4      	; 0x5540 <memcpy+0xa>
    553c:	01 90       	ld	r0, Z+
    553e:	0d 92       	st	X+, r0
    5540:	41 50       	subi	r20, 0x01	; 1
    5542:	50 40       	sbci	r21, 0x00	; 0
    5544:	d8 f7       	brcc	.-10     	; 0x553c <memcpy+0x6>
    5546:	08 95       	ret

00005548 <memset>:
    5548:	dc 01       	movw	r26, r24
    554a:	01 c0       	rjmp	.+2      	; 0x554e <memset+0x6>
    554c:	6d 93       	st	X+, r22
    554e:	41 50       	subi	r20, 0x01	; 1
    5550:	50 40       	sbci	r21, 0x00	; 0
    5552:	e0 f7       	brcc	.-8      	; 0x554c <memset+0x4>
    5554:	08 95       	ret

00005556 <strncpy>:
    5556:	fb 01       	movw	r30, r22
    5558:	dc 01       	movw	r26, r24
    555a:	41 50       	subi	r20, 0x01	; 1
    555c:	50 40       	sbci	r21, 0x00	; 0
    555e:	48 f0       	brcs	.+18     	; 0x5572 <strncpy+0x1c>
    5560:	01 90       	ld	r0, Z+
    5562:	0d 92       	st	X+, r0
    5564:	00 20       	and	r0, r0
    5566:	c9 f7       	brne	.-14     	; 0x555a <strncpy+0x4>
    5568:	01 c0       	rjmp	.+2      	; 0x556c <strncpy+0x16>
    556a:	1d 92       	st	X+, r1
    556c:	41 50       	subi	r20, 0x01	; 1
    556e:	50 40       	sbci	r21, 0x00	; 0
    5570:	e0 f7       	brcc	.-8      	; 0x556a <strncpy+0x14>
    5572:	08 95       	ret

00005574 <itoa>:
    5574:	fb 01       	movw	r30, r22
    5576:	9f 01       	movw	r18, r30
    5578:	e8 94       	clt
    557a:	42 30       	cpi	r20, 0x02	; 2
    557c:	c4 f0       	brlt	.+48     	; 0x55ae <itoa+0x3a>
    557e:	45 32       	cpi	r20, 0x25	; 37
    5580:	b4 f4       	brge	.+44     	; 0x55ae <itoa+0x3a>
    5582:	4a 30       	cpi	r20, 0x0A	; 10
    5584:	29 f4       	brne	.+10     	; 0x5590 <itoa+0x1c>
    5586:	97 fb       	bst	r25, 7
    5588:	1e f4       	brtc	.+6      	; 0x5590 <itoa+0x1c>
    558a:	90 95       	com	r25
    558c:	81 95       	neg	r24
    558e:	9f 4f       	sbci	r25, 0xFF	; 255
    5590:	64 2f       	mov	r22, r20
    5592:	77 27       	eor	r23, r23
    5594:	0e 94 eb 2a 	call	0x55d6	; 0x55d6 <__udivmodhi4>
    5598:	80 5d       	subi	r24, 0xD0	; 208
    559a:	8a 33       	cpi	r24, 0x3A	; 58
    559c:	0c f0       	brlt	.+2      	; 0x55a0 <itoa+0x2c>
    559e:	89 5d       	subi	r24, 0xD9	; 217
    55a0:	81 93       	st	Z+, r24
    55a2:	cb 01       	movw	r24, r22
    55a4:	00 97       	sbiw	r24, 0x00	; 0
    55a6:	a1 f7       	brne	.-24     	; 0x5590 <itoa+0x1c>
    55a8:	16 f4       	brtc	.+4      	; 0x55ae <itoa+0x3a>
    55aa:	5d e2       	ldi	r21, 0x2D	; 45
    55ac:	51 93       	st	Z+, r21
    55ae:	10 82       	st	Z, r1
    55b0:	c9 01       	movw	r24, r18
    55b2:	0c 94 db 2a 	jmp	0x55b6	; 0x55b6 <strrev>

000055b6 <strrev>:
    55b6:	dc 01       	movw	r26, r24
    55b8:	fc 01       	movw	r30, r24
    55ba:	67 2f       	mov	r22, r23
    55bc:	71 91       	ld	r23, Z+
    55be:	77 23       	and	r23, r23
    55c0:	e1 f7       	brne	.-8      	; 0x55ba <strrev+0x4>
    55c2:	32 97       	sbiw	r30, 0x02	; 2
    55c4:	04 c0       	rjmp	.+8      	; 0x55ce <strrev+0x18>
    55c6:	7c 91       	ld	r23, X
    55c8:	6d 93       	st	X+, r22
    55ca:	70 83       	st	Z, r23
    55cc:	62 91       	ld	r22, -Z
    55ce:	ae 17       	cp	r26, r30
    55d0:	bf 07       	cpc	r27, r31
    55d2:	c8 f3       	brcs	.-14     	; 0x55c6 <strrev+0x10>
    55d4:	08 95       	ret

000055d6 <__udivmodhi4>:
    55d6:	aa 1b       	sub	r26, r26
    55d8:	bb 1b       	sub	r27, r27
    55da:	51 e1       	ldi	r21, 0x11	; 17
    55dc:	07 c0       	rjmp	.+14     	; 0x55ec <__udivmodhi4_ep>

000055de <__udivmodhi4_loop>:
    55de:	aa 1f       	adc	r26, r26
    55e0:	bb 1f       	adc	r27, r27
    55e2:	a6 17       	cp	r26, r22
    55e4:	b7 07       	cpc	r27, r23
    55e6:	10 f0       	brcs	.+4      	; 0x55ec <__udivmodhi4_ep>
    55e8:	a6 1b       	sub	r26, r22
    55ea:	b7 0b       	sbc	r27, r23

000055ec <__udivmodhi4_ep>:
    55ec:	88 1f       	adc	r24, r24
    55ee:	99 1f       	adc	r25, r25
    55f0:	5a 95       	dec	r21
    55f2:	a9 f7       	brne	.-22     	; 0x55de <__udivmodhi4_loop>
    55f4:	80 95       	com	r24
    55f6:	90 95       	com	r25
    55f8:	bc 01       	movw	r22, r24
    55fa:	cd 01       	movw	r24, r26
    55fc:	08 95       	ret

000055fe <_exit>:
    55fe:	f8 94       	cli

00005600 <__stop_program>:
    5600:	ff cf       	rjmp	.-2      	; 0x5600 <__stop_program>
